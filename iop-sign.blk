/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2017 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include <sysexits.h>
#include <lib-common/iop.h>
#include <lib-common/parseopt.h>
#include <lib-common/ssl.h>
#include <lib-common/datetime.h>

extern const char libcommon_git_revision[];

enum action {
    DO_SIGN,
    CHECK,
    GEN_TOKEN,
};

static struct {
    enum action action;
    int help, version, skip_missing, skip_default, use_class_id;
    int quiet_obsolete;
    int php_e_handler;
    const char *path_dso;
    const char *signed_iop;
    const char *data_field;
    const char *path_signed;
    const char *key_path;
    const char *activation_timeout;
    const char *token_timeout;
} opts;

static popt_t popt[] = {
    OPT_GROUP("Options:"),
    OPT_FLAG('h', "help",   &opts.help,        "show this help"),
    OPT_FLAG('V', "version", &opts.version,    "show version"),
    OPT_STR('d',  "dso",    &opts.path_dso,    "set iop dso path (mandatory)"),
    OPT_STR('s',  "signed", &opts.signed_iop,  "signed data iop struct (mandatory)"),
    OPT_STR('f',  "field",  &opts.data_field,  "set the data field name (mandatory)"),
    OPT_FLAG('m', "skip-missing", &opts.skip_missing,
             "skip optional missing fields in signature computation"),
    OPT_FLAG('n', "skip-default", &opts.skip_default,
             "skip fields having the default value in signature computation"),
#ifdef SSL_HAVE_EVP_PKEY
    OPT_STR('K', "key", &opts.key_path, "enable key-based signing"),
#endif
    OPT_FLAG('c', "class-id", &opts.use_class_id,
             "use class_id when hashing classes, using this option is highly "
             "recommended because it takes into account the exact used class "
             "instead of only relying on the unpacker for the type check"),

    OPT_STR('A', "activation-timeout", &opts.activation_timeout,
            "the product will be active until this date"),
    OPT_STR('T', "token-timeout", &opts.token_timeout,
            "the activation token will be usable until this date"),

    OPT_FLAG('q', "quiet", &opts.quiet_obsolete, "OBSOLETE, so not use"),

    OPT_FLAG('\0', "php", &opts.php_e_handler, "use php log handler"),

    OPT_END()
};

/* {{{ special log handler when calling the iop-sign tool from php */

void php_e_handler_f(int level, const char *fmt, va_list args)
    __attr_printf__(2, 0);

void php_e_handler_f(int level, const char *fmt, va_list args)
{
    if (level <= LOG_ERR) {
        vfprintf(stdout, fmt, args);
        fputc('\n', stdout);
        fflush(stdout);
    }
}

/* }}} */

static const iop_field_t *
find_field(const iop_struct_t *iop, const lstr_t field_name)
{
    const iop_field_t *field = NULL;

    for (int i = 0; i < iop->fields_len; i++) {
        field = &iop->fields[i];
        if (lstr_equal(field->name, field_name))
           return field;
    }

    return NULL;
}

#ifdef SSL_HAVE_EVP_PKEY

static pem_password_b prompt_pass = ^int (char *buf, int size, int rwflags) {
    char *pass = getpass("Enter the passphrase of the key: ");

    if (!pass) {
        return 0;
    }

    return snprintf(buf, size, "%s", pass);
};

#endif

static int fill_signature_timestamp(const iop_struct_t *desc,
                                    void *signed_data)
{
    return iop_for_each_field_fast(desc, signed_data,
                                   ^int (const iop_struct_t *st_desc,
                                         const iop_field_t *fdesc,
                                         void *st_ptr) {
        iop_value_t val;

        if (fdesc->type != IOP_T_I64) {
            return 0;
        }

        if (iop_field_get_gen_attr(st_desc, fdesc,
                                   LSTR("iopSign:signatureTs"), IOP_T_BOOL,
                                   NULL, &val) < 0
        ||  !val.b)
        {
            return 0;
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            opt_i64_t *ts = (opt_i64_t *)((byte *)st_ptr + fdesc->data_offs);

            OPT_SET(*ts, lp_getsec());
        } else {
            int64_t *tss;
            int len;

            iop_get_field_values(fdesc, st_ptr, (void **)&tss, &len, NULL);
            for (int i = 0; i < len; i++) {
                tss[i] = lp_getsec();
            }
        }

        return 0;
    });
}

static int
fill_and_check_fields(const iop_struct_t *desc,
                      const char *field_name, const char *iop_file,
                      lstr_t key)
{
    t_scope;

    const iop_field_t *sig_field;
    const iop_field_t *data_field;
    lstr_t            *signature;
    void              *signed_data = NULL;
    byte              *data;
    unsigned           flags = 0;
    core__activation_token__t token;
    t_SB_8k(fbuf);

    sig_field = find_field(desc, LSTR_IMMED_V("signature"));

    if (!sig_field) {
        return e_error("cannot find signature field in struct '%*pM'",
                       LSTR_FMT_ARG(desc->fullname));
    }

    if (sig_field->type != IOP_T_STRING)
        return e_error("signature field is not a string");

    data_field = find_field(desc, LSTR_STR_V(field_name));

    if (!data_field) {
        return e_error("cannot find '%*pM' field in struct '%*pM'",
                       LSTR_FMT_ARG(LSTR_STR_V(field_name)),
                       LSTR_FMT_ARG(desc->fullname));
    }

    if (data_field->type != IOP_T_STRUCT && data_field->type != IOP_T_UNION)
        return e_error("data field is not an IOP struct");

    if (t_iop_junpack_ptr_file(iop_file, desc, &signed_data, 0, NULL,
                               &fbuf) < 0)
    {
        return e_error("cannot get signed data of file '%s': %*pM",
                       iop_file, SB_FMT_ARG(&fbuf));
    }

    if (opts.action == DO_SIGN) {
        RETHROW(fill_signature_timestamp(desc, signed_data));
    }

    if (opts.token_timeout) {
        time_t activation_timeout;
        time_t token_timeout;

        if (!strequal(opts.signed_iop, "core.SignedLicence")) {
            return e_error("You must provide a core.SignedLicence.");
        }

        activation_timeout = lstrtotime(LSTR(opts.activation_timeout));
        if (activation_timeout < 0) {
            return e_error("Activation timeout malformed.");
        }
        token_timeout = lstrtotime(LSTR(opts.token_timeout));
        if (token_timeout < 0) {
            return e_error("Token timeout malformed.");
        }

        sb_reset(&fbuf);
        if (t_format_activation_token((core__signed_licence__t *)signed_data,
                                      activation_timeout, token_timeout,
                                      &token, &fbuf) < 0)
        {
            return fbuf.len > 0 ? e_error("%*pM\n", SB_FMT_ARG(&fbuf))
                                : e_error("can't format token");
        }

        if (opts.action == GEN_TOKEN) {
            printf("%*pM\n", LSTR_FMT_ARG(token.token));
            return 0;
        }
    }

    signature = (lstr_t *)((byte *)signed_data + sig_field->data_offs);
    data      = (byte *)signed_data + data_field->data_offs;
    if (iop_field_is_class(data_field)) {
        data = *(void **)data;
    }

    if (opts.skip_missing) {
        flags |= IOP_HASH_SKIP_MISSING;
    }
    if (opts.skip_default) {
        flags |= IOP_HASH_SKIP_DEFAULT;
    }
    if (!opts.use_class_id) {
        flags |= IOP_HASH_DONT_INCLUDE_CLASS_ID;
    }

    if (opts.action == DO_SIGN) {
#ifdef SSL_HAVE_EVP_PKEY
        if (key.s) {
            *signature = t_iop_compute_rsa_signature(data_field->u1.st_desc,
                                                     data, key, flags,
                                                     prompt_pass);
        } else
#endif
        {
            *signature = t_iop_compute_signature(data_field->u1.st_desc, data,
                                                 flags);
        }

        if (!signature->s) {
            return e_error("cannot compute signature");
        }

        /* Fill or remove activation token, if any. */
        if (opts.token_timeout) {
            core__signed_licence__t *licence = (void *)signed_data;

            licence->activation_token = &token;
        } else
        if (strequal(opts.signed_iop, "core.SignedLicence")) {
            core__signed_licence__t *licence = (void *)signed_data;

            licence->activation_token = NULL;
        }

        if (!opts.quiet_obsolete) {
            sb_reset(&fbuf);
            if (iop_sb_jpack(&fbuf, desc, signed_data, 0) < 0) {
                return e_error("cannot sign your file");
            }
            printf("%*pM\n", SB_FMT_ARG(&fbuf));
        } else {
            printf("%*pM\n", LSTR_FMT_ARG(*signature));
        }
    } else {
#ifdef SSL_HAVE_EVP_PKEY
        if (key.s) {
            if (iop_check_rsa_signature(data_field->u1.st_desc, data,
                                        key, *signature, flags,
                                        prompt_pass) < 0)
            {
                return e_error("invalid signature");
            }
        } else
#endif
        {
            if (iop_check_signature(data_field->u1.st_desc, data, *signature,
                                    flags) < 0)
            {
                return e_error("invalid signature");
            }
        }

        /* Check if activation token is valid. */
        if (strequal(opts.signed_iop, "core.SignedLicence")) {
            core__signed_licence__t *slicence = (void *)signed_data;
            int rc;

            sb_reset(&fbuf);
            rc = t_parse_activation_token(slicence->activation_token->token,
                                          slicence->licence, NULL, NULL,
                                          NULL, &fbuf);
            if (rc < 0) {
                return e_error("%*pM", SB_FMT_ARG(&fbuf));
            }
        }
        e_notice("signature of file '%*pM' is valid",
                 LSTR_FMT_ARG(LSTR_STR_V(opts.path_signed)));
    }

    return 0;
}

int main(int argc, char **argv)
{
    SB_1k(err);
    SB_1k(key_buf);
    const char         *argv0 = NEXTARG(argc, argv);
    const iop_struct_t *desc  = NULL;
    iop_dso_t  *dso;
    lstr_t key = LSTR_NULL;

    argc = parseopt(argc, argv, popt, 0);
    if (opts.version) {
        printf("%d.%d-%s-%s\n", LIB_COMMON_MAJOR, LIB_COMMON_MINOR,
               LIB_COMMON_VERSION, libcommon_git_revision);
        return 0;
    }
    if (opts.help) {
        goto usage;
    }
    if (!opts.path_dso) {
        e_error("missing dso path (-d)");
        goto usage;
    }
    if (!opts.signed_iop) {
        e_error("missing signed iop (-s)");
        goto usage;
    }
    if (!opts.data_field) {
        e_error("missing data field name to set (-f)");
        goto usage;
    }
    if (argc < 2) {
        goto usage;
    }
    if (strequal(argv[0], "sign")) {
        opts.action = DO_SIGN;
        if (!!opts.token_timeout != !!opts.activation_timeout) {
            e_error("please set neither or both -A and -T options");
            goto usage;
        }
    } else
    if (strequal(argv[0], "check")) {
        opts.action = CHECK;
    } else
    if (strequal(argv[0], "gen-token")) {
        opts.action = GEN_TOKEN;
        if (!opts.token_timeout) {
            e_error("missing token timeout (-T)");
            goto usage;
        }
        if (!opts.activation_timeout) {
            e_error("missing activation timeout (-A)");
            goto usage;
        }
    } else {
        e_error("invalid command: %s", argv[0]);
        goto usage;
    }

    if (opts.php_e_handler) {
        e_set_handler(php_e_handler_f);
    }

    opts.path_signed = argv[1];
    dso = iop_dso_open(opts.path_dso, LM_ID_BASE, &err);
    if (!dso) {
        e_fatal("cannot open DSO file '%s': %*pM", opts.path_dso,
                SB_FMT_ARG(&err));
    }

    desc = iop_dso_find_type(dso, LSTR_STR_V(opts.signed_iop));
    if (!desc) {
        iop_dso_close(&dso);
        e_fatal("cannot find %s in the DSO file", opts.signed_iop);
    }

    if (opts.key_path) {
        if (sb_read_file(&key_buf, opts.key_path) < 0) {
            e_fatal("cannot read key file at `%s`: %m", opts.key_path);
        }

        key = LSTR_SB_V(&key_buf);
    }


    if (fill_and_check_fields(desc, opts.data_field, opts.path_signed, key) < 0)
    {
        iop_dso_close(&dso);
        return -1;
    }

    iop_dso_close(&dso);
    return 0;

  usage:
    makeusage(EX_USAGE, argv0, "<command> <file>\n\
\n\
commands: sign, check, gen-token\n\
\n\
Examples with a One licence (from the One directory):\n\
    # to sign the licence\n\
    iop-sign -mnc -d ./one.so -s core.SignedLicence -f licence \\\n\
        sign ./etc/dev/licence.cf\n\
    # to get an activation token for the licence\n\
    iop-sign -mnc -d ./one.so -s core.SignedLicence -f licence \\\n\
        -A 24-Jan-2029 -T 25-Jan-2029\n\
        gen-token ./etc/dev/licence.cf\n\
    # to sign the licence with an embeded activation token\n\
    iop-sign -mnc -d ./one.so -s core.SignedLicence -f licence \\\n\
        -A 24-Jan-2029\n\
        sign ./etc/dev/licence.cf\n\
    # to check the licence\n\
    iop-sign -mnc -d ./one.so -s core.SignedLicence -f licence \\\n\
        check ./etc/dev/licence.cf", NULL, popt);
}
