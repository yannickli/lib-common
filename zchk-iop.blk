/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2018 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

/* LCOV_EXCL_START */

#include "z.h"
#include "iop.h"
#include "iop/tstiop.iop.h"

/* {{{ Helpers */

/* {{{ iop.iop_for_each_field */

struct z_iop_for_each_step {
    const iop_struct_t *st_desc;
    const void *st_ptr;
    const char *fname;
};

qvector_t(z_iop_for_each_step, struct z_iop_for_each_step);

static void
_z_append_step(qv_t(z_iop_for_each_step) *vec, const iop_struct_t *st_desc,
               const void *st_ptr, const char *fname)
{
    struct z_iop_for_each_step *step;

    step = qv_growlen(z_iop_for_each_step, vec, 1);
    step->st_desc = st_desc;
    step->st_ptr = st_ptr;
    step->fname = fname;
}

#define z_append_step(vec, st_pfx, st_ptr, fname)                            \
    _z_append_step((vec), &st_pfx##__s, (st_ptr), (fname))

static int
z_check_iop_for_each_step(const struct z_iop_for_each_step *step,
                          const iop_struct_t *st_desc, void *st_ptr,
                          lstr_t fname)
{
    Z_ASSERT(st_desc == step->st_desc,
             "wrong st_dest, got %*pM, expected %*pM",
             LSTR_FMT_ARG(st_desc->fullname),
             LSTR_FMT_ARG(step->st_desc->fullname));
    Z_ASSERT(st_ptr == step->st_ptr, "wrong st_ptr, expected %p, got %p",
             st_ptr, step->st_ptr);
    Z_ASSERT_LSTREQUAL(fname, LSTR(step->fname), "wrong field");
    Z_HELPER_END;
}

static int
z_iop_for_each_step(const qv_t(z_iop_for_each_step) *steps,
                    const iop_struct_t *_st_desc, void *_st_ptr, int *count)
{
    return iop_for_each_field(_st_desc, _st_ptr,
    ^int (const iop_struct_t *st_desc, const iop_field_t *fdesc, void *st_ptr)
    {
        int pos = (*count)++;

        Z_ASSERT_LT(pos, steps->len, "unexpected step");
        Z_HELPER_RUN(z_check_iop_for_each_step(&steps->tab[pos], st_desc,
                                               st_ptr, fdesc->name));
        Z_HELPER_END;
    });
}

static int t_z_load_iop_for_each_json(tstiop__z_iop_for_each__t **z_struct)
{
    SB_1k(errb);
    tstiop__z_iop_for_each__t *res = NULL;
    const char *path = t_fmt("%ssamples/z-iop-for-each.json", z_cmddir_g.s);

    Z_ASSERT_N(t_iop_junpack_ptr_file(path, &tstiop__z_iop_for_each__s,
                                      (void **)&res, 0, NULL, &errb),
               "failed to read JSON file: %*pM", SB_FMT_ARG(&errb));

    *z_struct = res;
    Z_HELPER_END;
}

static int
z_test_iop_for_each_field(const tstiop__z_iop_for_each__t *z_struct)
{
    t_scope;
    int count = 0;
    qv_t(z_iop_for_each_step) steps;

    t_qv_init(z_iop_for_each_step, &steps, 128);
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "voidStruct1");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "integer");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "optUint1");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "ulongTab");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "optUint2");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "miniStruct");
    z_append_step(&steps, tstiop__mini_struct, &z_struct->mini_struct, "a");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "emptyTab");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "refTabStruct");
    z_append_step(&steps, tstiop__tab_struct, z_struct->ref_tab_struct,
                  "tab");
    tab_for_each_ptr(ptr, &z_struct->ref_tab_struct->tab) {
        z_append_step(&steps, tstiop__mini_struct, ptr, "a");
    }
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "optUnion1");
    z_append_step(&steps, tstiop__a_or_b, z_struct->opt_union1, "b");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "voidStruct2");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "optUnion2");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "ancestor");
    z_append_step(&steps, tstiop__ancestor, z_struct->ancestor, "name");
    z_append_step(&steps, tstiop__daddy, z_struct->ancestor, "b");
    z_append_step(&steps, tstiop__z_iop_for_each, z_struct, "objTab");
    tab_for_each_entry(ptr, &z_struct->obj_tab) {
        z_append_step(&steps, tstiop__ancestor, ptr, "name");
    }

    Z_HELPER_RUN(z_iop_for_each_step(&steps, &tstiop__z_iop_for_each__s,
                                     (void *)z_struct, &count));

    Z_ASSERT_EQ(count, 24);
    Z_HELPER_END;
}

static int
z_test_iop_for_each_st(const tstiop__z_iop_for_each__t *z_struct)
{
    __block int pos = 0;

    return iop_for_each_st(&tstiop__z_iop_for_each__s, (void *)z_struct,
                           ^int (const iop_struct_t *st_desc, void *st_ptr) {
        t_scope;
        SB_1k(sb);
        const char *structs[] = {
            "ZIopForEach", "Void", "MiniStruct", "TabStruct", "MiniStruct",
           "MiniStruct", "MiniStruct", "AOrB", "Void", "Daddy", "GrandPa",
           "GrandPa", "GrandPa"
        };

        int _pos = pos++;
        lstr_t expected_st_name;

        Z_ASSERT_LT(_pos, countof(structs), "unexpected struct, type name = "
                    "`%*pM`", LSTR_FMT_ARG(st_desc->fullname));

        expected_st_name = t_lstr_fmt("tstiop.%s", structs[_pos++]);

        /* Check that we probably have a correct pointer here. */
        Z_ASSERT_N(iop_sb_jpack(&sb, st_desc, st_ptr, IOP_JPACK_MINIMAL),
                   "failed to write field in JSON");

        Z_ASSERT_LSTREQUAL(st_desc->fullname, expected_st_name,
                           "expected a `%*pM', got a `%*pM', value=%*pM",
                           LSTR_FMT_ARG(expected_st_name),
                           LSTR_FMT_ARG(st_desc->fullname), SB_FMT_ARG(&sb));
        Z_HELPER_END;
    });
}
/* }}} */

/* }}} */

Z_GROUP_EXPORT(iop_blk) {
    IOP_REGISTER_PACKAGES(&tstiop__pkg);

    Z_TEST(iop_for_each, "test iop_for_each") { /* {{{ */
        t_scope;
        tstiop__z_iop_for_each__t *z_struct;

        Z_HELPER_RUN(t_z_load_iop_for_each_json(&z_struct));
        Z_HELPER_RUN(z_test_iop_for_each_field(z_struct),
                     "iop_for_each_field");
        Z_HELPER_RUN(z_test_iop_for_each_st(z_struct),
                     "iop_for_each_st");
    } Z_TEST_END
    /* }}} */
} Z_GROUP_END;

/* LCOV_EXCL_STOP */
