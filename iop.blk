/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2013 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "arith.h"
#include "iop.h"
#include "iop-helpers.inl.c"
#include "thr.h"
#include "container.h"
#include "sort.h"

/*------ Local declarations -{{{-*/

typedef struct class_id_key_t {
    const iop_struct_t *master;
    uint16_t            child_id;
} class_id_key_t;

static inline uint32_t
class_id_key_hash(const qhash_t *h, const class_id_key_t *key)
{
    return mem_hash32(key, offsetof(class_id_key_t, child_id) + 2);
}
static inline bool
class_id_key_equal(const qhash_t *h, const class_id_key_t *k1,
                   const class_id_key_t *k2)
{
    return (k1->master == k2->master) && (k1->child_id == k2->child_id);
}

qm_kvec_t(class_id, class_id_key_t, const iop_struct_t *,
          class_id_key_hash, class_id_key_equal);

typedef struct class_name_key_t {
    const iop_struct_t *master;
    const lstr_t       *child_fullname;
} class_name_key_t;

static inline uint32_t
class_name_key_hash(const qhash_t *h, const class_name_key_t *key)
{
    return qhash_hash_ptr(h, key->master)
         ^ qhash_lstr_hash(h, key->child_fullname);
}
static inline bool
class_name_key_equal(const qhash_t *h, const class_name_key_t *k1,
                   const class_name_key_t *k2)
{
    return (k1->master == k2->master)
         && lstr_equal(k1->child_fullname, k2->child_fullname);
}

qm_kvec_t(class_name, class_name_key_t, const iop_struct_t *,
          class_name_key_hash, class_name_key_equal);

/*------ Local declarations -}}}-*/

static struct {
    qm_t(class_id)   classes_by_id;
    qm_t(class_name) classes_by_name;
} iop_g = {
#define _G  iop_g
    .classes_by_id   = QM_INIT(class_id,   _G.classes_by_id,   false),
    .classes_by_name = QM_INIT(class_name, _G.classes_by_name, false),
};

/*------ iop_init -{{{-*/

static void
iop_init_fields(void *value, const iop_field_t *fdesc, const iop_field_t *end)
{
    for (; fdesc < end; fdesc++) {
        void *ptr = (char *)value + fdesc->data_offs;

        if (fdesc->repeat == IOP_R_REQUIRED && fdesc->type == IOP_T_STRUCT) {
            /* We can't handle the unions here since we don't know which field
             * has been selected */
            const iop_struct_t *desc = fdesc->u1.st_desc;

            if (iop_struct_is_class(desc)) {
                /* Field is a mandatory class instance, and should be init as
                 * an optional field: NULL pointer. */
                continue;
            }

            iop_init_fields(ptr, desc->fields, desc->fields +
                            desc->fields_len);
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            switch (fdesc->type) {
              case IOP_T_I8: case IOP_T_U8:
                *(uint8_t *)ptr  = fdesc->u1.defval_u64;
                break;
              case IOP_T_I16: case IOP_T_U16:
                *(uint16_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_ENUM:
                *(uint32_t *)ptr = fdesc->u0.defval_enum;
                break;
              case IOP_T_I32: case IOP_T_U32:
                *(uint32_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_I64: case IOP_T_U64:
                *(uint64_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_BOOL:
                *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
                break;
              case IOP_T_DOUBLE:
                *(double *)ptr   = fdesc->u1.defval_d;
                break;
              case IOP_T_STRING:
              case IOP_T_XML:
                *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data, fdesc->u0.defval_len);
                break;
              case IOP_T_DATA:
                ((lstr_t *)ptr)->len      = fdesc->u0.defval_len;
                ((lstr_t *)ptr)->data     = (void *)fdesc->u1.defval_data;
                ((lstr_t *)ptr)->mem_pool = 0;
                break;
              default:
                e_panic("unsupported");
                continue;
            }
        }
    }
}
void iop_init(const iop_struct_t *desc, void *value)
{
    memset(value, 0, desc->size);

    if (iop_struct_is_class(desc)) {
        const iop_struct_t **__vptr = value;
        const iop_struct_t *parent = desc;

        *__vptr = desc;

        while ((parent = parent->class_attrs->parent)) {
            iop_init_fields(value, parent->fields,
                            parent->fields + parent->fields_len);
        }
    }

    iop_init_fields(value, desc->fields, desc->fields + desc->fields_len);
}

/*------ iop_init -}}}-*/
/*----- duplicating values -{{{-*/

static size_t iop_dup_size(const iop_struct_t *desc, const void *val);

static size_t __iop_dup_size(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    size_t len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        bool is_class = iop_field_is_class(fdesc);
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n    = ((lstr_t *)ptr)->len;
            ptr  = ((lstr_t *)ptr)->data;
            len += ROUND_UP(n * fdesc->size, 8);
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                ptr = *(void **)ptr;
                if (is_class) {
                    /* Do not take the field size, but the size of the
                     * actually instanciated class */
                    len += ROUND_UP((*(const iop_struct_t **)ptr)->size, 8);
                } else {
                    len += ROUND_UP(fdesc->size, 8);
                }
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

                if (is_class) {
                    if (fdesc->repeat != IOP_R_OPTIONAL) {
                        /* Non-optional class fields have to be dereferenced
                         * (dereferencing of optional fields was already done
                         *  just above).
                         */
                        v = *(void **)v;
                        len += ROUND_UP((*(const iop_struct_t **)v)->size, 8);
                    }
                    len += iop_dup_size(fdesc->u1.st_desc, v);
                } else {
                    len += __iop_dup_size(fdesc->u1.st_desc, v);
                }
            }
        } else {
            for (int j = 0; j < n; j++) {
                len += ROUND_UP(IOP_FIELD(lstr_t, ptr, j).len + 1, 8);
            }
        }
    }

    return len;
}

static size_t iop_dup_size(const iop_struct_t *desc, const void *val)
{
    if (iop_struct_is_class(desc)) {
        size_t len = 0;

        desc = *(const iop_struct_t **)val;
        do {
            len += __iop_dup_size(desc, val);
        } while ((desc = desc->class_attrs->parent));

        return len;
    } else {
        return __iop_dup_size(desc, val);
    }
}

static uint8_t *realign(uint8_t *ptr)
{
    return (uint8_t *)ROUND_UP((uintptr_t)ptr, 8);
}

static uint8_t *__iop_copy_class(const iop_struct_t *st, uint8_t *dst,
                                 void *wval, const void *rval);

static uint8_t *
__iop_copy(const iop_struct_t *st, uint8_t *dst, void *wval, const void *rval)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        fdesc = get_union_field(st, rval);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *rp = (char *)rval + fdesc->data_offs;
        const void *wp = (char *)wval + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)rp)->len;
            rp  = ((lstr_t *)rp)->data;
            wp  = ((lstr_t *)wp)->data = dst;
            dst = realign(mempcpy(dst, rp, n * fdesc->size));
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, rp))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                rp = *(void **)rp;
                wp = *(void **)wp = dst;
                if (!iop_field_is_class(fdesc)) {
                    /* Will be done in __iop_copy_class for classes */
                    dst = realign(mempcpy(dst, rp, fdesc->size));
                }
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            bool is_class = iop_field_is_class(fdesc);

            for (int j = 0; j < n; j++) {
                const void *rv = &IOP_FIELD(const char, rp, j * fdesc->size);
                void       *wv = &IOP_FIELD(char,       wp, j * fdesc->size);

                if (is_class) {
                    if (fdesc->repeat != IOP_R_OPTIONAL) {
                        /* Non-optional class fields have to be dereferenced
                         * (dereferencing of optional fields was already done
                         *  just above).
                         */
                        rv = *(void **)rv;
                        wv = *(void **)wv = dst;
                    }
                    dst = __iop_copy_class(fdesc->u1.st_desc, dst, wv, rv);
                } else {
                    dst = __iop_copy(fdesc->u1.st_desc, dst, wv, rv);
                }
            }
        } else
        if (fdesc->type == IOP_T_STRING || fdesc->type == IOP_T_XML) {
            for (int j = 0; j < n; j++) {
                lstr_t *orig = &IOP_FIELD(lstr_t, rp, j);

                /* We have to fix the lstr_t mem_pool manually because some
                 * naughty programmers could have played with it */
                IOP_FIELD(lstr_t, wp, j).s = (const char *)dst;
                IOP_FIELD(lstr_t, wp, j).mem_pool = MEM_STATIC;
                dst = realign(mempcpyz(dst, orig->s, orig->len));
            }
        } else {
            for (int j = 0; j < n; j++) {
                lstr_t *orig = &IOP_FIELD(lstr_t, rp, j);

                IOP_FIELD(lstr_t, wp, j).data = dst;
                dst = realign(mempcpyz(dst, orig->data, orig->len));
            }
        }
    }

    return dst;
}

static uint8_t *__iop_copy_class(const iop_struct_t *st, uint8_t *dst,
                                 void *wval, const void *rval)
{
    st = *(const iop_struct_t **)rval;
    dst = realign(mempcpy(dst, rval, st->size));

    do {
        dst = __iop_copy(st, dst, wval, rval);
    } while ((st = st->class_attrs->parent));

    return dst;
}

void *iop_dup(mem_pool_t *mp, const iop_struct_t *st, const void *v)
{
    size_t sz;
    uint8_t *dst, *res;

    RETHROW_P(v);

    if (iop_struct_is_class(st)) {
        st = *(const iop_struct_t **)v;
    }

    sz = ROUND_UP(st->size, 8) + __iop_dup_size(st, v);
    res = mp ? mp->malloc(mp, sz, MEM_RAW) : imalloc(sz, MEM_LIBC | MEM_RAW);
    dst = realign(mempcpy(res, v, st->size));
    dst = __iop_copy(st, dst, res, v);
    assert (dst == res + sz);
    return res;
}

void iop_copy(mem_pool_t *mp, const iop_struct_t *st, void **outp, const void *v)
{
    size_t sz;
    uint8_t *dst, *res = *outp;

    if (unlikely(!v)) {
        if (mp) {
            mp_delete(mp, outp);
        } else {
            p_delete(outp);
        }

        return;
    }

    if (iop_struct_is_class(st)) {
        st = *(const iop_struct_t **)v;
    }

    sz = ROUND_UP(st->size, 8) + __iop_dup_size(st, v);

    if (mp) {
        res = mp->realloc(mp, res, 0, sz, MEM_RAW);
    } else {
        res = irealloc(res, 0, sz, MEM_LIBC | MEM_RAW);
    }
    dst = realign(mempcpy(res, v, st->size));
    dst = __iop_copy(st, dst, res, v);
    assert (dst == res + sz);
    *outp = res;
}

/*----- duplicating values -}}}-*/
/*----- comparing values -{{{-*/

static bool
__iop_equals(const iop_struct_t *st, const uint8_t *v1, const uint8_t *v2)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        if (*(uint16_t *)v1 != *(uint16_t *)v2)
            return false;
        fdesc = get_union_field(st, v1);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r1 = v1 + fdesc->data_offs;
        const void *r2 = v2 + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            /* Here we just check the length of the repeated field, then we
             * position our pointers on values to compare them later. */
            n   = ((lstr_t *)r1)->len;
            if (((lstr_t *)r2)->len != n)
                return false;
            r1  = ((lstr_t *)r1)->data;
            r2  = ((lstr_t *)r2)->data;
        }

        if (fdesc->repeat == IOP_R_OPTIONAL
        &&  ((1 << fdesc->type) & IOP_BLK_OK))
        {
            /* Optional blocks types cannot be compared using a single memcmp
             * we need to handle absent values first. */
            bool has = iop_value_has(fdesc, r1);

            if (has != iop_value_has(fdesc, r2))
                return false;
            if (!has)
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                /* Structures & unions must be dereferenced */
                r1  = *(void **)r1;
                r2  = *(void **)r2;
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            bool is_class = iop_field_is_class(fdesc);

            /* We need to recurse to compare structures & unions. */
            for (int i = 0; i < n; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if (is_class) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done just
                     *  above).
                     */
                    if (fdesc->repeat != IOP_R_OPTIONAL) {
                        t1  = *(void **)t1;
                        t2  = *(void **)t2;
                    }
                    THROW_IF(!iop_equals(fdesc->u1.st_desc, t1, t2), false);
                } else {
                    THROW_IF(!__iop_equals(fdesc->u1.st_desc, t1, t2), false);
                }
            }
        } else
        if ((1 << fdesc->type) & IOP_BLK_OK) {
            /* Blocks (string & co) must be compared one by one */
            for (int i = 0; i < n; i++) {
                const lstr_t *t1 = &IOP_FIELD(const lstr_t, r1, i);
                const lstr_t *t2 = &IOP_FIELD(const lstr_t, r2, i);

                if (t1->len != t2->len || memcmp(t1->data, t2->data, t1->len))
                    return false;
            }
        } else {
            /* Scalar types (even repeated) could be compared with one big
             * memcmp */
            assert (fdesc->size > 0 && "IOPC is probably outdated");
            if (memcmp(r1, r2, fdesc->size * n))
                return false;
        }
    }

    return true;
}

bool iop_equals(const iop_struct_t *st, const void *v1, const void *v2)
{
    if (v1 && v2) {
        if (iop_struct_is_class(st)) {
            const iop_struct_t *st2 = *(const iop_struct_t **)v2;

            st = *(const iop_struct_t **)v1;
            if (st != st2) {
                return false;
            }

            do {
                if (!__iop_equals(st, v1, v2)) {
                    return false;
                }
            } while ((st = st->class_attrs->parent));

            return true;
        }

        return __iop_equals(st, v1, v2);
    } else {
        return v1 == v2;
    }
}

static inline bool
iop_field_is_defval(const iop_field_t *fdesc, const void *ptr)
{
    assert (fdesc->repeat == IOP_R_DEFVAL);

    switch (fdesc->type) {
      case IOP_T_I8: case IOP_T_U8:
        return *(uint8_t *)ptr == (uint8_t)fdesc->u1.defval_u64;
      case IOP_T_I16: case IOP_T_U16:
        return *(uint16_t *)ptr == (uint16_t)fdesc->u1.defval_u64;
      case IOP_T_ENUM:
        return *(int *)ptr == fdesc->u0.defval_enum;
      case IOP_T_I32: case IOP_T_U32:
        return *(uint32_t *)ptr == (uint32_t)fdesc->u1.defval_u64;
      case IOP_T_I64: case IOP_T_U64:
      case IOP_T_DOUBLE:
        /* XXX double is handled like U64 because we want to compare them as
         * bit to bit */
        return *(uint64_t *)ptr == fdesc->u1.defval_u64;
      case IOP_T_BOOL:
        return fdesc->u1.defval_u64 ? *(bool *)ptr : !*(bool *)ptr;
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        if (!fdesc->u0.defval_len) {
            /* In this case we don't care about the string pointer. An empty
             * string is an empty string whatever its pointer is. */
            return !((lstr_t *)ptr)->len;
        } else {
            /* We consider a NULL string as “take the default value please”
             * and otherwise we check for the pointer equality. */
            return !((lstr_t *)ptr)->data
                || (((lstr_t *)ptr)->data == fdesc->u1.defval_data
                 && ((lstr_t *)ptr)->len  == fdesc->u0.defval_len);
        }
      default:
        e_panic("unsupported");
    }
}

/*----- comparing values -}}}-*/
/*----- sorting values -{{{-*/

/* {{{ Field path */

typedef struct field_step_t {
    uint16_t offset;
    uint16_t union_tag;
    flag_t   is_union   : 1;
} field_step_t;
GENERIC_INIT(field_step_t, field_step);

qvector_t(field_step, field_step_t);

typedef struct field_path_t {
    qv_t(field_step)    steps;
    const iop_field_t  *fdesc;
} field_path_t;
GENERIC_FUNCTIONS(field_path_t, field_path);

/* {{{ Get */

static const void *
iop_get_fieldp(const void *data, const field_path_t *field_path)
{
    const qv_t(field_step)  *steps = &field_path->steps;
    const iop_field_t       *fdesc = field_path->fdesc;

    RETHROW_P(data);

    for (int i = 0; i < steps->len - 1; i++) {
        field_step_t *step = &steps->tab[i];

        data = ((const byte *)data) + step->offset;

        if (step->is_union) {
            /* Check if the selected member of the union is the one we want
             * (the one specified in field_path), and if not this object is
             * considered as NULL in the sort */
            if (*(const uint16_t *)data != step->union_tag) {
                return NULL;
            }
        } else {
            /* Pointed structure or union (optional) */
            data = RETHROW_P(*((void **)data));
        }
    }

    data = ((const byte *)data) + qv_last(field_step, steps)->offset;

    /* XXX we sort union based on the union tag */
    if (fdesc->type == IOP_T_UNION) {
        return (const uint16_t *)data;
    }

    if (fdesc->repeat != IOP_R_OPTIONAL) {
        return data;
    }

    switch (fdesc->type) {
      case IOP_T_I8:
      case IOP_T_U8:
        return OPT_GET((const iop_opt_u8_t *)data);
      case IOP_T_I16:
      case IOP_T_U16:
        return OPT_GET((const iop_opt_u16_t *)data);
      case IOP_T_ENUM:
      case IOP_T_I32:
      case IOP_T_U32:
        return OPT_GET((const iop_opt_u32_t *)data);
      case IOP_T_I64:
      case IOP_T_U64:
        return OPT_GET((const iop_opt_u64_t *)data);
      case IOP_T_BOOL:
        return OPT_GET((const iop_opt_bool_t *)data);
      case IOP_T_DOUBLE:
        return OPT_GET((const iop_opt_double_t *)data);
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        return ((const lstr_t *)data)->s ? data : NULL;
      default:
        assert (false);
        return NULL;
    }
}

/* }}} */
/* {{{ Compile */

static int
t_iop_compile_field_path(const iop_struct_t *st, lstr_t field_path_s,
                         field_path_t *fp)
{
    const iop_field_t *fdesc = NULL;
    pstream_t field_path_ps = ps_initlstr(&field_path_s);
    const iop_struct_t *it = st;
    field_step_t *step;

    if (ps_done(&field_path_ps)) {
        return e_error("iop_sort: cannot process empty field path");
    }
    step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
    while (!ps_done(&field_path_ps)) {
        pstream_t fname;
        int ifield;

        if (ps_get_ps_chr_and_skip(&field_path_ps, '.', &fname) < 0) {
            fname = field_path_ps;
            __ps_skip_upto(&field_path_ps, field_path_ps.p_end);
        }

        if (ps_done(&fname)) {
            return e_error("iop_sort: cannot process field path `%*pM', "
                           "abnormal termination",
                           LSTR_FMT_ARG(field_path_s));
        }

        ifield = __iop_field_find_by_name(it, fname.s, ps_len(&fname));
        if (ifield < 0) {
            return e_error("iop_sort: cannot process field path `%*pM', "
                           "field `%*pM' is unknown",
                           LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname));
        }

        fdesc = it->fields + ifield;
        if (fdesc->repeat == IOP_R_REPEATED) {
            /* XXX we could also sort the repeated fields based on their
             * number of elements
             */
            return e_error("iop_sort: cannot process field path `%*pM', "
                           "field `%*pM' is repeated",
                           LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname));
        }
        if (it->is_union) {
            step->is_union = true;
            step->union_tag = fdesc->tag;
            step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
        }

        step->offset += fdesc->data_offs;
        if (fdesc->type == IOP_T_STRUCT || fdesc->type == IOP_T_UNION) {
            it = fdesc->u1.st_desc;

            if (fdesc->repeat == IOP_R_OPTIONAL) {
                step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
            }
        }
    }

    fp->fdesc = fdesc;

    return 0;
}

/* }}} */

/* }}} */
/* {{{ cmp functions */

static cmp_f const iop_cmp_funs[] = {
    [IOP_T_I8]          = &cmp_i8,
    [IOP_T_U8]          = &cmp_u8,
    [IOP_T_I16]         = &cmp_i16,
    [IOP_T_U16]         = &cmp_u16,
    [IOP_T_ENUM]        = &cmp_i32,
    [IOP_T_I32]         = &cmp_i32,
    [IOP_T_U32]         = &cmp_u32,
    [IOP_T_I64]         = &cmp_i64,
    [IOP_T_U64]         = &cmp_u64,
    [IOP_T_BOOL]        = &cmp_bool,
    [IOP_T_DOUBLE]      = &cmp_double,
    [IOP_T_UNION]       = &cmp_u16,
    [IOP_T_STRING]      = &cmp_lstr_iutf8,
    [IOP_T_XML]         = &cmp_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_lstr_iutf8,
};
static cmp_f const iop_cmp_rev_funs[] = {
    [IOP_T_I8]          = &cmp_rev_i8,
    [IOP_T_U8]          = &cmp_rev_u8,
    [IOP_T_I16]         = &cmp_rev_i16,
    [IOP_T_U16]         = &cmp_rev_u16,
    [IOP_T_ENUM]        = &cmp_rev_i32,
    [IOP_T_I32]         = &cmp_rev_i32,
    [IOP_T_U32]         = &cmp_rev_u32,
    [IOP_T_I64]         = &cmp_rev_i64,
    [IOP_T_U64]         = &cmp_rev_u64,
    [IOP_T_BOOL]        = &cmp_rev_bool,
    [IOP_T_DOUBLE]      = &cmp_rev_double,
    [IOP_T_UNION]       = &cmp_rev_u16,
    [IOP_T_STRING]      = &cmp_rev_lstr_iutf8,
    [IOP_T_XML]         = &cmp_rev_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_rev_lstr_iutf8,
};

/*}}}*/

int iop_sort(const iop_struct_t *st, void *vec, int len,
             lstr_t field_path_s, int flags)
{
    t_scope;
    field_path_t fp;
    cmp_f cmp;

    field_path_init(&fp);
    t_qv_init(field_step, &fp.steps, 16);
    if (t_iop_compile_field_path(st, field_path_s, &fp) < 0) {
        return -1;
    }

    if (fp.fdesc == NULL) {
        return e_error("iop_sort: no field specified");
    }
    if (fp.fdesc->type == IOP_T_STRUCT) {
        return e_error("iop_sort: cannot sort on struct");
    }

    if (flags & IOP_SORT_REVERSE) {
        cmp = iop_cmp_rev_funs[fp.fdesc->type];
    } else {
        cmp = iop_cmp_funs[fp.fdesc->type];
    }

    __qv_sort(vec, st->size, len,
    ^int (const void *d1, const void *d2) {
        d1 = iop_get_fieldp(d1, &fp);
        d2 = iop_get_fieldp(d2, &fp);
        if (d1 == d2)
            return 0;
        if (d1 == NULL)
            return (flags & IOP_SORT_NULL_FIRST) ? -1 : 1;
        if (d2 == NULL)
            return (flags & IOP_SORT_NULL_FIRST) ? 1 : -1;
        return (*cmp)(d1, d2);
    });

    return 0;
}

/* }}} */
/*----- hashing values -{{{-*/

struct iop_hash_ctx {
    size_t   pos;
    uint8_t  buf[1024];
    void   (*hfun)(void *ctx, const void *input, int len);
    void    *ctx;
};

static ALWAYS_INLINE
void iop_hash_update(struct iop_hash_ctx *ctx, const void *d, size_t len)
{
    size_t pos = ctx->pos;

    if (pos + len > sizeof(ctx->buf)) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
        ctx->hfun(ctx->ctx, d, len);
    } else {
        memcpy(ctx->buf + pos, d, len);
        if ((pos += len) > sizeof(ctx->buf) / 2) {
            ctx->pos = 0;
            ctx->hfun(ctx->ctx, ctx->buf, pos);
        } else {
            ctx->pos = pos;
        }
    }
}

static ALWAYS_INLINE
void iop_hash_update_u16(struct iop_hash_ctx *ctx, uint16_t i)
{
    size_t pos = ctx->pos;

    assert (pos + 2 < sizeof(ctx->buf));
    put_unaligned_le16(ctx->buf + pos, i);
    if ((pos += 2) > sizeof(ctx->buf) / 2) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
    } else {
        ctx->pos = pos;
    }
}

static ALWAYS_INLINE
void iop_hash_update_u32(struct iop_hash_ctx *ctx, uint32_t i)
{
    size_t pos = ctx->pos;

    assert (pos + 4 < sizeof(ctx->buf));
    put_unaligned_le32(ctx->buf + pos, i);
    if ((pos += 4) > sizeof(ctx->buf) / 2) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
    } else {
        ctx->pos = pos;
    }
}

static ALWAYS_INLINE
void iop_hash_update_i64(struct iop_hash_ctx *ctx, int64_t i)
{
    size_t pos = ctx->pos;

    assert (pos + 8 < sizeof(ctx->buf));
    put_unaligned_le64(ctx->buf + pos, i);
    if ((pos += 8) > sizeof(ctx->buf) / 2) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
    } else {
        ctx->pos = pos;
    }
}
#define iop_hash_update_dbl(ctx, d) \
    iop_hash_update_i64(ctx, double_bits_cpu(d))

static void
iop_opt_hash(struct iop_hash_ctx *ctx, const iop_field_t *f, const void *v)
{
    uint8_t b;

    switch (f->type) {
      case IOP_T_BOOL:
        b = !!((iop_opt_bool_t *)v)->v;
        iop_hash_update(ctx, &b, 1);
        break;
      case IOP_T_I8:
        iop_hash_update_i64(ctx, ((iop_opt_i8_t *)v)->v);
        break;
      case IOP_T_U8:
        iop_hash_update_i64(ctx, ((iop_opt_u8_t *)v)->v);
        break;
      case IOP_T_I16:
        iop_hash_update_i64(ctx, ((iop_opt_i16_t *)v)->v);
        break;
      case IOP_T_U16:
        iop_hash_update_i64(ctx, ((iop_opt_u16_t *)v)->v);
        break;
      case IOP_T_I32: case IOP_T_ENUM:
        iop_hash_update_i64(ctx, ((iop_opt_i32_t *)v)->v);
        break;
      case IOP_T_U32:
        iop_hash_update_i64(ctx, ((iop_opt_u32_t *)v)->v);
        break;
      case IOP_T_I64:
        iop_hash_update_i64(ctx, ((iop_opt_i64_t *)v)->v);
        break;
      case IOP_T_U64:
        iop_hash_update_i64(ctx, ((iop_opt_u64_t *)v)->v);
        break;
      case IOP_T_DOUBLE:
        iop_hash_update_dbl(ctx, ((iop_opt_double_t *)v)->v);
        break;
      default:
        e_panic("should not happen");
    }
}

static void __iop_hash(struct iop_hash_ctx *ctx, const iop_struct_t *st,
                       const uint8_t *v);

static inline void
__iop_hash_class(struct iop_hash_ctx *ctx, const iop_struct_t *st,
                 const uint8_t *v)
{
    st = *(const iop_struct_t **)v;
    do {
        __iop_hash(ctx, st, v);
    } while ((st = st->class_attrs->parent));
}

static void
__iop_hash(struct iop_hash_ctx *ctx, const iop_struct_t *st, const uint8_t *v)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        fdesc = get_union_field(st, v);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r = v + fdesc->data_offs;
        bool is_class = false;
        int n = 1;

        iop_hash_update_u16(ctx, fdesc->tag);
        iop_hash_update(ctx, fdesc->name.s, fdesc->name.len);

        if (fdesc->repeat == IOP_R_REPEATED) {
            n  = ((lstr_t *)r)->len;
            r  = ((lstr_t *)r)->data;
            iop_hash_update_u32(ctx, n);
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, r))
                continue;

            if ((1 << fdesc->type) & IOP_BLK_OK) {
                if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                    r = *(void **)r;
                }
            } else {
                iop_opt_hash(ctx, fdesc, r);
                continue;
            }
        }
        switch (fdesc->type) {
          case IOP_T_I8:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int8_t *)r)[i]);
            }
            break;
          case IOP_T_BOOL:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, !!((bool *)r)[i]);
            }
            break;
          case IOP_T_U8:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint8_t *)r)[i]);
            }
            break;
          case IOP_T_I16:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int16_t *)r)[i]);
            }
            break;
          case IOP_T_U16:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint16_t *)r)[i]);
            }
            break;
          case IOP_T_I32: case IOP_T_ENUM:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int32_t *)r)[i]);
            }
            break;
          case IOP_T_U32:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint32_t *)r)[i]);
            }
            break;
          case IOP_T_I64:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int64_t *)r)[i]);
            }
            break;
          case IOP_T_U64:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint64_t *)r)[i]);
            }
            break;
          case IOP_T_DOUBLE:
            for (int i = 0; i < n; i++) {
                iop_hash_update_dbl(ctx, ((double *)r)[i]);
            }
            break;
          case IOP_T_UNION:
          case IOP_T_STRUCT:
            is_class = iop_field_is_class(fdesc);
            for (int i = 0; i < n; i++) {
                const uint8_t *v2;

                v2 = &IOP_FIELD(const uint8_t, r, i * fdesc->size);

                if (is_class) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done just
                     *  above).
                     */
                    if (fdesc->repeat != IOP_R_OPTIONAL) {
                        v2 = *(void **)v2;
                    }
                    __iop_hash_class(ctx, fdesc->u1.st_desc, v2);
                } else {
                    __iop_hash(ctx, fdesc->u1.st_desc, v2);
                }
            }
            break;
          case IOP_T_XML:
          case IOP_T_STRING:
          case IOP_T_DATA:
            for (int i = 0; i < n; i++) {
                const lstr_t *s = &IOP_FIELD(const lstr_t, r, i);

                iop_hash_update_u32(ctx, s->len);
                iop_hash_update(ctx, s->data, s->len);
            }
            break;
          default:
            e_panic("should not happen");
        }
    }
}

void iop_hash(const iop_struct_t *st, const void *v,
              void (*hfun)(void *ctx, const void *input, int ilen),
              void *hctx)
{
    struct iop_hash_ctx ctx = {
        .hfun = hfun,
        .ctx  = hctx,
    };

    if (iop_struct_is_class(st)) {
        __iop_hash_class(&ctx, st, v);
    } else {
        __iop_hash(&ctx, st, v);
    }
    if (ctx.pos)
        hfun(hctx, ctx.buf, ctx.pos);
}

/*----- duplicating values -}}}-*/
/*----- check constraints before packing -{{{-*/

static __thread sb_t iop_err_g;

__attribute__((constructor))
static void iop_init_err(void)
{
    if (unlikely(iop_err_g.size == 0))
        sb_init(&iop_err_g);
}

static void iop_wipe_err(void)
{
    if (iop_err_g.size)
        sb_wipe(&iop_err_g);
}

thr_hooks(iop_init_err, iop_wipe_err);

void iop_set_verr(const char *fmt, va_list ap)
{
    sb_setvf(&iop_err_g, fmt, ap);
}

int iop_set_err(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    iop_set_verr(fmt, ap);
    va_end(ap);
    return -1;
}

int iop_set_err2(const lstr_t *s)
{
    sb_set(&iop_err_g, s->s, s->len);
    return -1;
}

void iop_clear_err(void)
{
    sb_reset(&iop_err_g);
}

const char *iop_get_err(void)
{
    if (iop_err_g.len)
        return iop_err_g.data;
    return NULL;
}

lstr_t iop_get_err_lstr(void)
{
    if (iop_err_g.len)
        return LSTR_INIT_V(iop_err_g.data, iop_err_g.len);
    return LSTR_NULL_V;
}

bool iop_field_has_constraints(const iop_struct_t *desc, const iop_field_t
                               *fdesc)
{
    if (iop_field_get_constraints_cb(desc, fdesc))
        return true;
    if (fdesc->type == IOP_T_ENUM && fdesc->u1.en_desc->flags)
        return true;
    return false;
}

int __iop_check_constraints(const iop_struct_t *desc, const void *val);

int iop_field_check_constraints(const iop_struct_t *desc, const iop_field_t
                                *fdesc, const void *ptr, int n, bool recurse)
{
    bool is_class;
    check_constraints_f check_constraints = NULL;

    if ((check_constraints = iop_field_get_constraints_cb(desc, fdesc))) {
        RETHROW(check_constraints(ptr, n));
    }
    switch (fdesc->type) {
      case IOP_T_ENUM:
        if (TST_BIT(&fdesc->u1.en_desc->flags, IOP_ENUM_STRICT)) {
            const iop_enum_t *en_desc = fdesc->u1.en_desc;

            for (int j = 0; j < n; j++) {
                int32_t intval = IOP_FIELD(int32_t, ptr, j);

                if (iop_ranges_search(en_desc->ranges,
                                      en_desc->ranges_len, intval) != -1)
                {
                    continue;
                }
                return iop_set_err("%d is not a valid value for enum %*pM",
                                   intval, LSTR_FMT_ARG(en_desc->fullname));
            }
        }
        break;
      case IOP_T_I8:
      case IOP_T_U8:
      case IOP_T_I16:
      case IOP_T_U16:
      case IOP_T_I32:
      case IOP_T_U32:
      case IOP_T_I64:
      case IOP_T_U64:
      case IOP_T_BOOL:
      case IOP_T_DOUBLE:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        break;
      case IOP_T_UNION:
      case IOP_T_STRUCT:
      default:
        if (!recurse)
            return 0;
        is_class = iop_field_is_class(fdesc);
        for (int j = 0; j < n; j++) {
            const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

            if (is_class) {
                /* Non-optional class fields have to be dereferenced
                 * (dereferencing of optional fields was already done
                 *  by the caller).
                 */
                if (fdesc->repeat != IOP_R_OPTIONAL) {
                    v = *(void **)v;
                }
                RETHROW(iop_check_constraints(fdesc->u1.st_desc, v));
            } else {
                RETHROW(__iop_check_constraints(fdesc->u1.st_desc, v));
            }
        }
        break;
    }

    return 0;
}

int __iop_check_constraints(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    unsigned           desc_flags = desc->flags;

    if (!TST_BIT(&desc_flags, IOP_STRUCT_HAS_CONSTRAINTS))
        return 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0) {
                unsigned fdesc_flags = fdesc->flags;

                if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
                    return iop_set_err("empty array not allowed");
                }
                continue;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field is it's still equal to its default value */
            if (iop_field_is_defval(fdesc, ptr))
                continue;
        }

        RETHROW(iop_field_check_constraints(desc, fdesc, ptr, n, true));
    }

    return 0;
}

int iop_check_constraints(const iop_struct_t *desc, const void *val)
{
    if (iop_struct_is_class(desc)) {
        desc = *(const iop_struct_t **)val;

        do {
            RETHROW(__iop_check_constraints(desc, val));
        } while ((desc = desc->class_attrs->parent));

        return 0;
    } else {
        return __iop_check_constraints(desc, val);
    }
}

/*-}}}-*/
/*----- get value encoding size -{{{-*/

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  qv_t(i32) *szs);

static int
__iop_bpack_size(const iop_struct_t *desc, const void *val, qv_t(i32) *szs)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    int len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0)
                continue;
            if (n > 1) {
                if ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    int32_t i32 = n * fdesc->size;

                    len += 1 + fdesc->tag_len;
                    len += get_len_len(i32) + i32;
                    continue;
                }
                /* Add:
                 * - 4 to encode the len on 32 bits,
                 * - n because there will be n tags 0 to separate elements.
                 */
                len += 4 + n;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field if still equal to its default value */
            if (iop_field_is_defval(fdesc, ptr))
                continue;
        }

        len += 1 + fdesc->tag_len;
        switch (fdesc->type) {
            bool is_class;

          case IOP_T_I8:
            len += n;
            break;
          case IOP_T_U8:
            len += n;
            for (int j = 0; j < n; j++)
                len += IOP_FIELD(uint8_t, ptr, j) >> 7;
            break;
          case IOP_T_I16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int16_t, ptr, j));
            break;
          case IOP_T_U16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(uint16_t, ptr, j));
            break;
          case IOP_T_I32:
          case IOP_T_ENUM:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int32_t, ptr, j));
            break;
          case IOP_T_U32:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(uint32_t, ptr, j));
            break;
          case IOP_T_I64:
          case IOP_T_U64:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(int64_t, ptr, j));
            break;
          case IOP_T_BOOL:
            len += n;
            break;
          case IOP_T_DOUBLE:
            len += n * 8;
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            for (int j = 0; j < n; j++) {
                int32_t i32 = IOP_FIELD(lstr_t, ptr, j).len;
                len += get_len_len(i32 + 1) + i32 + 1;
            }
            break;
          case IOP_T_UNION:
          case IOP_T_STRUCT:

          default:
            is_class = iop_field_is_class(fdesc);
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);
                int32_t offs = szs->len, i32;

                qv_growlen(i32, szs, 1);

                if (is_class) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    if (fdesc->repeat != IOP_R_OPTIONAL) {
                        v = *(void **)v;
                    }
                    i32 = __iop_bpack_size_class(fdesc->u1.st_desc, v, szs);
                } else {
                    i32 = __iop_bpack_size(fdesc->u1.st_desc, v, szs);
                }

                szs->tab[offs] = i32;
                len += get_len_len(i32) + i32;
            }
            break;
        }
    }

    return len;
}

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  qv_t(i32) *szs)
{
    int size = 0, level_size;
    bool first = true;

    desc = *(const iop_struct_t **)val;

    do {
        int szs_pos = szs->len;

        qv_growlen(i32, szs, 1);
        level_size = __iop_bpack_size(desc, val, szs);
        szs->tab[szs_pos] = level_size;
        size += level_size;
        if (first || level_size) {
            /* Add 1 for tag 0, followed by the class id */
            size += 1 + get_vint32_len(desc->class_attrs->class_id);
            first = false;
        }
    } while ((desc = desc->class_attrs->parent));

    return size;
}

int iop_bpack_size(const iop_struct_t *desc, const void *val, qv_t(i32) *szs)
{
    if (iop_struct_is_class(desc)) {
        return __iop_bpack_size_class(desc, val, szs);
    } else {
        return __iop_bpack_size(desc, val, szs);
    }
}

/*-}}}-*/
/*----- packing -{{{-*/

static uint8_t *
pack_struct(void *dst, const iop_struct_t *, const void *, const int **);
static uint8_t *
pack_class(void *dst, const iop_struct_t *, const void *, const int **);
static uint8_t *
pack_union(void *dst, const iop_struct_t *, const void *, const int **);

static uint8_t *
pack_value(uint8_t *dst, const iop_field_t *f, const void *v, const int **szsp)
{
    uint32_t len;

    switch (f->type) {
      case IOP_T_I8:
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = *(int8_t *)v;
        return dst;
      case IOP_T_U8:
        return pack_int32(dst, f->tag, f->tag_len, *(uint8_t *)v);
      case IOP_T_I16:
        return pack_int32(dst, f->tag, f->tag_len, *(int16_t *)v);
      case IOP_T_U16:
        return pack_int32(dst, f->tag, f->tag_len, *(uint16_t *)v);
      case IOP_T_I32:
      case IOP_T_ENUM:
        return pack_int32(dst, f->tag, f->tag_len, *(int32_t *)v);
      case IOP_T_U32:
        return pack_int64(dst, f->tag, f->tag_len, *(uint32_t *)v);
      case IOP_T_I64:
      case IOP_T_U64:
        return pack_int64(dst, f->tag, f->tag_len, *(int64_t *)v);
      case IOP_T_BOOL:
        /* bool are mapped to 0 or 1 */
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = !!*(bool *)v;
        return dst;
      case IOP_T_DOUBLE:
        dst = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(QUAD));
        return put_unaligned_double_le(dst, *(double *)v);
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        len = ((lstr_t *)v)->len;
        dst = pack_len(dst, f->tag, f->tag_len, len + 1);
        dst = mempcpyz(dst, ((lstr_t *)v)->data, len);
        return dst;
      case IOP_T_UNION:
        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        return pack_union(dst, f->u1.st_desc, v, szsp);
      case IOP_T_STRUCT:
      default:
        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        if (iop_field_is_class(f)) {
            /* Non-optional class fields have to be dereferenced
             * (dereferencing of optional fields was done in pack_struct).
             */
            if (f->repeat != IOP_R_OPTIONAL) {
                v = *(void **)v;
            }
            return pack_class(dst, f->u1.st_desc, v, szsp);
        } else {
            return pack_struct(dst, f->u1.st_desc, v, szsp);
        }
    }
}

static uint8_t *pack_value_vec(uint8_t *dst, const iop_field_t *f,
                               const void *v, uint32_t n, const int **szsp)
{
    const lstr_t *d;
    uint32_t len;
    bool is_class;

    switch (f->type) {
      case IOP_T_I32:
      case IOP_T_ENUM:
        do {
            dst = pack_int32(dst, 0, 0, *(int32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_U32:
        do {
            dst = pack_int64(dst, 0, 0, *(uint32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_I64:
      case IOP_T_U64:
        do {
            dst = pack_int64(dst, 0, 0, *(int64_t *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_DOUBLE:
        do {
            dst = pack_tag(dst, 0, 0, IOP_WIRE_MASK(QUAD));
            dst = put_unaligned_double_le(dst, *(double *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        do {
            d = v;
            len = d->len;
            dst = pack_len(dst, 0, 0, len + 1);
            dst = mempcpyz(dst, d->data, len);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_UNION:
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            dst = pack_union(dst, f->u1.st_desc, v, szsp);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_STRUCT:
        is_class = iop_field_is_class(f);
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            if (is_class) {
                dst = pack_class(dst, f->u1.st_desc, *(void **)v, szsp);
            } else {
                dst = pack_struct(dst, f->u1.st_desc, v, szsp);
            }
            v = (char *)v + f->size;
        } while (--n > 0);
        return dst;

      default:
        e_panic("should not happen");
    }
}

static uint8_t *
pack_struct(void *dst, const iop_struct_t *desc, const void *v, const int **szsp)
{
    assert(!desc->is_union); /* We don't want a union here */

    for (int i = 0; i < desc->fields_len; i++) {
        const iop_field_t *f = desc->fields + i;
        const void *ptr = (char *)v + f->data_offs;

        if (f->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(f, ptr))
                continue;
            if ((1 << f->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (f->repeat == IOP_R_REPEATED) {
            const lstr_t *data = ptr;

            if (data->len == 0)
                continue;
            ptr = data->data;
            if (data->len > 1) {
                if ((1 << f->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    /* When data unit is really small (byte, bool, …) we
                     * prefer to pack them in one big block */
                    uint32_t sz = data->len * f->size;

                    assert (f->size <= 2);
                    dst = pack_len(dst, f->tag, f->tag_len, sz);
                    dst = mempcpy(dst, data->data, sz);
                } else {
                    dst = pack_tag(dst, f->tag, f->tag_len,
                                   IOP_WIRE_MASK(REPEAT));
                    dst = put_unaligned_le32(dst, data->len);
                    dst = pack_value_vec(dst, f, ptr, data->len, szsp);
                }
                continue;
            }
        } else
        if (f->repeat == IOP_R_DEFVAL) {
            /* Skip the field is it's still equal to its default value */
            if (iop_field_is_defval(f, ptr))
                continue;
        }

        dst = pack_value(dst, f, ptr, szsp);
    }
    return dst;
}

static uint8_t *
pack_class(void *dst, const iop_struct_t *desc, const void *v,
           const int **szsp)
{
    bool first = true;

    desc = *(const iop_struct_t **)v;

    do {
        int level_size = *(*szsp)++;

        if (first || level_size) {
            /* We write the class id in a tag 0 only if:
             *  - this is the first level, because we always want to write the
             *    real class id of the packed object,
             *  - if there is actually something to pack.
             */
            dst = pack_int32(dst, 0, 0, desc->class_attrs->class_id);
            first = false;
        }
        if (level_size) {
            dst = pack_struct(dst, desc, v, szsp);
        }
    } while ((desc = desc->class_attrs->parent));

    return dst;
}

static uint8_t *
pack_union(void *dst, const iop_struct_t *desc, const void *v,
           const int **szsp)
{
    const iop_field_t *f = get_union_field(desc, v);
    assert(f->repeat == IOP_R_REQUIRED);

    return pack_value(dst, f, (char *)v + f->data_offs, szsp);
}

void
iop_bpack(void *dst, const iop_struct_t *desc, const void *v, const int *szs)
{
    if (desc->is_union) {
        pack_union(dst, desc, v, &szs);
    } else
    if (iop_struct_is_class(desc)) {
        pack_class(dst, desc, v, &szs);
    } else {
        pack_struct(dst, desc, v, &szs);
    }
}

lstr_t t_iop_bpack_struct(const iop_struct_t *st, const void *v)
{
    qv_t(i32) sizes;
    void *data;
    int len;

    if (!v)
        return LSTR_NULL_V;

    qv_inita(i32, &sizes, 1024);

    len  = iop_bpack_size(st, v, &sizes);
    data = t_new_raw(char, len);

    iop_bpack(data, st, v, sizes.tab);
    qv_wipe(i32, &sizes);
    return lstr_init_(data, len, MEM_STACK);
}

/*-}}}-*/
/*----- unpacking -{{{-*/

static int get_uint32(pstream_t *ps, int ilen, uint32_t *u32)
{
    PS_WANT(ps_has(ps, ilen));
    *u32 = 0;
    memcpy(u32, ps->p, ilen);
#if __BYTE_ORDER == __BIG_ENDIAN
    *u32 = __builtin_bswap32(*u32);
#endif
    return __ps_skip(ps, ilen);
}

/*
 * XXX: an iop_range helps doing run-length encoded binary search. We know
 * that IOPs tags are mostly contiguous, hence we encode "full" runs of tags
 * this way:
 *   [ offset0, start_tag0, offset1, ..., start_tag_n, offset_n]
 *
 * This means that the offset0-th up to the offset1-th values described by
 * this iop_range take values contiguously from the range:
 *   [ start_tag0 .. start_tag0 + offset1 - offset0 [
 *
 * Of course, offset0 is always equal to 0, and offset_n should be equal to
 * ranges_len.
 *
 * Example: the iop_range for "10 11 12 13 100 101 102" is "0 10 4 100 7"
 *  - positions [0 .. 4[ have values in [10  .. 10 + 4 - 0[
 *  - positions [4 .. 7[ have values in [100 .. 100 + 7 - 4[
 *
 */
int iop_ranges_search(int const * ranges, int ranges_len, int tag)
{
    int l = 0, r = ranges_len;

    while (l < r) {
        int i = (l + r) / 2;
        int offs  = ranges[i * 2];
        int start = ranges[i * 2 + 1];

        if (tag < start) {
            r = i;
            continue;
        }
        if (tag + offs >= start + ranges[i * 2 + 2]) {
            l = i + 1;
            continue;
        }
        return ranges[i * 2] + (tag - start);
    }
    return -1;
}

int iop_enum_from_str2(const iop_enum_t *e, const char *s, int len, bool *found)
{
    if (len < 0)
        len = strlen(s);
    *found = false;
    for (int i = 0; i < e->enum_len; i++) {
        if (len == e->names[i].len && !strncasecmp(e->names[i].s, s, len)) {
            *found = true;
            return e->values[i];
        }
    }
    return -1;
}

int iop_enum_from_str(const iop_enum_t *e, const char *s, int len, int err)
{
    bool found;
    int val = iop_enum_from_str2(e, s, len, &found);

    return (found) ? val : err;
}

int iop_enum_from_lstr(const iop_enum_t *e, const lstr_t s, bool *found)
{
    *found = false;
    for (int i = 0; i < e->enum_len; i++) {
        if (s.len == e->names[i].len
        &&  strncasecmp(e->names[i].s, s.s, s.len) == 0)
        {
            *found = true;
            return e->values[i];
        }
    }
    return -1;
}


static int iop_skip_field(pstream_t *ps, iop_wire_type_t wt)
{
    uint32_t u32;

    switch (wt) {
      case IOP_WIRE_BLK1: PS_CHECK(get_uint32(ps, 1, &u32)); break;
      case IOP_WIRE_BLK2: PS_CHECK(get_uint32(ps, 2, &u32)); break;
      case IOP_WIRE_BLK4: PS_CHECK(get_uint32(ps, 4, &u32)); break;

      case IOP_WIRE_INT1:
      case IOP_WIRE_INT2:
      case IOP_WIRE_INT4:
        u32 = 1 << (wt - IOP_WIRE_INT1);
        break;
      case IOP_WIRE_QUAD:
        u32 = 8;
        break;
      default:
        return -1;
    }

    return ps_skip(ps, u32);
}

static ALWAYS_INLINE
int iop_patch_int(const iop_field_t *fdesc, void *ptr, int64_t i64)
{
    switch (fdesc->type) {
      case IOP_T_I8: case IOP_T_U8:
        *(int8_t *)ptr  = i64;
        break;
      case IOP_T_I16: case IOP_T_U16:
        *(int16_t *)ptr = i64;
        break;
      case IOP_T_ENUM:
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_I32: case IOP_T_U32:
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        *(int64_t *)ptr = i64;
        break;
      case IOP_T_BOOL:
        *(bool *)ptr    = i64;
        break;
    }
    return 0;
}

static ALWAYS_INLINE int
__get_tag_wt(pstream_t *ps, uint32_t *tag, iop_wire_type_t *wt)
{
    *wt  = IOP_WIRE_FMT(ps->b[0]);
    *tag = IOP_TAG(__ps_getc(ps));
    if (likely(*tag < IOP_LONG_TAG(1)))
        return 0;
    if (likely(*tag == IOP_LONG_TAG(1)))
        return get_uint32(ps, 1, tag);
    return get_uint32(ps, 2, tag);
}

static ALWAYS_INLINE int
__get_class_id(pstream_t *ps, iop_wire_type_t wt, uint16_t *class_id)
{
    switch (wt) {
      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        *class_id = (int8_t)__ps_getc(ps);
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        *class_id = (int16_t)__ps_get_le16(ps);
        return 0;

      default:
        return -1;
    }
}

int __iop_skip_absent_field_desc(void *value, const iop_field_t *fdesc)
{
    void *ptr = (char *)value + fdesc->data_offs;

    if (fdesc->repeat == IOP_R_REQUIRED) {
        const iop_struct_t *desc = fdesc->u1.st_desc;

        /* For a required field, only structs can be absents, be careful that
         * union and class must be presents */
        PS_WANT(fdesc->type == IOP_T_STRUCT);
        PS_WANT(!iop_field_is_class(fdesc));
        for (int i = 0; i < desc->fields_len; i++)
            PS_CHECK(__iop_skip_absent_field_desc(ptr, desc->fields + i));
        return 0;
    } else
    if (fdesc->repeat == IOP_R_DEFVAL) {
        switch (fdesc->type) {
          case IOP_T_I8: case IOP_T_U8:
            *(uint8_t *)ptr  = fdesc->u1.defval_u64;
            break;
          case IOP_T_I16: case IOP_T_U16:
            *(uint16_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_ENUM:
            *(uint32_t *)ptr = fdesc->u0.defval_enum;
            break;
          case IOP_T_I32: case IOP_T_U32:
            *(uint32_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_I64: case IOP_T_U64:
            *(uint64_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_BOOL:
            *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
            break;
          case IOP_T_DOUBLE:
            *(double *)ptr   = fdesc->u1.defval_d;
            break;
          case IOP_T_STRING:
          case IOP_T_XML:
            *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data, fdesc->u0.defval_len);
            break;
          case IOP_T_DATA:
            ((lstr_t *)ptr)->len      = fdesc->u0.defval_len;
            ((lstr_t *)ptr)->data     = (void *)fdesc->u1.defval_data;
            ((lstr_t *)ptr)->mem_pool = 0;
            break;
          default:
            return -1;
        }
    } else
    if (fdesc->repeat == IOP_R_REPEATED) {
        unsigned fdesc_flags = fdesc->flags;

        if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY))
            return iop_set_err("empty array not allowed");
        p_clear((lstr_t *)ptr, 1);
    } else {
        iop_value_set_absent(fdesc, ptr);
    }
    return 0;
}

static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, bool copy, iop_wire_type_t *class_id_wt);
static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, bool copy);
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, bool copy);

static int unpack_value(mem_pool_t *mp, iop_wire_type_t wt,
                        const iop_field_t *fdesc, void *v,
                        pstream_t *ps, bool copy)
{
    uint32_t u32;
    pstream_t ps_tmp;

    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_WANT(ps_has(ps, u32));
        switch (fdesc->type) {
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            *(lstr_t *)v = LSTR_INIT_V((copy ? mp_dup(mp, ps->s, u32)
                                        : ps->p), u32 - 1);
            return __ps_skip(ps, u32);
          case IOP_T_UNION:
            ps_tmp = __ps_get_ps(ps, u32);
            return unpack_union(mp, fdesc->u1.st_desc, v, &ps_tmp, copy);
          case IOP_T_STRUCT:
            ps_tmp = __ps_get_ps(ps, u32);
            if (iop_field_is_class(fdesc)) {
                *(void **)v = NULL;
                return unpack_class(mp, fdesc->u1.st_desc, v, &ps_tmp, copy);
            } else {
                return unpack_struct(mp, fdesc->u1.st_desc, v, &ps_tmp, copy,
                                     NULL);
            }
        }
        return -1;

      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int8_t)__ps_getc(ps));

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int16_t)__ps_get_le16(ps));

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int32_t)__ps_get_le32(ps));

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_WANT(ps_has(ps, 8));
            return iop_patch_int(fdesc, v, __ps_get_le64(ps));
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE)
            return ps_get_double_le(ps, v);
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        return ps_get_le64(ps, v);
      default:
        return -1;
    }
}

/* Returns:
 * * 1 when "change of level" (used for classes) tag was seen; in that case,
 *   the wire type associated to this tag is written in class_id_wt.
 * * 0 otherwise on success.
 * * a negative value on error.
 */
static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, bool copy, iop_wire_type_t *class_id_wt)
{
    bool is_class = iop_struct_is_class(desc);
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = desc->fields + desc->fields_len;
    iop_wire_type_t wt;
    uint32_t tag;

    while (fdesc < end && !ps_done(ps)) {
        uint32_t n = 1;
        void *v;

        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
        if (tag == 0) {
            /* This is a "change of level" tag in a packed class; check that
             * all the remaining fields at this level are optional. */
            PS_WANT(is_class);
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking class %*pM, got change of level tag",
                          LSTR_FMT_ARG(desc->fullname));
            do {
                PS_CHECK(__iop_skip_absent_field_desc(value, fdesc));
            } while (++fdesc != end);
            *class_id_wt = wt;
            return 1;
        }
        while (unlikely(tag > fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking struct %*pM, skipping %*pM field",
                          LSTR_FMT_ARG(desc->fullname),
                          LSTR_FMT_ARG(fdesc->name));
            PS_CHECK(__iop_skip_absent_field_desc(value, fdesc));
            if (++fdesc == end)
                return 0;
        }
        if (unlikely(tag < fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking struct %*pM, skipping %*pM field",
                          LSTR_FMT_ARG(desc->fullname),
                          LSTR_FMT_ARG(fdesc->name));
            PS_CHECK(iop_skip_field(ps, wt));
            continue;
        }

        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, unpacking %*pM field",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name));

        if (wt == IOP_WIRE_REPEAT) {
            PS_CHECK(get_uint32(ps, 4, &n));
            PS_WANT(n >= 1);
            PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
            wt = IOP_WIRE_FMT(__ps_getc(ps));
        }

        v = (char *)value + fdesc->data_offs;
        if (fdesc->repeat == IOP_R_REPEATED) {
            lstr_t *data = v;

            if (wt != IOP_WIRE_REPEAT
            &&  ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK))
            {
                /* optimized version of repeated fields are packed in simples
                 * IOP blocks */
                uint32_t len;

                switch (wt) {
                  case IOP_WIRE_BLK1:
                    PS_CHECK(get_uint32(ps, 1, &len));
                    break;
                  case IOP_WIRE_BLK2:
                    PS_CHECK(get_uint32(ps, 2, &len));
                    break;
                  case IOP_WIRE_BLK4:
                    PS_CHECK(get_uint32(ps, 4, &len));
                    break;
                  default:
                    /* Here we expect to have a uniq-value packed as a normal
                     * field (data->len == 1) */
                    goto unpack_array;
                }
                PS_WANT(ps_has(ps, len));

                if (fdesc->size == 1) {
                    data->len = len;
                    data->data = (copy ? mp_dup(mp, ps->s, len)
                                       : (void *)ps->p);
                } else {
                    assert (fdesc->size == 2);
                    PS_WANT(len % 2 == 0);
                    data->len  = len / 2;
                    data->data = mp_dup(mp, ps->s, len);
                }

                __ps_skip(ps, len);
                v = data->data;
                n = data->len;
                goto next;
            }

          unpack_array:
            data->len  = n;
            data->data = v = mp->malloc(mp, n * fdesc->size, MEM_RAW);

            while (n-- > 1) {
                PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
                v  = (char *)v + fdesc->size;
            }
            PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
            v = data->data;
            n = data->len;
        } else {
            while (n-- > 1) {
                PS_CHECK(iop_skip_field(ps, wt));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
            }
            if (fdesc->repeat == IOP_R_OPTIONAL
            &&  !iop_field_is_class(fdesc))
            {
                v = iop_value_set_here(mp, fdesc, v);
            }
            PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
            n = 1;
        }

      next:
        if (unlikely(iop_field_has_constraints(desc, fdesc))) {
            RETHROW(iop_field_check_constraints(desc, fdesc, v, n, false));
        }
        fdesc++;
    }

    for (; fdesc < end; fdesc++) {
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, skipping %*pM field",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name));
        PS_CHECK(__iop_skip_absent_field_desc(value, fdesc));
    }

    return 0;
}

static inline int
unpack_skip_all_fields(const iop_struct_t *desc, void *value)
{
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = fdesc + desc->fields_len;

    for ( ; fdesc < end; fdesc++) {
        PS_CHECK(__iop_skip_absent_field_desc(value, fdesc));
    }
    return 0;
}

static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, bool copy)
{
    const iop_struct_t *real_desc;
    class_id_key_t key;
    iop_wire_type_t wt;
    uint32_t tag;
    int pos;

    PS_WANT(!ps_done(ps));
    p_clear(&key, 1);

    /* Get the class id of the packed class instance */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    PS_WANT(tag == 0);
    PS_CHECK(__get_class_id(ps, wt, &key.child_id));

    if (key.child_id == desc->class_attrs->class_id) {
        real_desc = desc;
        goto unpack;
    }

    /* Get the iop_struct_t of the instanciated class from its class_id */
    key.master = desc;
    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }
    if ((pos = qm_find(class_id, &_G.classes_by_id, &key)) < 0) {
        e_trace(0, "cannot find child %d of class '%*pM' (%p)",
                key.child_id, LSTR_FMT_ARG(key.master->fullname), key.master);
        return -1;
    }
    real_desc = _G.classes_by_id.values[pos];

    /* We are trying to unpack a class of type "desc", and the packed
     * class is of type "real_desc". Check that this is authorized. */
    PS_WANT(iop_class_is_a(real_desc, desc));

    e_named_trace(5, "iop/c/unpacker",
                  "unpacking a class of type %*pM, real type %*pM",
                  LSTR_FMT_ARG(desc->fullname),
                  LSTR_FMT_ARG(real_desc->fullname));

  unpack:
    if (*value) {
        *value = mp->realloc(mp, *value, 0, real_desc->size, MEM_RAW);
    } else {
        *value = mp->malloc(mp, real_desc->size, MEM_RAW);
    }

    /* Set the _vprt pointer */
    *(const iop_struct_t **)(*value) = real_desc;

    /* Unpack the several levels */
    do {
        uint16_t class_id = 0;
        int res;

        PS_CHECK((res = unpack_struct(mp, real_desc, *value, ps, copy, &wt)));

        if (!(real_desc = real_desc->class_attrs->parent)) {
            return 0;
        }

        if (res != 1) {
            /* "Change of level" tag was not seen yet */
            if (ps_done(ps)) {
                /* Such a tag won't be there because pstream is finished. This
                 * is possible if all the remaining levels have only optional
                 * fields. */
                do {
                    PS_CHECK(unpack_skip_all_fields(real_desc, *value));
                } while ((real_desc = real_desc->class_attrs->parent));
                return 0;
            }
            /* Read it */
            PS_CHECK(__get_tag_wt(ps, &tag, &wt));
            PS_WANT(tag == 0);
        }

        /* Get the next class id, and run the tree up to it; the skipped
         * classes must have only optional fields. */
        PS_CHECK(__get_class_id(ps, wt, &class_id));
        while (class_id != real_desc->class_attrs->class_id) {
            PS_CHECK(unpack_skip_all_fields(real_desc, *value));
            PS_WANT((real_desc = real_desc->class_attrs->parent));
        }
    } while (real_desc);

    return 0;
}

/* note: returns 0 on success, -1 on error and 1 if the pstream hasn't been
 * fully consumed. */
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, bool copy)
{
    const iop_field_t *fdesc = desc->fields;

    iop_wire_type_t wt;
    uint32_t tag;
    int ifield;

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Write the selected field */
    *((uint16_t *)value) = fdesc->tag;
    value = (char *)value + fdesc->data_offs;

    e_named_trace(5, "iop/c/unpacker", "unpacking union %*pM field %*pM",
                  LSTR_FMT_ARG(desc->fullname), LSTR_FMT_ARG(fdesc->name));
    PS_CHECK(unpack_value(mp, wt, fdesc, value, ps,
                          copy));
    if (unlikely(iop_field_has_constraints(desc, fdesc))) {
        RETHROW(iop_field_check_constraints(desc, fdesc, value, 1, false));
    }
    return ps_done(ps) ? 0 : 1;
}

int iop_bunpack(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                pstream_t ps, bool copy)
{
    assert (!iop_struct_is_class(desc));
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);
    if (desc->is_union) {
        return unpack_union(mp, desc, value, &ps, copy) ? -1 : 0;
    }
    return unpack_struct(mp, desc, value, &ps, copy, NULL);
}

int iop_bunpack_ptr(mem_pool_t *mp, const iop_struct_t *desc, void **value,
                    pstream_t ps, bool copy)
{
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);

    if (!iop_struct_is_class(desc)) {
        if (*value) {
            *value = mp->realloc(mp, *value, 0, desc->size, MEM_RAW);
        } else {
            *value = mp->malloc(mp, desc->size, MEM_RAW);
        }
        return iop_bunpack(mp, desc, *value, ps, copy);
    }

    return unpack_class(mp, desc, value, &ps, copy);
}

/* XXX: this function can unpack only union because the struct can't be
 * delimited in a stream.
 * */
int iop_bunpack_multi(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                pstream_t *ps, bool copy)
{
    assert(desc->is_union);

    e_named_trace(5, "iop/c/unpacker", "unpacking IOP union(s) %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);
    return (unpack_union(mp, desc, value, ps, copy) < 0) ? -1 : 0;
}

/* XXX this function doesn't check the IOP content and trust what it reads
 * XXX: this function can unpack only union because the struct can't be
 * delimited in a stream. */
int iop_bskip(const iop_struct_t *desc, pstream_t *ps)
{
    const iop_field_t *fdesc = desc->fields;
    iop_wire_type_t wt;
    uint32_t tag, u32;
    int ifield;

    assert(desc->is_union);

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Skip union data */
    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_CHECK(ps_skip(ps, u32)); /* Skip block */
        return 0;

      case IOP_WIRE_INT1:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 1));
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 2));
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 4));
        return 0;

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_CHECK(ps_skip(ps, 8));
            return 0;
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE) {
            PS_CHECK(ps_skip(ps, sizeof(double)));
            return 0;
        }
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        PS_CHECK(ps_skip(ps, 8));
        return 0;
      default:
        return -1;
    }
}

ssize_t iop_get_field_len(pstream_t ps)
{
    iop_wire_type_t wt;
    uint32_t tag, u32, tag_len, len_len;

    if (ps_done(&ps))
        return 0;
    wt  = IOP_WIRE_FMT(ps.b[0]);
    tag = IOP_TAG(ps.b[0]);
    if (likely(tag < IOP_LONG_TAG(1))) {
        tag_len = 1;
    } else {
        tag_len = 2 + tag - IOP_LONG_TAG(1);
    }
    switch (wt) {
      case IOP_WIRE_BLK1:
        len_len = 1;
        break;
      case IOP_WIRE_BLK2:
        len_len = 2;
        break;
      case IOP_WIRE_BLK4:
        len_len = 4;
        break;
      case IOP_WIRE_REPEAT: /* not supported by this function */
        return -1;
      case IOP_WIRE_INT1:
        return tag_len + 1;
      case IOP_WIRE_INT2:
        return tag_len + 2;
      case IOP_WIRE_INT4:
        return tag_len + 4;
      case IOP_WIRE_QUAD:
        return tag_len + 8;
      default:
        return -1;
    }
    if (ps_skip(&ps, tag_len) < 0)
        return 0;
    if (get_uint32(&ps, len_len, &u32) < 0)
        return 0;
    return tag_len + u32;
}

/*-}}}-*/
/*------ introspection -{{{-*/

const iop_iface_t *iop_mod_find_iface(const iop_mod_t *mod, uint32_t tag)
{
    size_t l = 0, r = mod->ifaces_len;

    while (l < r) {
        size_t  i = (l + r) / 2;
        const iop_iface_alias_t *alias = &mod->ifaces[i];

        if (tag == alias->tag) {
            return alias->iface;
        }
        if (tag < alias->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_iface_find_rpc(const iop_iface_t *iface, uint32_t tag)
{
    size_t l = 0, r = iface->funs_len;

    while (l < r) {
        size_t i = (l + r) / 2;
        const iop_rpc_t *rpc = &iface->funs[i];

        if (tag == rpc->tag) {
            return rpc;
        }
        if (tag < rpc->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_mod_find_rpc(const iop_mod_t *mod, uint32_t cmd)
{
    const iop_iface_t *iface = RETHROW_P(iop_mod_find_iface(mod, cmd >> 16));
    return iop_iface_find_rpc(iface, cmd & 0xffff);
}

/*------ introspection -}}}-*/
/*------ Signature -{{{-*/

static
lstr_t t_iop_sign_salt_sha256(const iop_struct_t *st, const void *v, uint32_t salt)
{
    uint8_t buf[SHA256_DIGEST_SIZE];
    be32_t  s = cpu_to_be32(salt);

    iop_hmac_sha256(st, v, LSTR_INIT_V((void *)&s, sizeof(s)), buf);
    return t_lstr_fmt("$256:%*pX$%*pX", (int)sizeof(s), &s,
                      SHA256_DIGEST_SIZE, buf);
}

lstr_t t_iop_compute_signature(const iop_struct_t *st, const void *v)
{
    return t_iop_sign_salt_sha256(st, v, ha_rand());
}

__must_check__
static int iop_signature_get_salt(lstr_t signature, be32_t *salt)
{
    if (lstr_startswith(signature, LSTR_IMMED_V("$256:"))) {
        if (signature.len != 5 + 8 + 1 + SHA256_DIGEST_SIZE * 2)
        {
#ifdef NDEBUG
            return -1;
#else
            return e_error("invalid $256 signature (invalid length)");
#endif
        }
        if (strconv_hexdecode(salt, sizeof(salt), signature.s + 5, 8) < 0
        ||  signature.s[5 + 8] != '$')
        {
#ifdef NDEBUG
            return -1;
#else
            return e_error("invalid $256 signature (invalid salt)");
#endif
        }
    } else {
#ifdef NDEBUG
        return -1;
#else
        return e_error("unparseable signature: <%*pM>",
                       LSTR_FMT_ARG(signature));
#endif
    }
    return 0;
}

int iop_check_signature(const iop_struct_t *st, const void *v, lstr_t sig)
{
    t_scope;
    lstr_t exp;
    be32_t salt;

#ifndef NDEBUG
    if (lstr_equal2(sig, LSTR_IMMED_V("$42:defeca7e$")))
        return 0;
#endif

    if (iop_signature_get_salt(sig, &salt) < 0) {
#ifdef NDEBUG
        return -1;
#else
        return e_error("error while getting salt");
#endif
    }

    exp = t_iop_sign_salt_sha256(st, v, be_to_cpu32(salt));
    if (!lstr_equal2(sig, exp)) {
#ifdef NDEBUG
        return -1;
#else
        return e_error("invalid signature (invalid value)");
#endif
    }

    return 0;
}

__attribute__((constructor))
static void iop_signature_initialize(void)
{
    ha_srand();
}

/*------ Signature -}}}-*/
/*------ class manipulation -{{{-*/

iop_value_t const *iop_get_cvar(const void *obj, lstr_t name)
{
    const iop_struct_t *desc = *(iop_struct_t **)obj;
    iop_static_field_t _search = { .name = name };
    iop_static_field_t *search = &_search;

    while (desc) {
        const iop_class_attrs_t *cls = desc->class_attrs;
        bool found;
        int pos;
        cmp_b cmp = ^int (const void *a, const void *b) {
            const iop_static_field_t **v1 = (const iop_static_field_t **)a;
            const iop_static_field_t **v2 = (const iop_static_field_t **)b;

            return lstr_cmp(&(*v1)->name, &(*v2)->name);
        };

        pos = bisect_blk(&search, cls->static_fields,
                         sizeof(iop_static_field_t *),
                         cls->static_fields_len, &found, cmp);
        if (found) {
            const iop_static_field_t *f;

            f = desc->class_attrs->static_fields[pos];
            return &f->value;
        }

        desc = cls->parent;
    };

    return NULL;
}

bool iop_class_is_a(const iop_struct_t *cls1, const iop_struct_t *cls2)
{
    if (!iop_struct_is_class(cls1) || !iop_struct_is_class(cls2)) {
        assert (false);
        return false;
    }

    do {
        if (cls1 == cls2) {
            return true;
        }
    } while ((cls1 = cls1->class_attrs->parent));

    return false;
}

const iop_struct_t *
iop_get_class_by_fullname(const iop_struct_t *st, lstr_t fullname)
{
    class_name_key_t key = {
        .master = st,
        .child_fullname = &fullname,
    };
    int pos;

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    pos = RETHROW_NP(qm_find(class_name, &_G.classes_by_name, &key));
    return _G.classes_by_name.values[pos];
}

void iop_for_each_registered_classes(iop_for_each_class_b cb)
{
    qm_for_each_pos(class_id, pos, &_G.classes_by_id) {
        cb(_G.classes_by_id.values[pos]);
    }
}

/*------ class manipulation -}}}-*/
/*------ Packages registration -{{{-*/

static void iop_register_class(const iop_struct_t *desc)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };
    uint32_t pos;

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    /* Register in classes_by_id hash table */
    pos = __qm_put(class_id, &_G.classes_by_id, &key, desc, 0);
    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;
        if (_G.classes_by_id.values[pos] != desc) {
            e_fatal("conflicting class id %d: used by both '%*pM' and '%*pM'",
                    desc->class_attrs->class_id, LSTR_FMT_ARG(desc->fullname),
                    LSTR_FMT_ARG(_G.classes_by_id.values[pos]->fullname));
        }
    } else {
        class_name_key_t key2 = {
            .master         = key.master,
            .child_fullname = &desc->fullname,
        };

        e_named_trace(5, "iop/package_registration",
                      "registering class '%*pM' as a child of '%*pM' (%p)",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(key.master->fullname), key.master);

        /* Register in classes_by_name hash table */
        if (qm_add(class_name, &_G.classes_by_name, &key2, desc) < 0) {
            e_fatal("conflicting class name '%*pM' as a child of '%*pM'",
                    LSTR_FMT_ARG(desc->fullname),
                    LSTR_FMT_ARG(key.master->fullname));
        }

        if (desc->class_attrs->parent) {
            /* Register the parent only if the class was not registered
             * yet, because if it is, we are sure the parent is already
             * registered. */
            iop_register_class(desc->class_attrs->parent);
        }
    }
}

void iop_register_packages(const iop_pkg_t **pkgs, int len)
{
    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];

        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            if (iop_struct_is_class(desc)) {
                iop_register_class(desc);
            }
        }
    }
}

static void iop_unregister_class(const iop_struct_t *desc)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    if (qm_del_key(class_id, &_G.classes_by_id, &key) >= 0) {
        class_name_key_t key2 = {
            .master         = key.master,
            .child_fullname = &desc->fullname,
        };

        qm_del_key(class_name, &_G.classes_by_name, &key2);

        if (desc->class_attrs->parent) {
            /* Unregister the parent only if the class was registered,
             * because if not we are sure the parent won't be. */
            iop_unregister_class(desc->class_attrs->parent);
        }
    }
}

void iop_unregister_packages(const iop_pkg_t **pkgs, int len)
{
    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];

        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            if (iop_struct_is_class(desc)) {
                iop_unregister_class(desc);
            }
        }
    }
}

/*------ Packages registration -}}}-*/

__attribute__((destructor))
static void iop_shutdown(void)
{
    qm_wipe(class_id,   &_G.classes_by_id);
    qm_wipe(class_name, &_G.classes_by_name);
}

iop_struct_t const iop__void__s = {
    .fullname   = LSTR_IMMED("Void"),
    .fields_len = 0,
    .size       = 0,
};
