/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "arith.h"
#include "core.h"
#include "iop.h"
#include "iop-priv.h"
#include "iop-helpers.in.c"
#include "thr.h"
#include "sort.h"


static struct {
    iop_env_t env;
} iop_g;
#define _G  iop_g

/* {{{ Various helpers */

static inline int
__iop_field_find_by_name2(const iop_struct_t *desc, const lstr_t name)
{
    const iop_field_t *field = desc->fields;

    for (int i = 0; i < desc->fields_len; i++) {
        if (lstr_equal(field->name, name)) {
            return i;
        }
        field++;
    }
    return -1;
}

static inline const iop_field_t *
__iop_field_find_by_name(const iop_struct_t *desc, const lstr_t name)
{
    int pos = RETHROW_NP(__iop_field_find_by_name2(desc, name));

    return &desc->fields[pos];
}

int iop_field_find_by_name(const iop_struct_t *st, const lstr_t name,
                           const iop_struct_t **found_st,
                           const iop_field_t  **found_fdesc)
{
    int acc = 0;
    bool is_class = iop_struct_is_class(st);

    do {
        int pos = __iop_field_find_by_name2(st, name);

        if (pos >= 0) {
            if (found_st) {
                *found_st = st;
            }
            if (found_fdesc) {
                *found_fdesc = st->fields + pos;
            }
            return acc + pos;
        }
        acc += st->fields_len;
    } while (is_class && (st = st->class_attrs->parent));

    return -1;
}

const iop_field_t *iop_get_field(const void *ptr, const iop_struct_t *st,
                                 lstr_t path, const void ** nullable out_ptr,
                                 const iop_struct_t ** nullable out_st)
{
    pstream_t ps = ps_initlstr(&path);
    const iop_field_t *iop_field = NULL;

    while (!ps_done(&ps)) {
        pstream_t as;
        pstream_t s;
        int array_index;

        RETHROW_P(ptr);

        if (ps_get_ps_chr_and_skip(&ps, '.', &as) < 0) {
            as = ps;
            ps = ps_init(NULL, 0);
        }

        if (ps_get_ps_chr_and_skip(&as, '[', &s) < 0) {
            s = as;
            array_index = -1;
        } else {
            errno = 0;
            array_index = ps_geti(&as);
            THROW_NULL_IF(array_index < 0 || errno);
            RETHROW_NP(ps_skipc(&as, ']'));
            THROW_NULL_IF(!ps_done(&as));
        }

        if (iop_struct_is_class(st)) {
            st = *(const iop_struct_t **)ptr;
        }
        RETHROW_NP(iop_field_find_by_name(st, LSTR_PS_V(&s), out_st,
                                          &iop_field));
        if (st->is_union && *(int16_t *)ptr != iop_field->tag) {
            return NULL;
        }
        ptr = (const byte *)ptr + iop_field->data_offs;

        if (array_index >= 0) {
            const IOP_ARRAY_OF(byte) *array_ptr = ptr;

            THROW_NULL_IF(iop_field->repeat != IOP_R_REPEATED);
            THROW_NULL_IF(array_ptr->len <= array_index);
            ptr = array_ptr->tab + (iop_field->size * array_index);
        } else
        if (iop_field->repeat == IOP_R_REPEATED) {
            THROW_NULL_IF(!ps_done(&ps));
        }

        switch (iop_field->type) {
          case IOP_T_UNION:
          case IOP_T_STRUCT:
            if (!ps_done(&ps) && iop_field_is_pointed(iop_field)) {
                ptr = *(const void **)ptr;
            }
            st = iop_field->u1.st_desc;
            break;
          default:
            THROW_NULL_IF(!ps_done(&ps));
            break;
        }
    }
    if (out_ptr) {
        *out_ptr = ptr;
    }
    return iop_field;
}

iop_value_from_field_res_t
iop_value_from_field(const void *ptr, const iop_field_t *field,
                     iop_value_t *value)
{
    THROW_ERR_IF(field->repeat == IOP_R_REPEATED);

    ptr = (byte *)ptr + field->data_offs;

#define GET_SCALAR(type, opt, f)                                             \
        if (field->repeat == IOP_R_OPTIONAL) {                               \
            const opt *o = ptr;                                              \
                                                                             \
            if (OPT_ISSET(*o)) {                                             \
                value->f = OPT_VAL(*o);                                      \
            } else {                                                         \
                return IOP_FIELD_NOT_SET;                                    \
            }                                                                \
        } else {                                                             \
            value->f = *(const type *)ptr;                                   \
        }

    switch (field->type) {
      case IOP_T_I8:
        GET_SCALAR(int8_t, opt_i8_t, i);
        return 0;

      case IOP_T_U8:
        GET_SCALAR(uint8_t, opt_u8_t, u);
        return 0;

      case IOP_T_I16:
        GET_SCALAR(int16_t, opt_i16_t, i);
        return 0;

      case IOP_T_U16:
        GET_SCALAR(uint16_t, opt_u16_t, u);
        return 0;

      case IOP_T_ENUM:
      case IOP_T_I32:
        GET_SCALAR(int32_t, opt_i32_t, i);
        return 0;

      case IOP_T_U32:
        GET_SCALAR(uint32_t, opt_u32_t, u);
        return 0;

      case IOP_T_I64:
        GET_SCALAR(int64_t, opt_i64_t, i);
        return 0;

      case IOP_T_U64:
        GET_SCALAR(uint64_t, opt_u64_t, u);
        return 0;

      case IOP_T_BOOL:
        GET_SCALAR(bool, opt_bool_t, b);
        return 0;

      case IOP_T_DOUBLE:
        GET_SCALAR(double, opt_double_t, d);
        return 0;

#undef GET_SCALAR

      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA: {
        const lstr_t *str = ptr;

        if (field->repeat == IOP_R_OPTIONAL && !str->s) {
            return IOP_FIELD_NOT_SET;
        } else {
            value->s = lstr_dupc(*str);
        }
        return 0;
      }
      case IOP_T_STRUCT:
      case IOP_T_UNION: {
        if (iop_field_is_pointed(field)) {
            ptr = *(const void **)ptr;
        }

        if (!ptr) {
            return IOP_FIELD_NOT_SET;
        }
        value->p = (void *)ptr;
        return 0;
      }
    }
    return IOP_FIELD_ERROR;
}

static int iop_value_to_ptr(void *ptr, const iop_field_t *field,
                            const iop_value_t *value)
{
#define SET_SCALAR(type, opt, f)                                             \
        if (field->repeat == IOP_R_OPTIONAL) {                               \
            opt *o = ptr;                                                    \
                                                                             \
            OPT_SET(*o, value->f);                                           \
        } else {                                                             \
            *(type *)ptr = value->f;                                         \
        }

    switch (field->type) {
      case IOP_T_I8:
        SET_SCALAR(int8_t, opt_i8_t, i);
        return 0;

      case IOP_T_U8:
        SET_SCALAR(uint8_t, opt_u8_t, u);
        return 0;

      case IOP_T_I16:
        SET_SCALAR(int16_t, opt_i16_t, i);
        return 0;

      case IOP_T_U16:
        SET_SCALAR(uint16_t, opt_u16_t, u);
        return 0;

      case IOP_T_ENUM:
      case IOP_T_I32:
        SET_SCALAR(int32_t, opt_i32_t, i);
        return 0;

      case IOP_T_U32:
        SET_SCALAR(uint32_t, opt_u32_t, u);
        return 0;

      case IOP_T_I64:
        SET_SCALAR(int64_t, opt_i64_t, i);
        return 0;

      case IOP_T_U64:
        SET_SCALAR(uint64_t, opt_u64_t, u);
        return 0;

      case IOP_T_BOOL:
        SET_SCALAR(bool, opt_bool_t, b);
        return 0;

      case IOP_T_DOUBLE:
        SET_SCALAR(double, opt_double_t, d);
        return 0;

#undef SET_SCALAR

      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA: {
        lstr_t *str = ptr;

        *str = lstr_dupc(value->s);
        return 0;
      }
      case IOP_T_STRUCT:
      case IOP_T_UNION: {
        if (iop_field_is_pointed(field)) {
            *(void **)ptr = (void *)value->p;
        } else
        if (value->p != ptr) {
            memcpy(ptr, value->p, field->size);
        }

        return 0;
      }
    }
    return -1;
}

int iop_value_to_repeated_field(void *ptr, const iop_field_t *field,
                                uint32_t pos, const iop_value_t *value)
{
    lstr_t data_s;
    void *data_p;

    if (!expect(field->repeat == IOP_R_REPEATED)) {
        return -1;
    }

    data_s = *(lstr_t *)((byte *)ptr + field->data_offs);
    data_p = (byte *)data_s.data + pos * field->size;

    return iop_value_to_ptr(data_p, field, value);
}

int iop_value_to_field(void *ptr, const iop_field_t *field,
                       const iop_value_t *value)
{
    ptr = (byte *)ptr + field->data_offs;

    return iop_value_to_ptr(ptr, field, value);
}

void iop_set_opt_field(void *ptr, const iop_field_t *field)
{
    if (field->repeat != IOP_R_OPTIONAL) {
        e_panic("non-optional fields are not supported in iop_set_opt_field");
    }

    ptr = (byte *)ptr + field->data_offs;

    switch ((iop_type_t)field->type) {
      case IOP_T_U8: case IOP_T_I8: case IOP_T_BOOL:
        ((opt_i8_t *)ptr)->has_field = true;
        break;

      case IOP_T_U16: case IOP_T_I16:
        ((opt_i16_t *)ptr)->has_field = true;
        break;

      case IOP_T_U32: case IOP_T_I32: case IOP_T_ENUM:
        ((opt_i32_t *)ptr)->has_field = true;
        break;

      case IOP_T_U64: case IOP_T_I64: case IOP_T_DOUBLE:
        ((opt_i64_t *)ptr)->has_field = true;
        break;

      case IOP_T_STRING: case IOP_T_DATA: case IOP_T_XML: {
        lstr_t *s = ptr;

        if (!s->s) {
            assert (!s->len);
            s->s = "";
        }
      } break;

      case IOP_T_UNION: case IOP_T_STRUCT:
        e_panic("unions/structs are not supported in iop_set_opt_field");
        break;
    }
}

iop_struct_t *
iop_type_vector_to_iop_struct(mem_pool_t *mp, lstr_t fullname,
                              const qv_t(iop_field_info) *fields_info)
{
    iop_struct_t *st;
    iop_field_t *field;
    int *ranges;
    int data_offs = 0;
    int max_align = 1;
    int len = fields_info->len;
    int names_len = 0;
    char *names;

    if (!expect(len > 0)) {
        return mp_dup(mp, &iop__void__s, 1);
    }

    qv_for_each_ptr(iop_field_info, field_info, fields_info) {
        names_len += field_info->name.len;
    }

    /* single allocation for output iop_struct_t */
    st = mp_new_extra(mp, iop_struct_t, sizeof(iop_field_t) * len +
                      3 * sizeof(int) +
                      fullname.len * sizeof(char) +
                      names_len * sizeof(char));
    st->fields = (iop_field_t *)&st[1];
    st->ranges = (int *)&st->fields[len];
    ((lstr_t *)&st->fullname)->v = (char *)&st->ranges[3];
    names = st->fullname.v + fullname.len;

    /* fields */
    field = (iop_field_t *)st->fields;
    qv_for_each_ptr(iop_field_info, field_info, fields_info) {
        unsigned field_size = 1;
        int field_align = 1;
        iop_type_t type = field_info->type;
        bool is_optional = field_info->repeat == IOP_R_OPTIONAL;
        int tag;

        switch (type) {
          case IOP_T_I8:
          case IOP_T_U8:
          case IOP_T_BOOL:
            field_size = is_optional ? sizeof(opt_i8_t) : 1;
            field_align = is_optional ? alignof(opt_i8_t) : 1;
            break;
          case IOP_T_I16:
          case IOP_T_U16:
            field_size = is_optional ? sizeof(opt_i16_t) : 2;
            field_align = is_optional ? alignof(opt_i16_t) : 2;
            break;
          case IOP_T_I32:
          case IOP_T_U32:
          case IOP_T_ENUM:
            field_size = is_optional ? sizeof(opt_i32_t) : 4;
            field_align = is_optional ? alignof(opt_i32_t) : 4;
            break;
          case IOP_T_I64:
          case IOP_T_U64:
          case IOP_T_DOUBLE:
            field_size = is_optional ? sizeof(opt_i64_t) : 8;
            field_align = is_optional ? alignof(opt_i64_t) : 8;
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            field_size = sizeof(lstr_t);
            field_align = alignof(lstr_t);
            break;
          case IOP_T_STRUCT:
          case IOP_T_UNION:
            field_size = field_info->u1.st_desc->size;
            field_align = field_size;
            break;
          default:
            /* type not handled */
            assert (0);
            break;
        }

        /* update alignement */
        data_offs   = ROUND_UP(data_offs, field_align);
        max_align   = MAX(max_align, field_align);

        /* update field attributes */
        tag = field - st->fields + 1;
        *field = (iop_field_t){
            .name      = LSTR_NULL,
            .tag       = tag,
            .tag_len   = (tag >= 30) + (tag >= 256),
            .repeat    = field_info->repeat,
            .type      = type,
            .size      = field_size,
            .data_offs = data_offs
        };

        /* set name */
        field->name.s = names;
        field->name.len = field_info->name.len;
        p_copy(field->name.v, field_info->name.v, field_info->name.len);
        names += field_info->name.len;

        if (type == IOP_T_STRUCT || type == IOP_T_UNION) {
            field->u1.st_desc = field_info->u1.st_desc;
        } else
        if (type == IOP_T_ENUM) {
            field->u1.en_desc = field_info->u1.en_desc;
        }

        /* next */
        data_offs += field_size;
        field++;
    }

    /* ranges */
    ranges = (int *)st->ranges;
    ranges[0] = 0;
    ranges[1] = 1;
    ranges[2] = len;

    /* build iop structure for record */
    memcpy((void *)st->fullname.s, fullname.s, fullname.len);
    *(int *)&st->fullname.len = fullname.len;

    st->fields_len = len;
    st->ranges_len = 1;
    st->size       = ROUND_UP(data_offs, max_align);

    return st;
}

lstr_t t_camelcase_to_c(lstr_t s)
{
    t_SB(buf, 64);

    for (int i = 0; i < s.len; i++) {
        if (i && isupper(s.s[i])) {
            sb_addc(&buf, '_');
        }
        sb_addc(&buf, tolower(s.s[i]));
    }

    return lstr_init_(buf.data, buf.len, MEM_STACK);
}

lstr_t t_iop_type_to_c(lstr_t name)
{
    t_SB(buf, 64);
    qv_t(lstr) parts;
    pstream_t ps = ps_initlstr(&name);
    ctype_desc_t dot;

    t_qv_init(lstr, &parts, 3);
    ctype_desc_build(&dot, ".");
    ps_split(ps, &dot, 0, &parts);
    if (!parts.len) {
        return LSTR_EMPTY_V;
    }

    for (int i = 0; i < parts.len - 1; i++) {
        sb_add_lstr(&buf, parts.tab[i]);
        sb_adds(&buf, "__");
    }
    sb_add_lstr(&buf, t_camelcase_to_c(parts.tab[parts.len - 1]));

    return lstr_init_(buf.data, buf.len, MEM_STACK);
}

int c_to_camelcase(lstr_t s, bool is_first_upper, sb_t *out)
{
    pstream_t ps = ps_initlstr(&s);

    THROW_ERR_IF(lstr_endswithc(s, '_'));

    sb_reset(out);
    while (!ps_done(&ps)) {
        pstream_t token;
        pstream_t token2;

        if (ps_get_ps_chr_and_skip(&ps, '_', &token) < 0) {
            token = ps;
            ps = ps_init(NULL, 0);
        }

        /* Validate token */
        THROW_ERR_IF(ps_len(&token) == 0);

        token2 = ps_get_span(&token, &ctype_isalnum);
        THROW_ERR_IF(ps_len(&token) > 0);

        token = ps_get_cspan(&token2, &ctype_isupper);
        THROW_ERR_IF(ps_len(&token2) > 0);

        /* fast path if the string needs no modification */
        if (!is_first_upper && !out->len && ps_done(&ps)) {
            sb_set_lstr(out, s);
            return 0;
        }

        /* Transform token */
        if (is_first_upper || out->len) {
            sb_addc(out, toupper(ps_getc(&token)));
        }
        sb_add(out, token.s, ps_len(&token));
    }
    return 0;
}

bool iop_type_is_scalar(iop_type_t type)
{
    return !((1 << type) & IOP_STRUCTS_OK);
}

bool iop_field_is_pointed(const iop_field_t *fdesc)
{
    if (iop_type_is_scalar(fdesc->type)) {
        return false;
    }

    if (fdesc->repeat == IOP_R_OPTIONAL) {
        return true;
    }

    return iop_field_is_reference(fdesc) || iop_field_is_class(fdesc);
}

static void *iop_get_opt_field(iop_type_t type, void *data)
{
    switch (type) {
      case IOP_T_I8:
      case IOP_T_U8:
        return OPT_GET((opt_u8_t *)data);
      case IOP_T_I16:
      case IOP_T_U16:
        return OPT_GET((opt_u16_t *)data);
      case IOP_T_ENUM:
      case IOP_T_I32:
      case IOP_T_U32:
        return OPT_GET((opt_u32_t *)data);
      case IOP_T_I64:
      case IOP_T_U64:
        return OPT_GET((opt_u64_t *)data);
      case IOP_T_BOOL:
        return OPT_GET((opt_bool_t *)data);
      case IOP_T_DOUBLE:
        return OPT_GET((opt_double_t *)data);
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        return ((lstr_t *)data)->s ? data : NULL;
      case IOP_T_STRUCT:
      case IOP_T_UNION:
        return *(void **)data;
    }

    assert (false);
    return NULL;
}

static const void *iop_get_opt_field_const(iop_type_t type, const void *data)
{
    return iop_get_opt_field(type, (void *)data);
}

void iop_get_field_values(const iop_field_t *fdesc, void *st_ptr,
                          void **values, int *len,
                          bool * nullable is_array_of_pointers)
{
    void *fptr = (byte *)st_ptr + fdesc->data_offs;

    if (fdesc->repeat == IOP_R_REPEATED) {
        iop_array_i8_t *array = fptr;

        *values = array->tab;
        *len = array->len;
        if (is_array_of_pointers) {
            *is_array_of_pointers = iop_field_is_class(fdesc);
        }

        return;
    }

    if (is_array_of_pointers) {
        /* For non-repeated fields, we will always apply the indirection. */
        *is_array_of_pointers = false;
    }

    if (fdesc->repeat == IOP_R_OPTIONAL) {
        fptr = iop_get_opt_field(fdesc->type, fptr);
        if (!fptr) {
            /* The optional field is absent. */
            *len = 0;
            *values = NULL;
            return;
        }

        *values = fptr;
    } else
    if (iop_field_is_pointed(fdesc)) {
        *values = *(void **)fptr;
    } else {
        *values = fptr;
    }

    *len = 1;
}

void iop_get_field_values_const(const iop_field_t *fdesc, const void *st_ptr,
                                const void **values, int *len,
                                bool * nullable is_array_of_pointers)
{
    iop_get_field_values(fdesc, (void *)st_ptr, (void **)values, len,
                         is_array_of_pointers);
}

/* }}} */
/* {{{ Iop type string description */

const char *iop_type_get_string_desc(iop_type_t type)
{
    switch (type) {
      case IOP_T_I8:
        return "byte";
      case IOP_T_I16:
        return "short";
      case IOP_T_I32:
        return "int";
      case IOP_T_I64:
        return "long";
      case IOP_T_U8:
        return "ubyte";
      case IOP_T_U16:
        return "ushort";
      case IOP_T_U32:
        return "uint";
      case IOP_T_U64:
        return "ulong";
      case IOP_T_BOOL:
        return "bool";
      case IOP_T_ENUM:
        return "enum";
      case IOP_T_DOUBLE:
        return "double";
      case IOP_T_STRING:
        return "string";
      case IOP_T_DATA:
        return "bytes";
      case IOP_T_UNION:
        return "union";
      case IOP_T_STRUCT:
        return "struct";
      case IOP_T_XML:
        return "xml";
    }
    e_panic("iop_type unsupported");
}

/* }}} */
/* {{{ Generic attributes */

static bool iop_type_is_string(iop_type_t type)
{
    switch (type) {
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        return true;

      default:
        return false;
    }
}

static int iop_convert_i64(int64_t i64, iop_type_t type, iop_value_t *value)
{
#define CHECK_RANGE(_min, _max)  THROW_ERR_IF(i64 < _min || i64 > _max)

    switch (type) {
      case IOP_T_I8:
        CHECK_RANGE(INT8_MIN, INT8_MAX);
        value->i = i64;
        break;
      case IOP_T_U8:
        CHECK_RANGE(0, UINT8_MAX);
        value->u = i64;
        break;
      case IOP_T_I16:
        CHECK_RANGE(INT16_MIN, INT16_MAX);
        value->i = i64;
        break;
      case IOP_T_U16:
        CHECK_RANGE(0, UINT16_MAX);
        value->u = i64;
        break;
      case IOP_T_I32:
        CHECK_RANGE(INT32_MIN, INT32_MAX);
        value->i = i64;
        break;
      case IOP_T_U32:
        CHECK_RANGE(0, UINT32_MAX);
        value->u = i64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        value->i = i64;
        break;
      case IOP_T_BOOL:
        CHECK_RANGE(0, 1);
        value->b = i64;
        break;
      case IOP_T_DOUBLE:
        value->d = i64;
        break;
      default:
        return -1;
    }

#undef CHECK_RANGE
    return 0;
}

#define ATTR_IS_GENERIC(_attr, _what)                                        \
    (_attr->type == IOP_##_what##_GEN_ATTR_S                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_O                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_I                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_D)

static int iop_convert_value(iop_type_t exp_type, iop_type_t val_type,
                             iop_value_t *value)
{
    switch (val_type) {
      case IOP_T_STRING:
        return iop_type_is_string(exp_type) ? 0 : -1;

      case IOP_T_I64:
        return iop_convert_i64(value->i64, exp_type, value);

      case IOP_T_DOUBLE:
        return exp_type == IOP_T_DOUBLE ? 0 : -1;

      default:
        e_panic("iop_type unsupported");
    }
}

#define __get_gen_attr_value(_attrs, _len, _key, _what, _what_l,           \
                             _exp_type, _val_type, _val)                   \
    ({                                                                     \
        int _res = -1;                                                     \
        iop_type_t _attr_type;                                             \
                                                                           \
        for (int _i = 0; _i < _len; _i++) {                                \
            const iop_##_what_l##_attr_t *_attr = _attrs + _i;             \
                                                                           \
            if (!ATTR_IS_GENERIC(_attr, _what)                             \
            ||  !lstr_equal(_key, _attr->args[0].v.s))                     \
            {                                                              \
                continue;                                                  \
            }                                                              \
                                                                           \
            _res = 0;                                                      \
            switch (_attr->type) {                                         \
              case IOP_##_what##_GEN_ATTR_O:                               \
              case IOP_##_what##_GEN_ATTR_S:                               \
                _val->s = _attr->args[1].v.s;                              \
                _attr_type = IOP_T_STRING;                                 \
                break;                                                     \
              case IOP_##_what##_GEN_ATTR_I:                               \
                _val->i64 = _attr->args[1].v.i64;                          \
                _attr_type = IOP_T_I64;                                    \
                break;                                                     \
              case IOP_##_what##_GEN_ATTR_D:                               \
                _val->d = _attr->args[1].v.d;                              \
                _attr_type = IOP_T_DOUBLE;                                 \
                break;                                                     \
              default:                                                     \
                e_panic("invalid generic attribute type");                 \
            }                                                              \
            break;                                                         \
        }                                                                  \
                                                                           \
        if (_res == 0) {                                                   \
            if ((int)_exp_type >= 0) {                                     \
                _res = iop_convert_value(_exp_type, _attr_type, _val);     \
            }                                                              \
            if (_val_type) {                                               \
                *_val_type = _attr_type;                                   \
            }                                                              \
        }                                                                  \
                                                                           \
        _res;                                                              \
    })

int iop_struct_get_gen_attr(const iop_struct_t *st, lstr_t key,
                            iop_type_t exp_type, iop_type_t *val_type,
                            iop_value_t *value)
{
    unsigned flags = st->flags;

    if (!TST_BIT(&flags, IOP_STRUCT_EXTENDED) || !st->st_attrs) {
        return -1;
    }
    return __get_gen_attr_value(st->st_attrs->attrs, st->st_attrs->attrs_len,
                                key, STRUCT, struct, exp_type, val_type,
                                value);
}

int iop_enum_get_gen_attr(const iop_enum_t *en, lstr_t key,
                          iop_type_t exp_type, iop_type_t *val_type,
                          iop_value_t *value)
{
    if (!TST_BIT(&en->flags, IOP_ENUM_EXTENDED) || !en->en_attrs) {
        return -1;
    }
    return __get_gen_attr_value(en->en_attrs->attrs, en->en_attrs->attrs_len,
                                key, ENUM, enum, exp_type, val_type, value);
}

static int iop_enum_pos_from_val(const iop_enum_t *e, int val);
static int iop_enum_pos_from_str(const iop_enum_t *e, const char *s, int len);

int iop_enum_get_gen_attr_from_val(const iop_enum_t *ed, int val, lstr_t key,
                                   iop_type_t exp_type, iop_type_t *val_type,
                                   iop_value_t *value)
{
    const iop_enum_value_attrs_t *va;
    int pos;

    if (!TST_BIT(&ed->flags, IOP_ENUM_EXTENDED) || !ed->values_attrs) {
        return -1;
    }
    pos = RETHROW(iop_enum_pos_from_val(ed, val));
    va = &ed->values_attrs[pos];
    return __get_gen_attr_value(va->attrs, va->attrs_len, key, ENUM_VALUE,
                                enum_value, exp_type, val_type, value);
}

int iop_enum_get_gen_attr_from_str(const iop_enum_t *ed, lstr_t val,
                                   lstr_t key, iop_type_t exp_type,
                                   iop_type_t *val_type, iop_value_t *value)
{
    const iop_enum_value_attrs_t *va;
    int pos;

    if (!TST_BIT(&ed->flags, IOP_ENUM_EXTENDED) || !ed->values_attrs) {
        return -1;
    }
    pos = RETHROW(iop_enum_pos_from_str(ed, val.s, val.len));
    va = &ed->values_attrs[pos];
    return __get_gen_attr_value(va->attrs, va->attrs_len, key, ENUM_VALUE,
                                enum_value, exp_type, val_type, value);
}

int iop_iface_get_gen_attr(const iop_iface_t *iface, lstr_t key,
                           iop_type_t exp_type, iop_type_t *val_type,
                           iop_value_t *value)
{
    if (!TST_BIT(&iface->flags, IOP_IFACE_HAS_ATTRS) || !iface->iface_attrs) {
        return -1;
    }
    return __get_gen_attr_value(iface->iface_attrs->attrs,
                                iface->iface_attrs->attrs_len, key, IFACE,
                                iface, exp_type, val_type, value);
}

int iop_rpc_get_gen_attr(const iop_iface_t *iface, const iop_rpc_t *rpc,
                         lstr_t key, iop_type_t exp_type,
                         iop_type_t *val_type, iop_value_t *value)
{
    const iop_rpc_attrs_t *attrs = RETHROW_PN(iop_rpc_get_attrs(iface, rpc));

    return __get_gen_attr_value(attrs->attrs, attrs->attrs_len, key, RPC,
                                rpc, exp_type, val_type, value);
}

int iop_field_get_gen_attr(const iop_struct_t *st, const iop_field_t *field,
                           lstr_t key, iop_type_t exp_type,
                           iop_type_t *val_type, iop_value_t *value)
{
    const iop_field_attrs_t *attrs = RETHROW_PN(iop_field_get_attrs(st,
                                                                    field));

    return __get_gen_attr_value(attrs->attrs, attrs->attrs_len, key, FIELD,
                                field, exp_type, val_type, value);
}

bool iop_field_get_bool_gen_attr(const iop_struct_t *st,
                                 const iop_field_t *field, lstr_t key,
                                 bool def)
{
    iop_value_t value;

    if (iop_field_get_gen_attr(st, field, key, IOP_T_BOOL, NULL, &value) < 0)
    {
        return def;
    }

    return value.b;
}

int iop_field_by_name_get_gen_attr(const iop_struct_t *st, lstr_t f_name,
                                   lstr_t key, iop_type_t exp_type,
                                   iop_type_t *val_type, iop_value_t *value)
{
    int pos = RETHROW(__iop_field_find_by_name2(st, f_name));
    const iop_field_t *field = st->fields + pos;

    return iop_field_get_gen_attr(st, field, key, exp_type, val_type, value);
}

/* }}} */
/* {{{ iop_init / iop_new */

static void
iop_init_fields(void *value, const iop_field_t *fdesc, const iop_field_t *end)
{
    for (; fdesc < end; fdesc++) {
        void *ptr = (char *)value + fdesc->data_offs;

        if (fdesc->repeat == IOP_R_REQUIRED && fdesc->type == IOP_T_STRUCT) {
            /* We can't handle the unions here since we don't know which field
             * has been selected */
            const iop_struct_t *desc = fdesc->u1.st_desc;

            if (iop_field_is_pointed(fdesc)) {
                /* Field should be initialized as an optional field: NULL
                 * pointer. */
                continue;
            }

            iop_init_fields(ptr, desc->fields, desc->fields +
                            desc->fields_len);
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            switch (fdesc->type) {
              case IOP_T_I8: case IOP_T_U8:
                *(uint8_t *)ptr  = fdesc->u1.defval_u64;
                break;
              case IOP_T_I16: case IOP_T_U16:
                *(uint16_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_ENUM:
                *(uint32_t *)ptr = fdesc->u0.defval_enum;
                break;
              case IOP_T_I32: case IOP_T_U32:
                *(uint32_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_I64: case IOP_T_U64:
                *(uint64_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_BOOL:
                *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
                break;
              case IOP_T_DOUBLE:
                *(double *)ptr   = fdesc->u1.defval_d;
                break;
              case IOP_T_STRING:
              case IOP_T_XML:
              case IOP_T_DATA:
                *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data,
                                             fdesc->u0.defval_len);
                break;
              default:
                e_panic("unsupported");
                continue;
            }
        }
    }
}
void iop_init_desc(const iop_struct_t *desc, void *value)
{
    memset(value, 0, desc->size);

    if (iop_struct_is_class(desc)) {
        const iop_struct_t **__vptr = value;
        const iop_struct_t *parent = desc;

        e_assert(panic, !desc->class_attrs->is_abstract,
                 "initialization of abstract class '%*pM' is forbidden",
                 LSTR_FMT_ARG(desc->fullname));

        *__vptr = desc;

        while ((parent = parent->class_attrs->parent)) {
            iop_init_fields(value, parent->fields,
                            parent->fields + parent->fields_len);
        }
    }

    iop_init_fields(value, desc->fields, desc->fields + desc->fields_len);
}

void *mp_iop_new_desc(mem_pool_t *mp, const iop_struct_t *st)
{
    void *res = mp_imalloc(mp, st->size, 8, MEM_RAW);

    iop_init_desc(st, res);

    return res;
}

/* }}} */
/* {{{ Duplicating values */

static size_t iop_dup_size(const iop_struct_t *desc, const void *val);

static size_t __iop_dup_size(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    size_t len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        bool is_class = iop_field_is_class(fdesc);
        bool is_ref   = iop_field_is_reference(fdesc);
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n    = ((lstr_t *)ptr)->len;
            ptr  = ((lstr_t *)ptr)->data;
            len += ROUND_UP(n * fdesc->size, 8);
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                ptr = *(void **)ptr;
                if (is_class) {
                    /* Do not take the field size, but the size of the
                     * actually instanciated class */
                    len += ROUND_UP((*(const iop_struct_t **)ptr)->size, 8);
                } else {
                    len += ROUND_UP(fdesc->size, 8);
                }
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional reference fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    v = *(void **)v;
                    if (is_class) {
                        len += ROUND_UP((*(const iop_struct_t **)v)->size, 8);
                    }
                }
                if (is_class) {
                    len += iop_dup_size(fdesc->u1.st_desc, v);
                } else {
                    if (is_ref) {
                        len += ROUND_UP(fdesc->size, 8);
                    }
                    len += __iop_dup_size(fdesc->u1.st_desc, v);
                }
            }
        } else {
            for (int j = 0; j < n; j++) {
                len += ROUND_UP(IOP_FIELD(lstr_t, ptr, j).len + 1, 8);
            }
        }
    }

    return len;
}

static size_t iop_dup_size(const iop_struct_t *desc, const void *val)
{
    if (iop_struct_is_class(desc)) {
        size_t len = 0;

        desc = *(const iop_struct_t **)val;
        do {
            len += __iop_dup_size(desc, val);
        } while ((desc = desc->class_attrs->parent));

        return len;
    } else {
        return __iop_dup_size(desc, val);
    }
}

static uint8_t *realign(uint8_t *ptr)
{
    return (uint8_t *)ROUND_UP((uintptr_t)ptr, 8);
}

static uint8_t *__iop_copy_class(const iop_struct_t *st, uint8_t *dst,
                                 void *wval, const void *rval);

static uint8_t *
__iop_copy(const iop_struct_t *st, uint8_t *dst, void *wval, const void *rval)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        fdesc = get_union_field(st, rval);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *rp = (char *)rval + fdesc->data_offs;
        const void *wp = (char *)wval + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n = ((lstr_t *)rp)->len;
            if (n) {
                rp  = ((lstr_t *)rp)->data;
                wp  = ((lstr_t *)wp)->data = dst;
                dst = realign(mempcpy(dst, rp, n * fdesc->size));
            } else {
                ((lstr_t *)wp)->data = NULL;
                wp  = dst;
                dst = realign(dst);
            }
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, rp))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                rp = *(void **)rp;
                wp = *(void **)wp = dst;
                if (!iop_field_is_class(fdesc)) {
                    /* Will be done in __iop_copy_class for classes */
                    dst = realign(mempcpy(dst, rp, fdesc->size));
                }
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);

            for (int j = 0; j < n; j++) {
                const void *rv = &IOP_FIELD(const char, rp, j * fdesc->size);
                void       *wv = &IOP_FIELD(char,       wp, j * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional referenced fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    rv = *(void **)rv;
                    wv = *(void **)wv = dst;
                }
                if (is_class) {
                    dst = __iop_copy_class(fdesc->u1.st_desc, dst, wv, rv);
                } else {
                    if (is_ref) {
                        /* Will be done in __iop_copy_class for classes */
                        dst = realign(mempcpy(dst, rv, fdesc->size));
                    }
                    dst = __iop_copy(fdesc->u1.st_desc, dst, wv, rv);
                }
            }
        } else {
            assert (fdesc->type == IOP_T_STRING || fdesc->type == IOP_T_XML
                ||  fdesc->type == IOP_T_DATA);

            for (int j = 0; j < n; j++) {
                lstr_t *orig = &IOP_FIELD(lstr_t, rp, j);

                /* We have to fix the lstr_t mem_pool manually because some
                 * naughty programmers could have played with it */
                IOP_FIELD(lstr_t, wp, j).data = dst;
                IOP_FIELD(lstr_t, wp, j).mem_pool = MEM_STATIC;
                dst = realign(mempcpyz(dst, orig->s, orig->len));
            }
        }
    }

    return dst;
}

static uint8_t *__iop_copy_class(const iop_struct_t *st, uint8_t *dst,
                                 void *wval, const void *rval)
{
    st = *(const iop_struct_t **)rval;
    dst = realign(mempcpy(dst, rval, st->size));

    do {
        dst = __iop_copy(st, dst, wval, rval);
    } while ((st = st->class_attrs->parent));

    return dst;
}

void *mp_iop_dup_desc_sz(mem_pool_t *mp, const iop_struct_t *st,
                         const void *v, size_t * nullable psz)
{
    bool is_class;
    size_t sz;
    uint8_t *dst, *res;

    RETHROW_P(v);

    if ((is_class = iop_struct_is_class(st))) {
        st = *(const iop_struct_t **)v;
        sz = ROUND_UP(st->size, 8) + iop_dup_size(st, v);
    } else {
        sz = ROUND_UP(st->size, 8) + __iop_dup_size(st, v);
    }
    if (psz) {
        *psz = sz;
    }

    res = mp_imalloc(mp, sz, 8, MEM_RAW);
    dst = realign(mempcpy(res, v, st->size));

    if (is_class) {
        do {
            dst = __iop_copy(st, dst, res, v);
        } while ((st = st->class_attrs->parent));
    } else {
        dst = __iop_copy(st, dst, res, v);
    }

    assert (dst == res + sz);
    return res;
}

void mp_iop_copy_desc_sz(mem_pool_t *mp, const iop_struct_t *st, void **outp,
                         const void *v, size_t * nullable psz)
{
    bool is_class;
    size_t sz;
    uint8_t *dst, *res = *outp;

    if (unlikely(!v)) {
        mp_delete(mp, outp);
        return;
    }

    if ((is_class = iop_struct_is_class(st))) {
        st = *(const iop_struct_t **)v;
        sz = ROUND_UP(st->size, 8) + iop_dup_size(st, v);
    } else {
        sz = ROUND_UP(st->size, 8) + __iop_dup_size(st, v);
    }

    if (psz) {
        *psz = sz;
    }

    res = mp_irealloc(mp, res, 0, sz, 8, MEM_RAW);
    dst = realign(mempcpy(res, v, st->size));

    if (is_class) {
        do {
            dst = __iop_copy(st, dst, res, v);
        } while ((st = st->class_attrs->parent));
    } else {
        dst = __iop_copy(st, dst, res, v);
    }

    assert (dst == res + sz);
    *outp = res;
}

void mp_iop_obj_copy(mem_pool_t *mp, void *out, const void *v, unsigned flags)
{
    size_t offset = sizeof(iop_struct_t *);
    const iop_struct_t *v_desc = *(const iop_struct_t **)v;

    assert (iop_obj_is_a_desc(out, v_desc));

    if (flags & IOP_OBJ_DEEP_COPY) {
        assert (0 && "DEEP COPY UNIMPLEMENTED");
    }

    memcpy((char *)out + offset, (const char *)v + offset,
           v_desc->size - offset);
}

/* }}} */
/* {{{ Comparing values */

__cold static void
sb_prepend_field(sb_t *sb, const iop_field_t *fdesc, int j);

static int iop_first_diff(const iop_struct_t *st,
                          const void *v1, const void *v2,
                          sb_t *field_path, sb_t *diff_desc);

static bool iop_value_equals(iop_type_t type, const void *v1, const void *v2)
{
    switch (type) {
      case IOP_T_BOOL:
        return *(const bool *)v1 == *(const bool *)v2;

      case IOP_T_U8:
      case IOP_T_I8:
        return *(const int8_t *)v1 == *(const int8_t *)v2;

      case IOP_T_U16:
      case IOP_T_I16:
        return *(const int16_t *)v1 == *(const int16_t *)v2;

      case IOP_T_U32:
      case IOP_T_I32:
      case IOP_T_ENUM:
        return *(const int32_t *)v1 == *(const int32_t *)v2;

      case IOP_T_U64:
      case IOP_T_I64:
        return *(const int64_t *)v1 == *(const int64_t *)v2;

      case IOP_T_DOUBLE:
        return *(const double *)v1 == *(const double *)v2;

      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        return lstr_equal(*(const lstr_t *)v1, *(const lstr_t *)v2);

      case IOP_T_UNION:
      case IOP_T_STRUCT:
        e_panic("not supported");
    }

    return false;
}

static void iop_value_print(iop_type_t type, const void *v, sb_t *buf)
{
    switch (type) {
      case IOP_T_BOOL:
        sb_adds(buf, *(const bool *)v ? "true" : "false");
        break;

#define CASE_NUMBER(type, fmt, type_t)                                       \
      case type:                                                             \
        sb_addf(buf, fmt, *(const type_t *)v);                               \
        break;

      CASE_NUMBER(IOP_T_U8, "%u", uint8_t);
      CASE_NUMBER(IOP_T_I8, "%d", int8_t);
      CASE_NUMBER(IOP_T_U16, "%u", uint16_t);
      CASE_NUMBER(IOP_T_I16, "%d", int16_t);
      CASE_NUMBER(IOP_T_U32, "%u", uint32_t);
      CASE_NUMBER(IOP_T_I32, "%d", int32_t);
      CASE_NUMBER(IOP_T_ENUM, "%d", int32_t);
      CASE_NUMBER(IOP_T_U64, "%ju", uint64_t);
      CASE_NUMBER(IOP_T_I64, "%jd", int64_t);
      CASE_NUMBER(IOP_T_DOUBLE, "%f", double);

#undef CASE_NUMBER

      case IOP_T_STRING:
      case IOP_T_XML:
        sb_add_lstr(buf, *(const lstr_t *)v);
        break;

      case IOP_T_DATA: {
        lstr_t data = *(const lstr_t *)v;

        sb_add_hex(buf, data.data, data.len);
      } break;

      case IOP_T_UNION:
      case IOP_T_STRUCT:
        e_panic("not supported");
    }
}

/* Returns -1 if no diff found, 0 otherwise. */
static int __iop_first_diff(const iop_struct_t *st,
                            const void *v1, const void *v2,
                            sb_t *field_path, sb_t *diff_desc)
{
    const iop_field_t *fdesc;
    int i = 0;
    const iop_field_t *end;

    if (st->is_union) {
        if (*(uint16_t *)v1 != *(uint16_t *)v2) {
            sb_setf(diff_desc, "union field differs (`%*pU` vs `%*pU`)",
                    *(uint16_t *)v1, st, *(uint16_t *)v2, st);
            return -1;
        }

        fdesc = get_union_field(st, v1);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r1;
        const void *r2;
        int len1;
        int len2;
        bool is_array_of_pointers;

        iop_get_field_values_const(fdesc, v1, &r1, &len1,
                                   &is_array_of_pointers);
        iop_get_field_values_const(fdesc, v2, &r2, &len2, NULL);

        if (len1 != len2) {
            if (fdesc->repeat == IOP_R_REPEATED) {
                sb_setf(diff_desc, "array length differs (%d vs %d)",
                        len1, len2);
            } else {
                sb_setf(diff_desc,
                        "field presence differs (field absent on %s value)",
                        len1 ? "second" : "first");
            }
            goto print_field;
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            /* We need to recurse to compare structures & unions. */
            for (i = 0; i < len1; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if (is_array_of_pointers) {
                    t1  = *(void **)t1;
                    t2  = *(void **)t2;
                }

                if (iop_first_diff(fdesc->u1.st_desc, t1, t2,
                                        field_path, diff_desc) >= 0)
                {
                    goto print_field;
                }
            }
        } else {
            for (i = 0; i < len1; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if (!iop_value_equals(fdesc->type, t1, t2)) {
                    sb_sets(diff_desc, "value differs (`");
                    iop_value_print(fdesc->type, t1, diff_desc);
                    sb_adds(diff_desc, "` vs `");
                    iop_value_print(fdesc->type, t2, diff_desc);
                    sb_adds(diff_desc, "`)");

                    goto print_field;
                }
            }
        }
    }

    return -1;

  print_field:
    sb_prepend_field(field_path, fdesc, i);
    return 0;
}

static int iop_first_diff(const iop_struct_t *st,
                          const void *v1, const void *v2,
                          sb_t *field_path, sb_t *diff_desc)
{
    THROW_ERR_IF(v1 == v2);

    if (iop_struct_is_class(st)) {
        const iop_struct_t *st2 = *(const iop_struct_t **)v2;

        st = *(const iop_struct_t **)v1;
        if (st != st2) {
            sb_setf(diff_desc, "class type differs (%*pM vs %*pM)",
                    LSTR_FMT_ARG(st->fullname),
                    LSTR_FMT_ARG(st2->fullname));
            return 0;
        }

        do {
            if (__iop_first_diff(st, v1, v2, field_path, diff_desc) >= 0) {
                return 0;
            }
        } while ((st = st->class_attrs->parent));

        return -1;
    }

    return __iop_first_diff(st, v1, v2, field_path, diff_desc);
}

int iop_first_diff_desc(const iop_struct_t *st,
                        const void *v1, const void *v2, sb_t *diff_desc)
{
    SB_1k(field_path);

    sb_reset_reverse(&field_path);
    RETHROW(iop_first_diff(st, v1, v2, &field_path, diff_desc));

    if (field_path.len) {
        assert (field_path.data[0] == '.');
        sb_skip(&field_path, 1);
        sb_prependf(diff_desc, "field `%*pM`: ", SB_FMT_ARG(&field_path));
    }

    return 0;
}

static bool
__iop_equals(const iop_struct_t *st, const uint8_t *v1, const uint8_t *v2)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        if (*(uint16_t *)v1 != *(uint16_t *)v2)
            return false;
        fdesc = get_union_field(st, v1);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r1 = v1 + fdesc->data_offs;
        const void *r2 = v2 + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            /* Here we just check the length of the repeated field, then we
             * position our pointers on values to compare them later. */
            n   = ((lstr_t *)r1)->len;
            if (((lstr_t *)r2)->len != n)
                return false;
            r1  = ((lstr_t *)r1)->data;
            r2  = ((lstr_t *)r2)->data;
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            /* Optional blocks types cannot be compared using a single memcmp
             * we need to handle absent values first. */
            bool has = iop_value_has(fdesc, r1);

            if (has != iop_value_has(fdesc, r2))
                return false;
            if (!has)
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                /* Structures & unions must be dereferenced */
                r1  = *(void **)r1;
                r2  = *(void **)r2;
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);

            /* We need to recurse to compare structures & unions. */
            for (int i = 0; i < n; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done just
                     *  above).
                     */
                    t1  = *(void **)t1;
                    t2  = *(void **)t2;
                }
                if (is_class) {
                    THROW_IF(!iop_equals_desc(fdesc->u1.st_desc, t1, t2),
                             false);
                } else {
                    THROW_IF(!__iop_equals(fdesc->u1.st_desc, t1, t2), false);
                }
            }
        } else
        if ((1 << fdesc->type) & IOP_BLK_OK) {
            /* Blocks (string & co) must be compared one by one */
            for (int i = 0; i < n; i++) {
                const lstr_t *t1 = &IOP_FIELD(const lstr_t, r1, i);
                const lstr_t *t2 = &IOP_FIELD(const lstr_t, r2, i);

                if (t1->len != t2->len || memcmp(t1->data, t2->data, t1->len))
                    return false;
            }
        } else {
            assert (fdesc->size > 0 && "IOPC is probably outdated");
            if (!iop_scalar_equals(fdesc, r1, r2, n))
                return false;
        }
    }

    return true;
}

bool iop_equals_desc(const iop_struct_t *st, const void *v1, const void *v2)
{
    if (v1 && v2) {
        if (iop_struct_is_class(st)) {
            const iop_struct_t *st2 = *(const iop_struct_t **)v2;

            st = *(const iop_struct_t **)v1;
            if (st != st2) {
                return false;
            }

            do {
                if (!__iop_equals(st, v1, v2)) {
                    return false;
                }
            } while ((st = st->class_attrs->parent));

            return true;
        }

        return __iop_equals(st, v1, v2);
    } else {
        return v1 == v2 || (st->size == 0);
    }
}

/* }}} */
/* {{{ Sorting values */
/* {{{ Field path */

typedef struct field_step_t {
    uint16_t offset;
    uint16_t union_tag;
    flag_t   is_union   : 1;
} field_step_t;
GENERIC_INIT(field_step_t, field_step);

qvector_t(field_step, field_step_t);

typedef struct field_path_t {
    qv_t(field_step)    steps;
    const iop_field_t  *fdesc;
    flag_t is_typename : 1;
} field_path_t;
GENERIC_FUNCTIONS(field_path_t, field_path);

/* {{{ Get */

static const void *
iop_get_fieldp(const void *data, const field_path_t *field_path)
{
    const qv_t(field_step)  *steps = &field_path->steps;
    const iop_field_t       *fdesc = field_path->fdesc;

    RETHROW_P(data);

    for (int i = 0; i < steps->len - 1; i++) {
        field_step_t *step = &steps->tab[i];

        data = ((const byte *)data) + step->offset;

        if (step->is_union) {
            /* Check if the selected member of the union is the one we want
             * (the one specified in field_path), and if not this object is
             * considered as NULL in the sort/filter. */
            if (*(const uint16_t *)data != step->union_tag) {
                return NULL;
            }
        } else {
            /* Pointed structure or union (optional), or classes */
            data = RETHROW_P(*((void **)data));
        }
    }

    data = ((const byte *)data) + qv_last(field_step, steps)->offset;

    if (field_path->is_typename) {
        const iop_struct_t *st = *(const void **)data;

        return &st->fullname;
    }

    if (fdesc->repeat == IOP_R_REPEATED) {
        int len = ((iop_array_i8_t *)data)->len;

        return len ? data : NULL;
    }

    if (fdesc->type == IOP_T_UNION
    ||  fdesc->repeat != IOP_R_OPTIONAL || fdesc->type == IOP_T_STRUCT)
    {
        return data;
    }

    return iop_get_opt_field_const(fdesc->type, data);
}

/* }}} */
/* {{{ Compile */

static int
t_iop_compile_field_path(const iop_struct_t *st, lstr_t field_path_s,
                         field_path_t *fp, sb_t *err)
{
    const iop_field_t *fdesc = NULL;
    pstream_t field_path_ps = ps_initlstr(&field_path_s);
    const iop_struct_t *it = st;
    field_step_t *step;

    if (ps_done(&field_path_ps)) {
        if (err) {
            sb_adds(err, "cannot process empty field path");
        }
        return -1;
    }
    step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
    while (!ps_done(&field_path_ps)) {
        pstream_t fname;

        if (ps_get_ps_chr_and_skip(&field_path_ps, '.', &fname) < 0) {
            fname = field_path_ps;
            __ps_skip_upto(&field_path_ps, field_path_ps.p_end);
        }

        if (ps_done(&fname)) {
            if (err) {
                sb_addf(err, "cannot process field path `%*pM' "
                        "abnormal termination",
                        LSTR_FMT_ARG(field_path_s));
            }
            return -1;
        }

        if (ps_strequal(&fname, "_class")) {
            if (!ps_done(&field_path_ps)) {
                if (err) {
                    sb_adds(err, "cannot fetch subfield of a typename");
                }
                return -1;
            }
            if (!iop_struct_is_class(it)) {
                if (err) {
                    sb_adds(err, "cannot fetch typename of a non-class object");
                }
                return -1;
            }
            fp->is_typename = true;
            break;
        }

        if (iop_field_find_by_name(it, LSTR_PS_V(&fname), NULL,
                                   &fdesc) < 0)
        {
            if (err) {
                sb_addf(err, "cannot process field path `%*pM', "
                        "field `%*pM' is unknown in structure `%*pM'",
                        LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname),
                        LSTR_FMT_ARG(it->fullname));
            }
            return -1;
        }

        if (fdesc->repeat == IOP_R_REPEATED && !ps_done(&field_path_ps)) {
            /* XXX we could also sort the repeated fields based on their
             * number of elements
             */
            if (err) {
                sb_addf(err, "cannot process field path `%*pM', "
                        "field `%*pM' is repeated in structure `%*pM'",
                        LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname),
                        LSTR_FMT_ARG(it->fullname));
            }
            return -1;
        }
        if (it->is_union) {
            step->is_union = true;
            step->union_tag = fdesc->tag;
            step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
        }

        step->offset += fdesc->data_offs;
        if (fdesc->type == IOP_T_STRUCT || fdesc->type == IOP_T_UNION) {
            it = fdesc->u1.st_desc;

            if (iop_field_is_pointed(fdesc)) {
                step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
            }
        }
    }

    fp->fdesc = fdesc;

    return 0;
}

/* }}} */
/* }}} */
/* {{{ cmp functions */

static cmp_f const iop_cmp_funs[] = {
    [IOP_T_I8]          = &cmp_i8,
    [IOP_T_U8]          = &cmp_u8,
    [IOP_T_I16]         = &cmp_i16,
    [IOP_T_U16]         = &cmp_u16,
    [IOP_T_ENUM]        = &cmp_i32,
    [IOP_T_I32]         = &cmp_i32,
    [IOP_T_U32]         = &cmp_u32,
    [IOP_T_I64]         = &cmp_i64,
    [IOP_T_U64]         = &cmp_u64,
    [IOP_T_BOOL]        = &cmp_bool,
    [IOP_T_DOUBLE]      = &cmp_double,
    [IOP_T_UNION]       = &cmp_u16, /* XXX: we compare the union tag. */
    [IOP_T_STRING]      = &cmp_lstr_iutf8,
    [IOP_T_XML]         = &cmp_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_lstr_iutf8,
};
static cmp_f const iop_cmp_rev_funs[] = {
    [IOP_T_I8]          = &cmp_rev_i8,
    [IOP_T_U8]          = &cmp_rev_u8,
    [IOP_T_I16]         = &cmp_rev_i16,
    [IOP_T_U16]         = &cmp_rev_u16,
    [IOP_T_ENUM]        = &cmp_rev_i32,
    [IOP_T_I32]         = &cmp_rev_i32,
    [IOP_T_U32]         = &cmp_rev_u32,
    [IOP_T_I64]         = &cmp_rev_i64,
    [IOP_T_U64]         = &cmp_rev_u64,
    [IOP_T_BOOL]        = &cmp_rev_bool,
    [IOP_T_DOUBLE]      = &cmp_rev_double,
    [IOP_T_UNION]       = &cmp_rev_u16, /* XXX: we compare the union tag. */
    [IOP_T_STRING]      = &cmp_rev_lstr_iutf8,
    [IOP_T_XML]         = &cmp_rev_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_rev_lstr_iutf8,
};

/*}}}*/
/* {{{ equality functions */

/* Equality functions must return 0 if values are equal and another value of
 * values are different. */

static int iop_string_sql_like(const void *s1, const void *s2)
{
    return lstr_utf8_is_ilike(*(const lstr_t *)s1,
                              *(const lstr_t *)s2) ? 0 : -1;
}

static cmp_f const iop_equal_funs_sql_like[] = {
    [IOP_T_I8]          = &cmp_i8,
    [IOP_T_U8]          = &cmp_u8,
    [IOP_T_I16]         = &cmp_i16,
    [IOP_T_U16]         = &cmp_u16,
    [IOP_T_ENUM]        = &cmp_i32,
    [IOP_T_I32]         = &cmp_i32,
    [IOP_T_U32]         = &cmp_u32,
    [IOP_T_I64]         = &cmp_i64,
    [IOP_T_U64]         = &cmp_u64,
    [IOP_T_BOOL]        = &cmp_bool,
    [IOP_T_DOUBLE]      = &cmp_double,
    [IOP_T_UNION]       = &cmp_u16,
    [IOP_T_STRING]      = &iop_string_sql_like,
    [IOP_T_XML]         = &cmp_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_lstr_iutf8,
};

/*}}}*/

typedef struct iop_sort_priv_t {
    field_path_t fp;
    int flags;
    cmp_f cmp;
} iop_sort_priv_t;

qvector_t(iop_sort_p, iop_sort_priv_t);

static int
compare_field(const void *d1, const void *d2, const iop_sort_priv_t *priv)
{
    d1 = iop_get_fieldp(d1, &priv->fp);
    d2 = iop_get_fieldp(d2, &priv->fp);
    if (d1 == d2) {
        return 0;
    }
    if (!d1) {
        return (priv->flags & IOP_SORT_NULL_FIRST) ? -1 : 1;
    }
    if (!d2) {
        return (priv->flags & IOP_SORT_NULL_FIRST) ? 1 : -1;
    }
    return priv->cmp(d1, d2);
}

int iop_msort_desc(const iop_struct_t *st, void *vec, int len,
                   const qv_t(iop_sort) *params, sb_t *err)
{
    t_scope;
    bool is_class = iop_struct_is_class(st);
    qv_t(iop_sort_p) sorts;

    t_qv_init(iop_sort_p, &sorts, params->len);
    qv_growlen(iop_sort_p, &sorts, params->len);

    qv_for_each_pos(iop_sort, pos, params) {
        iop_sort_priv_t *priv = &sorts.tab[pos];
        iop_sort_t *sort = &params->tab[pos];
        iop_type_t type;

        field_path_init(&priv->fp);
        t_qv_init(field_step, &priv->fp.steps, 16);
        RETHROW(t_iop_compile_field_path(st, sort->field_path, &priv->fp,
                                         err));

        if (priv->fp.is_typename) {
            type = IOP_T_STRING;
        } else {
            if (priv->fp.fdesc->type == IOP_T_STRUCT) {
                if (err) {
                    sb_addf(err, "cannot sort on sub-structure field `%*pM'",
                            LSTR_FMT_ARG(sort->field_path));
                }
                return -1;
            }
            if (priv->fp.fdesc->repeat == IOP_R_REPEATED) {
                if (err) {
                    sb_addf(err, "cannot sort on repeated field `%*pM'",
                            LSTR_FMT_ARG(sort->field_path));
                }
                return -1;
            }
            type = priv->fp.fdesc->type;
        }

        if (sort->flags & IOP_SORT_REVERSE) {
            priv->cmp = iop_cmp_rev_funs[type];
        } else {
            priv->cmp = iop_cmp_funs[type];
        }

        priv->flags = sort->flags;
    }

    __qv_sort(vec, is_class ? sizeof(void *) : st->size, len,
        ^int (const void *d1, const void *d2) {
            if (is_class) {
                d1 = *(void **)d1;
                d2 = *(void **)d2;
            }

            qv_for_each_ptr(iop_sort_p, sort, &sorts) {
                int ret = compare_field(d1, d2, sort);

                if (ret) {
                    return ret;
                }
            }
            return 0;
        });

    return 0;
}

int iop_sort_desc(const iop_struct_t *st, void *vec, int len,
                  lstr_t field_path, int flags, sb_t *err)
{
    qv_t(iop_sort) params;
    iop_sort_t param = {
        .field_path = field_path,
        .flags = flags,
    };

    qv_init_static(iop_sort, &params, &param, 1);
    return iop_msort_desc(st, vec, len, &params, err);
}

static int
__iop_filter(const iop_struct_t *st, void *vec, int *len, lstr_t field_path,
             void * const *allowed_values, int values_len,
             opt_bool_t is_set, unsigned flags, sb_t *err)
{
    t_scope;
    bool is_pointer = iop_struct_is_class(st);
    field_path_t fp;
    cmp_f equal;
    byte *vec_read = vec;
    byte *vec_write = vec;
    byte *vec_start = vec;
    size_t elem_size = is_pointer ? sizeof(void *) : st->size;
    iop_type_t type;

    field_path_init(&fp);
    t_qv_init(field_step, &fp.steps, 16);
    RETHROW(t_iop_compile_field_path(st, field_path, &fp, err));

    if (OPT_ISSET(is_set)) {
        if (!fp.is_typename
        &&  fp.fdesc->repeat != IOP_R_OPTIONAL
        &&  fp.fdesc->repeat != IOP_R_REPEATED)
        {
            if (err) {
                sb_addf(err, "field `%*pM' in the structure `%*pM' is "
                        "neither optional nor repeated",
                        LSTR_FMT_ARG(field_path), LSTR_FMT_ARG(st->fullname));
            }
            return -1;
        }
        type = fp.fdesc->type;
    } else
    if (!fp.is_typename) {
        if (fp.fdesc->type == IOP_T_STRUCT) {
            if (err) {
                sb_addf(err, "cannot filter on sub-structure `%*pM'",
                        LSTR_FMT_ARG(field_path));
            }
            return -1;
        }
        if (fp.fdesc->repeat == IOP_R_REPEATED) {
            if (err) {
                sb_addf(err, "cannot filter on repeated field `%*pM'",
                        LSTR_FMT_ARG(field_path));
            }
            return -1;
        }
        type = fp.fdesc->type;
    } else {
        type = IOP_T_STRING;
    }

    if (flags & IOP_FILTER_SQL_LIKE) {
        equal = iop_equal_funs_sql_like[type];
    } else {
        equal = iop_cmp_funs[type];
    }

    for (int i = 0; i < *len; i++) {
        const void *d;
        const void *tmp;

        tmp = is_pointer ? *(void **)vec_read : vec_read;
        d = iop_get_fieldp(tmp, &fp);

        if (OPT_ISSET(is_set)) {
            assert (!values_len);
            if (!!d == OPT_VAL(is_set)) {
                goto next;
            }
            goto filter_out;
        }

        if (d) {
            for (int j = 0; j < values_len; j++) {
                /* TODO: sort allowed_values and use a bisection. */
                if (equal(d, allowed_values[j]) == 0) {
                    goto next;
                }
            }
        }

      filter_out:
        if (vec_start != vec_read && vec_write != vec_read) {
            p_move(vec_write, vec_start, vec_read - vec_start);
        }
        vec_write += vec_read - vec_start;
        vec_start = vec_read + elem_size;

      next:
        vec_read += elem_size;
    }

    if (vec_start != vec_read && vec_write != vec_read) {
        p_move(vec_write, vec_start, vec_read - vec_start);
        vec_write += vec_read - vec_start;
    }
    *len = (vec_write - (byte *)vec) / elem_size;

    return 0;
}

int iop_filter(const iop_struct_t *st, void *vec, int *len, lstr_t field_path,
               void * const *allowed_values, int values_len, unsigned flags,
               sb_t *err)
{
    return __iop_filter(st, vec, len, field_path, allowed_values, values_len,
                        (opt_bool_t)OPT_NONE, flags, err);
}

int iop_filter_opt(const iop_struct_t *st, void *vec, int *len,
                   lstr_t field_path, bool is_set, sb_t *err)
{
    return __iop_filter(st, vec, len, field_path, NULL, 0,
                        (opt_bool_t)OPT(is_set), 0, err);
}

/* }}} */
/* {{{ Hashing values */

#define ATTRS
#define F(x)  x
#include "iop-hashing-values.in.c"
#undef F
#undef ATTRS

/* }}} */
/* {{{ Check constraints before packing */

typedef struct iop_err_t {
    sb_t err;
    sb_t path;
    const iop_struct_t *desc;
} iop_err_t;

static __thread iop_err_t iop_err_g;

__attribute__((constructor))
static void iop_init_err(void)
{
    if (unlikely(iop_err_g.err.size == 0)) {
        p_clear(&iop_err_g, 1);
        sb_init(&iop_err_g.err);
        sb_init(&iop_err_g.path);
    }
}

static void iop_wipe_err(void)
{
    if (iop_err_g.err.size) {
        sb_wipe(&iop_err_g.err);
        sb_wipe(&iop_err_g.path);
        iop_err_g.desc = NULL;
    }
}

thr_hooks(iop_init_err, iop_wipe_err);

void iop_set_verr(const char *fmt, va_list ap)
{
    sb_setvf(&iop_err_g.err, fmt, ap);
}

int iop_set_err(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    iop_set_verr(fmt, ap);
    va_end(ap);
    return -1;
}

int iop_set_err2(const lstr_t *s)
{
    sb_set(&iop_err_g.err, s->s, s->len);
    return -1;
}

void iop_clear_err(void)
{
    sb_reset(&iop_err_g.err);
    sb_reset(&iop_err_g.path);
    iop_err_g.desc = NULL;
}

static void iop_expand_err(void)
{
    if (!iop_err_g.desc) {
        return;
    }
    if (iop_err_g.path.len) {
        sb_prependf(&iop_err_g.err, "in %s of type %s: ",
                    iop_err_g.path.data + 1, iop_err_g.desc->fullname.s);
    } else {
        sb_prependf(&iop_err_g.err, "in type %s: ",
                    iop_err_g.desc->fullname.s);
    }
    iop_err_g.desc = NULL;
}

const char *iop_get_err(void)
{
    if (iop_err_g.err.len) {
        iop_expand_err();
        return iop_err_g.err.data;
    }
    return NULL;
}

lstr_t iop_get_err_lstr(void)
{
    if (iop_err_g.err.len) {
        iop_expand_err();
        return LSTR_INIT_V(iop_err_g.err.data, iop_err_g.err.len);
    }
    return LSTR_NULL_V;
}

static int
__iop_check_constraints_struct(const iop_struct_t *desc, const void *val);
static int
__iop_check_constraints_class(const iop_struct_t *desc, const void *val);

__cold static void sb_prepend_field(sb_t *sb, const iop_field_t *fdesc, int j)
{
    if (fdesc->repeat == IOP_R_REPEATED) {
        sb_prependf(sb, ".%s[%d]", fdesc->name.s, j);
    } else {
        sb_prependf(sb, ".%s", fdesc->name.s);
    }
}

static const char *t_fmt_field(const iop_field_t *fdesc, int j)
{
    if (fdesc->repeat == IOP_R_REPEATED) {
        return t_fmt("%s[%d]", fdesc->name.s, j);
    } else {
        return fdesc->name.s;
    }
}

int iop_field_check_constraints(const iop_struct_t *desc, const iop_field_t
                                *fdesc, const void *ptr, int n, bool recurse)
{
    check_constraints_f check_constraints = NULL;

    if ((check_constraints = iop_field_get_constraints_cb(desc, fdesc))) {
        if (unlikely(check_constraints(ptr, n) < 0)) {
            iop_err_g.desc = desc;
            sb_reset(&iop_err_g.path);
            return -1;
        }
    }
    switch (fdesc->type) {
      case IOP_T_ENUM:
        if (TST_BIT(&fdesc->u1.en_desc->flags, IOP_ENUM_STRICT)) {
            const iop_enum_t *en_desc = fdesc->u1.en_desc;

            for (int j = 0; j < n; j++) {
                int32_t intval = IOP_FIELD(int32_t, ptr, j);

                if (iop_ranges_search(en_desc->ranges,
                                      en_desc->ranges_len, intval) != -1)
                {
                    continue;
                } else {
                    t_scope;

                    iop_err_g.desc = desc;
                    sb_reset(&iop_err_g.path);
                    iop_set_err("%d is not a valid value for enum %*pM"
                                " (field %s)",
                                intval, LSTR_FMT_ARG(en_desc->fullname),
                                t_fmt_field(fdesc, j));
                    return -1;
                }
            }
        }
        break;

      case IOP_T_I8:
      case IOP_T_U8:
      case IOP_T_I16:
      case IOP_T_U16:
      case IOP_T_I32:
      case IOP_T_U32:
      case IOP_T_I64:
      case IOP_T_U64:
      case IOP_T_BOOL:
      case IOP_T_DOUBLE:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        break;

      case IOP_T_UNION:
      case IOP_T_STRUCT:
      default: {
        bool is_class;
        bool is_ref;

        if (!recurse) {
            return 0;
        }

        is_class = iop_field_is_class(fdesc);
        is_ref   = iop_field_is_reference(fdesc);
        for (int j = 0; j < n; j++) {
            int ret;
            const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

            if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                /* Non-optional class fields have to be dereferenced
                 * (dereferencing of optional fields was already done
                 *  by the caller).
                 */
                v = *(void **)v;
            }
            if (is_class) {
                ret = __iop_check_constraints_class(fdesc->u1.st_desc, v);
            } else {
                ret = __iop_check_constraints_struct(fdesc->u1.st_desc, v);
            }
            if (ret < 0) {
                sb_prepend_field(&iop_err_g.path, fdesc, j);
                return -1;
            }
        }
        break;
      }
    }

    return 0;
}

static int
__iop_check_constraints_struct(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    unsigned           desc_flags = desc->flags;

    if (!TST_BIT(&desc_flags, IOP_STRUCT_HAS_CONSTRAINTS))
        return 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0) {
                unsigned fdesc_flags = fdesc->flags;

                if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
                    iop_err_g.desc = desc;
                    sb_reset(&iop_err_g.path);
                    iop_set_err("empty array not allowed for field `%*pM`",
                                LSTR_FMT_ARG(fdesc->name));
                    return -1;
                }
                continue;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field if it's still equal to its default value */
            if (iop_field_is_defval(fdesc, ptr, true))
                continue;
        }

        RETHROW(iop_field_check_constraints(desc, fdesc, ptr, n, true));
    }

    return 0;
}

static int
__iop_check_constraints_class(const iop_struct_t *desc, const void *val)
{
    desc = *(const iop_struct_t **)val;

    if (unlikely(desc->class_attrs->is_abstract)) {
        iop_err_g.desc = desc;
        sb_reset(&iop_err_g.path);
        return iop_set_err("'%*pM' is an abstract class",
                           LSTR_FMT_ARG(desc->fullname));
    }

    do {
        RETHROW(__iop_check_constraints_struct(desc, val));
    } while ((desc = desc->class_attrs->parent));

    return 0;
}

int iop_check_constraints_desc(const iop_struct_t *desc, const void *val)
{
    int ret;

    if (iop_struct_is_class(desc)) {
        ret = __iop_check_constraints_class(desc, val);
    } else {
        ret = __iop_check_constraints_struct(desc, val);
    }
    return ret;
}

/* }}} */
/* {{{ Get value encoding size */

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  const unsigned flags, qv_t(i32) *szs);

static int __iop_bpack_size(const iop_struct_t *desc, const void *val,
                            const unsigned flags, qv_t(i32) *szs)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    int len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (flags & IOP_BPACK_SKIP_PRIVATE) {
            const iop_field_attrs_t *attrs = iop_field_get_attrs(desc, fdesc);

            if (attrs && TST_BIT(&attrs->flags, IOP_FIELD_PRIVATE)) {
                continue;
            }
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0)
                continue;
            if (n > 1) {
                if ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    int32_t i32 = n * fdesc->size;

                    len += 1 + fdesc->tag_len;
                    len += get_len_len(i32) + i32;
                    continue;
                }
                /* Add:
                 * - 4 to encode the len on 32 bits,
                 * - n because there will be n tags 0 to separate elements.
                 */
                len += 4 + n;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field if still equals to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&   iop_field_is_defval(fdesc, ptr, true))
            {
                continue;
            }
        }

        len += 1 + fdesc->tag_len;
        switch (fdesc->type) {
          case IOP_T_I8:
            len += n;
            break;
          case IOP_T_U8:
            len += n;
            for (int j = 0; j < n; j++)
                len += IOP_FIELD(uint8_t, ptr, j) >> 7;
            break;
          case IOP_T_I16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int16_t, ptr, j));
            break;
          case IOP_T_U16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(uint16_t, ptr, j));
            break;
          case IOP_T_I32:
          case IOP_T_ENUM:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int32_t, ptr, j));
            break;
          case IOP_T_U32:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(uint32_t, ptr, j));
            break;
          case IOP_T_I64:
          case IOP_T_U64:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(int64_t, ptr, j));
            break;
          case IOP_T_BOOL:
            len += n;
            break;
          case IOP_T_DOUBLE:
            len += n * 8;
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            for (int j = 0; j < n; j++) {
                int32_t i32 = IOP_FIELD(lstr_t, ptr, j).len;
                len += get_len_len(i32 + 1) + i32 + 1;
            }
            break;

          case IOP_T_UNION:
          case IOP_T_STRUCT:
          default: {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);

            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);
                int32_t offs = szs->len, i32;

                qv_growlen(i32, szs, 1);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    v = *(void **)v;
                }
                if (is_class) {
                    i32 = __iop_bpack_size_class(fdesc->u1.st_desc, v, flags,
                                                 szs);
                } else {
                    i32 = __iop_bpack_size(fdesc->u1.st_desc, v, flags, szs);
                }

                szs->tab[offs] = i32;
                len += get_len_len(i32) + i32;
            }
            break;
          }
        }
    }

    return len;
}

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  const unsigned flags, qv_t(i32) *szs)
{
    int size = 0, level_size;
    bool first = true;

    desc = *(const iop_struct_t **)val;

    e_assert(panic, !desc->class_attrs->is_abstract,
             "packing of abstract class '%*pM' is forbidden",
             LSTR_FMT_ARG(desc->fullname));

    /* If this assert fails, you are exporting private classes through
     * a public interface... this is BAD!
     */
    assert (!desc->class_attrs->is_private
            || !(flags & IOP_BPACK_SKIP_PRIVATE));

    do {
        int szs_pos = szs->len;

        qv_growlen(i32, szs, 1);
        level_size = __iop_bpack_size(desc, val, flags, szs);
        szs->tab[szs_pos] = level_size;
        size += level_size;
        if (first || level_size) {
            /* Add 1 for tag 0, followed by the class id */
            size += 1 + get_vint32_len(desc->class_attrs->class_id);
            first = false;
        }
    } while ((desc = desc->class_attrs->parent));

    return size;
}

int iop_bpack_size_flags(const iop_struct_t *desc, const void *val,
                         const unsigned flags, qv_t(i32) *szs)
{
    if (flags & IOP_BPACK_STRICT) {
        RETHROW(iop_check_constraints_desc(desc, val));
    }

    /* Put the packer flags in first to reuse them when packing */
    qv_append(i32, szs, flags);

    if (iop_struct_is_class(desc)) {
        return __iop_bpack_size_class(desc, val, flags, szs);
    } else {
        return __iop_bpack_size(desc, val, flags, szs);
    }
}

/* }}} */
/* {{{ Packing */

static uint8_t *pack_struct(void *dst, const iop_struct_t *, const void *,
                            const unsigned, const int **);
static uint8_t *pack_class(void *dst, const iop_struct_t *, const void *,
                           const unsigned, const int **);
static uint8_t *pack_union(void *dst, const iop_struct_t *, const void *,
                           const unsigned, const int **);

static uint8_t *
pack_value(uint8_t *dst, const iop_field_t *f, const void *v,
           const unsigned flags, const int **szsp)
{
    uint32_t len;

    switch (f->type) {
      case IOP_T_I8:
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = *(int8_t *)v;
        return dst;
      case IOP_T_U8:
        return pack_int32(dst, f->tag, f->tag_len, *(uint8_t *)v);
      case IOP_T_I16:
        return pack_int32(dst, f->tag, f->tag_len, *(int16_t *)v);
      case IOP_T_U16:
        return pack_int32(dst, f->tag, f->tag_len, *(uint16_t *)v);
      case IOP_T_I32:
      case IOP_T_ENUM:
        return pack_int32(dst, f->tag, f->tag_len, *(int32_t *)v);
      case IOP_T_U32:
        return pack_int64(dst, f->tag, f->tag_len, *(uint32_t *)v);
      case IOP_T_I64:
      case IOP_T_U64:
        return pack_int64(dst, f->tag, f->tag_len, *(int64_t *)v);
      case IOP_T_BOOL:
        /* bool are mapped to 0 or 1 */
        assert (*(uint8_t *)v == 0 || *(uint8_t *)v == 1);
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        /* XXX: cast in uint8_t because casting in bool would have no effect.
         */
        *dst++ = !!*(uint8_t *)v;
        return dst;
      case IOP_T_DOUBLE:
        dst = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(QUAD));
        return put_unaligned_double_le(dst, *(double *)v);
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        len = ((lstr_t *)v)->len;
        dst = pack_len(dst, f->tag, f->tag_len, len + 1);
        dst = mempcpyz(dst, ((lstr_t *)v)->data, len);
        return dst;
      case IOP_T_UNION:
        if (iop_field_is_reference(f)) {
            v = *(void **)v;
        }
        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        return pack_union(dst, f->u1.st_desc, v, flags, szsp);
      case IOP_T_STRUCT:
      default: {
        bool is_class = iop_field_is_class(f);
        bool is_ref   = iop_field_is_reference(f);

        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        if ((is_class || is_ref) && f->repeat != IOP_R_OPTIONAL) {
            /* Non-optional class fields have to be dereferenced
             * (dereferencing of optional fields was done in pack_struct).
             */
            v = *(void **)v;
        }
        if (is_class) {
            return pack_class(dst, f->u1.st_desc, v, flags, szsp);
        } else {
            return pack_struct(dst, f->u1.st_desc, v, flags, szsp);
        }
      }
    }
}

static uint8_t *
pack_value_vec(uint8_t *dst, const iop_field_t *f, const void *v, uint32_t n,
               const unsigned flags, const int **szsp)
{
    const lstr_t *d;
    uint32_t len;
    bool is_class;

    switch (f->type) {
      case IOP_T_I32:
      case IOP_T_ENUM:
        do {
            dst = pack_int32(dst, 0, 0, *(int32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_U32:
        do {
            dst = pack_int64(dst, 0, 0, *(uint32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_I64:
      case IOP_T_U64:
        do {
            dst = pack_int64(dst, 0, 0, *(int64_t *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_DOUBLE:
        do {
            dst = pack_tag(dst, 0, 0, IOP_WIRE_MASK(QUAD));
            dst = put_unaligned_double_le(dst, *(double *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        do {
            d = v;
            len = d->len;
            dst = pack_len(dst, 0, 0, len + 1);
            dst = mempcpyz(dst, d->data, len);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_UNION:
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            dst = pack_union(dst, f->u1.st_desc, v, flags, szsp);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_STRUCT:
        is_class = iop_field_is_class(f);
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            if (is_class) {
                dst = pack_class(dst, f->u1.st_desc, *(void **)v, flags,
                                 szsp);
            } else {
                dst = pack_struct(dst, f->u1.st_desc, v, flags, szsp);
            }
            v = (char *)v + f->size;
        } while (--n > 0);
        return dst;

      default:
        e_panic("should not happen");
    }
}

static uint8_t *
pack_struct(void *dst, const iop_struct_t *desc, const void *v,
            const unsigned flags, const int **szsp)
{
    assert(!desc->is_union); /* We don't want a union here */

    for (int i = 0; i < desc->fields_len; i++) {
        const iop_field_t *f = desc->fields + i;
        const void *ptr = (char *)v + f->data_offs;

        if (flags & IOP_BPACK_SKIP_PRIVATE) {
            const iop_field_attrs_t *attrs = iop_field_get_attrs(desc, f);

            if (attrs && TST_BIT(&attrs->flags, IOP_FIELD_PRIVATE)) {
                continue;
            }
        }

        if (f->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(f, ptr))
                continue;
            if ((1 << f->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (f->repeat == IOP_R_REPEATED) {
            const lstr_t *data = ptr;

            if (data->len == 0)
                continue;
            ptr = data->data;
            if (data->len > 1) {
                if ((1 << f->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    /* When data unit is really small (byte, bool, ) we
                     * prefer to pack them in one big block */
                    uint32_t sz = data->len * f->size;

                    assert (f->size <= 2);
                    dst = pack_len(dst, f->tag, f->tag_len, sz);
                    dst = mempcpy(dst, data->data, sz);
                } else {
                    dst = pack_tag(dst, f->tag, f->tag_len,
                                   IOP_WIRE_MASK(REPEAT));
                    dst = put_unaligned_le32(dst, data->len);
                    dst = pack_value_vec(dst, f, ptr, data->len, flags, szsp);
                }
                continue;
            }
        } else
        if (f->repeat == IOP_R_DEFVAL) {
            /* Skip the field if it's still equal to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&  iop_field_is_defval(f, ptr, true))
            {
                continue;
            }
        }

        dst = pack_value(dst, f, ptr, flags, szsp);
    }
    return dst;
}

static uint8_t *pack_class(void *dst, const iop_struct_t *desc, const void *v,
                           const unsigned flags, const int **szsp)
{
    bool first = true;

    desc = *(const iop_struct_t **)v;

    do {
        int level_size = *(*szsp)++;

        if (first || level_size) {
            /* We write the class id in a tag 0 only if:
             *  - this is the first level, because we always want to write the
             *    real class id of the packed object,
             *  - if there is actually something to pack.
             */
            dst = pack_int32(dst, 0, 0, desc->class_attrs->class_id);
            first = false;
        }
        if (level_size) {
            dst = pack_struct(dst, desc, v, flags, szsp);
        }
    } while ((desc = desc->class_attrs->parent));

    return dst;
}

static uint8_t *
pack_union(void *dst, const iop_struct_t *desc, const void *v,
           const unsigned flags, const int **szsp)
{
    const iop_field_t *f = get_union_field(desc, v);

    return pack_value(dst, f, (char *)v + f->data_offs, flags, szsp);
}

void iop_bpack(void *dst, const iop_struct_t *desc, const void *v,
               const int *szs)
{
    /* Read packing flags from first `szs' value */
    const unsigned flags = *szs++;

    if (desc->is_union) {
        pack_union(dst, desc, v, flags, &szs);
    } else
    if (iop_struct_is_class(desc)) {
        pack_class(dst, desc, v, flags, &szs);
    } else {
        pack_struct(dst, desc, v, flags, &szs);
    }
}

lstr_t mp_iop_bpack_struct_flags(mem_pool_t *mp, const iop_struct_t *st,
                                 const void *v, const unsigned flags)
{
    qv_t(i32) sizes;
    byte *data;
    int len;

    if (!v) {
        return LSTR_NULL_V;
    }
    qv_inita(i32, &sizes, 1024);

    len = iop_bpack_size_flags(st, v, flags, &sizes);
    if (len < 0) {
        qv_wipe(i32, &sizes);
        return LSTR_NULL_V;
    }
    data = mp_new_raw(mp, byte, len + 1);
    data[len] = '\0';

    iop_bpack(data, st, v, sizes.tab);
    qv_wipe(i32, &sizes);
    return mp_lstr_init(mp, data, len);
}

lstr_t t_iop_bpack_struct_flags(const iop_struct_t *st, const void *v,
                                const unsigned flags)
{
    return mp_iop_bpack_struct_flags(t_pool(), st, v, flags);
}

/* }}} */
/* {{{ Unpacking */

static inline int get_uint32(pstream_t *ps, int ilen, uint32_t *u32)
{
    switch (ilen) {
      case 1:
        *u32 = RETHROW(ps_getc(ps));
        return 0;

      case 2: {
        uint16_t u16 = 0;
        RETHROW(ps_get_le16(ps, &u16));
        *u32 = u16;
      } return 0;

      case 4:
        return ps_get_le32(ps, u32);
    }
    e_panic("this should not happen");
}

/*
 * XXX: an iop_range helps doing run-length encoded binary search. We know
 * that IOPs tags are mostly contiguous, hence we encode "full" runs of tags
 * this way:
 *   [ offset0, start_tag0, offset1, ..., offset_n, start_tag_n, offset_end]
 *
 * This means that the offset0-th up to the offset1-th values described by
 * this iop_range take values contiguously from the range:
 *   [ start_tag0 .. start_tag0 + offset1 - offset0 [
 *
 * Of course, offset0 is always equal to 0, and offset_n should be equal to
 * ranges_len.
 *
 * Example: the iop_range for "10 11 12 13 100 101 102" is "0 10 4 100 7"
 *  - positions [0 .. 4[ have values in [10  .. 10 + 4 - 0[
 *  - positions [4 .. 7[ have values in [100 .. 100 + 7 - 4[
 *
 */
int iop_ranges_search(int const * ranges, int ranges_len, int tag)
{
    int l = 0, r = ranges_len;

    while (l < r) {
        int i = (l + r) / 2;
        int offs  = ranges[i * 2];
        int start = ranges[i * 2 + 1];

        if (tag < start) {
            r = i;
            continue;
        }
        if (tag + offs >= start + ranges[i * 2 + 2]) {
            l = i + 1;
            continue;
        }
        return ranges[i * 2] + (tag - start);
    }
    return -1;
}

static int iop_enum_pos_from_val(const iop_enum_t *e, int val)
{
    return iop_ranges_search(e->ranges, e->ranges_len, val);
}

static int iop_enum_pos_from_str(const iop_enum_t *e, const char *s, int len)
{
    if (len < 0) {
        len = strlen(s);
    }
    for (int i = 0; i < e->enum_len; i++) {
        if (len == e->names[i].len && !strncasecmp(e->names[i].s, s, len)) {
            return i;
        }
    }
    return -1;
}

int iop_enum_from_str2_desc(const iop_enum_t *e, const char *s, int len,
                            bool *found)
{
    int pos = iop_enum_pos_from_str(e, s, len);

    if (pos < 0) {
        *found = false;
        return -1;
    }
    *found = true;
    return e->values[pos];
}

int iop_enum_from_str_desc(const iop_enum_t *e, const char *s, int len,
                           int err)
{
    bool found;
    int val = iop_enum_from_str2_desc(e, s, len, &found);

    return (found) ? val : err;
}

int iop_enum_from_lstr_desc(const iop_enum_t *e, const lstr_t s, bool *found)
{
    return iop_enum_from_str2_desc(e, s.s, s.len, found);
}


static int iop_skip_field(pstream_t *ps, iop_wire_type_t wt)
{
    uint32_t u32 = 0;

    switch (wt) {
      case IOP_WIRE_BLK1: PS_CHECK(get_uint32(ps, 1, &u32)); break;
      case IOP_WIRE_BLK2: PS_CHECK(get_uint32(ps, 2, &u32)); break;
      case IOP_WIRE_BLK4: PS_CHECK(get_uint32(ps, 4, &u32)); break;

      case IOP_WIRE_INT1:
      case IOP_WIRE_INT2:
      case IOP_WIRE_INT4:
        u32 = 1 << (wt - IOP_WIRE_INT1);
        break;
      case IOP_WIRE_QUAD:
        u32 = 8;
        break;

      case IOP_WIRE_REPEAT: {
        uint32_t n = 0;

        PS_CHECK(get_uint32(ps, 4, &n));
        PS_WANT(n >= 1);

        while (n--) {
            PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
            wt = IOP_WIRE_FMT(__ps_getc(ps));
            RETHROW(iop_skip_field(ps, wt));
        }
      } break;

      default:
        return -1;
    }

    return ps_skip(ps, u32);
}

static ALWAYS_INLINE
int iop_patch_int(const iop_field_t *fdesc, void *ptr, int64_t i64)
{
#define CHECK_RANGE(_min, _max)  THROW_ERR_IF(i64 < _min || i64 > _max)

    switch (fdesc->type) {
      case IOP_T_I8:
        CHECK_RANGE(INT8_MIN, INT8_MAX);
        *(int8_t *)ptr = i64;
        break;
      case IOP_T_U8:
        CHECK_RANGE(0, UINT8_MAX);
        *(uint8_t *)ptr  = i64;
        break;
      case IOP_T_I16:
        CHECK_RANGE(INT16_MIN, INT16_MAX);
        *(int16_t *)ptr = i64;
        break;
      case IOP_T_U16:
        CHECK_RANGE(0, UINT16_MAX);
        *(uint16_t *)ptr = i64;
        break;
      case IOP_T_ENUM:
      case IOP_T_I32:
        CHECK_RANGE(INT32_MIN, INT32_MAX);
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_U32:
        CHECK_RANGE(0, UINT32_MAX);
        *(uint32_t *)ptr = i64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        *(int64_t *)ptr = i64;
        break;
      case IOP_T_BOOL:
        CHECK_RANGE(0, 1);
        *(bool *)ptr = i64;
        break;
    }

#undef CHECK_RANGE
    return 0;
}

static ALWAYS_INLINE int
__get_tag_wt(pstream_t *ps, uint32_t *tag, iop_wire_type_t *wt)
{
    *wt  = IOP_WIRE_FMT(ps->b[0]);
    *tag = IOP_TAG(__ps_getc(ps));
    if (likely(*tag < IOP_LONG_TAG(1)))
        return 0;
    if (likely(*tag == IOP_LONG_TAG(1)))
        return get_uint32(ps, 1, tag);
    return get_uint32(ps, 2, tag);
}

static ALWAYS_INLINE int
__get_class_id(pstream_t *ps, iop_wire_type_t wt, uint16_t *class_id)
{
    switch (wt) {
      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        *class_id = (int8_t)__ps_getc(ps);
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        *class_id = (int16_t)__ps_get_le16(ps);
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        *class_id = (int16_t)__ps_get_le32(ps);
        return 0;

      default:
        return -1;
    }
}

int iop_skip_absent_field_desc(mem_pool_t *mp, void *value,
                               const iop_struct_t *sdesc,
                               const iop_field_t *fdesc)
{
    void *ptr = (char *)value + fdesc->data_offs;

    switch (fdesc->repeat) {
      case IOP_R_REQUIRED: {
        const iop_struct_t *desc = fdesc->u1.st_desc;
        bool is_class;

        /* For a required field, only structs can be absents, be careful that
         * union must be present */
        PS_WANT(fdesc->type == IOP_T_STRUCT);

        if ((is_class = iop_field_is_class(fdesc))) {
            /* For classes, we consider that the absent object is of the
             * expected type, and not a child.
             * We have to allocate it since it's pointed. */
            PS_WANT(!desc->class_attrs->is_abstract);
            *(void **)ptr = mp_imalloc(mp, desc->size, 8, MEM_RAW);
            ptr = *(void **)ptr;
            *(const iop_struct_t **)ptr = desc;
        } else
        if (iop_field_is_reference(fdesc)) {
            *(void **)ptr = mp_imalloc(mp, desc->size, 8, MEM_RAW);
            ptr = *(void **)ptr;
        }
        do {
            for (int i = 0; i < desc->fields_len; i++) {
                RETHROW(iop_skip_absent_field_desc(mp, ptr, desc,
                                                   desc->fields + i));
            }
        } while (is_class && (desc = desc->class_attrs->parent));
      } return 0;

      case IOP_R_DEFVAL:
        switch (fdesc->type) {
          case IOP_T_I8: case IOP_T_U8:
            *(uint8_t *)ptr  = fdesc->u1.defval_u64;
            break;
          case IOP_T_I16: case IOP_T_U16:
            *(uint16_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_ENUM:
            *(uint32_t *)ptr = fdesc->u0.defval_enum;
            break;
          case IOP_T_I32: case IOP_T_U32:
            *(uint32_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_I64: case IOP_T_U64:
            *(uint64_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_BOOL:
            *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
            break;
          case IOP_T_DOUBLE:
            *(double *)ptr   = fdesc->u1.defval_d;
            break;
          case IOP_T_STRING:
          case IOP_T_XML:
          case IOP_T_DATA:
            *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data,
                                         fdesc->u0.defval_len);
            break;
          default:
            return -1;
        }
        break;

      case IOP_R_REPEATED: {
        unsigned fdesc_flags = fdesc->flags;

        if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
            sb_reset(&iop_err_g.path);
            iop_err_g.desc = sdesc;
            iop_set_err("empty array not allowed for field `%*pM`",
                        LSTR_FMT_ARG(fdesc->name));
            return -1;
        }
        p_clear((lstr_t *)ptr, 1);
      } break;

      case IOP_R_OPTIONAL:
        iop_value_set_absent(fdesc, ptr);
        break;
    }
    return 0;
}

static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, unsigned flags, iop_wire_type_t *class_id_wt);
static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, unsigned flags);
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, unsigned flags);

static int unpack_value(mem_pool_t *mp, iop_wire_type_t wt,
                        const iop_field_t *fdesc, void *v,
                        pstream_t *ps, unsigned flags)
{
    uint32_t u32 = 0;
    pstream_t ps_tmp;

    if (iop_field_is_reference(fdesc)) {
        v = iop_value_set_here(mp, fdesc, v);
    }

    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_WANT(ps_has(ps, u32));
        switch (fdesc->type) {
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            *(lstr_t *)v = LSTR_INIT_V(((flags & IOP_UNPACK_COPY_STRINGS)
                                        ? mp_dup(mp, ps->s, u32)
                                        : ps->p), u32 - 1);
            return __ps_skip(ps, u32);
          case IOP_T_UNION:
            ps_tmp = __ps_get_ps(ps, u32);
            return unpack_union(mp, fdesc->u1.st_desc, v, &ps_tmp, flags);
          case IOP_T_STRUCT:
            ps_tmp = __ps_get_ps(ps, u32);
            if (iop_field_is_class(fdesc)) {
                *(void **)v = NULL;
                return unpack_class(mp, fdesc->u1.st_desc, v, &ps_tmp, flags);
            } else {
                return unpack_struct(mp, fdesc->u1.st_desc, v, &ps_tmp, flags,
                                     NULL);
            }
        }
        return -1;

      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int8_t)__ps_getc(ps));

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int16_t)__ps_get_le16(ps));

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int32_t)__ps_get_le32(ps));

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_WANT(ps_has(ps, 8));
            return iop_patch_int(fdesc, v, __ps_get_le64(ps));
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE)
            return ps_get_double_le(ps, v);
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        return ps_get_le64(ps, v);
      default:
        return -1;
    }
}

/* Returns:
 * * 1 when "change of level" (used for classes) tag was seen; in that case,
 *   the wire type associated to this tag is written in class_id_wt.
 * * 0 otherwise on success.
 * * a negative value on error.
 */
static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, unsigned flags, iop_wire_type_t *class_id_wt)
{
    bool is_class = iop_struct_is_class(desc);
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = desc->fields + desc->fields_len;
    iop_wire_type_t wt = 0;
    uint32_t tag = 1;

    while (!ps_done(ps)) {
        uint32_t n = 1;
        void *v;

        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
        if (tag == 0) {
            /* This is a "change of level" tag in a packed class; check that
             * all the remaining fields at this level are optional. */
            PS_WANT(is_class);
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking class %*pM, got change of level tag",
                          LSTR_FMT_ARG(desc->fullname));
            while (fdesc < end) {
                PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
                fdesc++;
            }
            *class_id_wt = wt;
            return 1;
        }
        if (fdesc >= end) {
            goto end;
        }

        while (unlikely(tag > fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker", "unpacking struct %*pM, "
                          "skipping absent field %*pM (tag %u)",
                          LSTR_FMT_ARG(desc->fullname),
                          LSTR_FMT_ARG(fdesc->name), fdesc->tag);
            PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
            if (++fdesc == end) {
                goto end;
            }
        }
        if (unlikely(tag < fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking struct %*pM, skipping unknown tag %u",
                          LSTR_FMT_ARG(desc->fullname), tag);
            PS_CHECK(iop_skip_field(ps, wt));
            continue;
        }

        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, unpacking field %*pM (tag %u)",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name), tag);

        if (fdesc && flags & IOP_UNPACK_FORBID_PRIVATE) {
            const iop_field_attrs_t *attrs = iop_field_get_attrs(desc, fdesc);

            if (attrs && TST_BIT(&attrs->flags, IOP_FIELD_PRIVATE)) {
                iop_set_err("field `%*pM` of struct `%*pM` is private",
                            LSTR_FMT_ARG(fdesc->name),
                            LSTR_FMT_ARG(desc->fullname));
                return -1;
            }
        }

        if (wt == IOP_WIRE_REPEAT) {
            PS_CHECK(get_uint32(ps, 4, &n));
            PS_WANT(n >= 1);
            PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
            wt = IOP_WIRE_FMT(__ps_getc(ps));
        }

        v = (char *)value + fdesc->data_offs;
        if (fdesc->repeat == IOP_R_REPEATED) {
            lstr_t *data = v;

            if (wt != IOP_WIRE_REPEAT
            &&  ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK))
            {
                /* optimized version of repeated fields are packed in simples
                 * IOP blocks */
                uint32_t len = 0;

                switch (wt) {
                  case IOP_WIRE_BLK1:
                    PS_CHECK(get_uint32(ps, 1, &len));
                    break;
                  case IOP_WIRE_BLK2:
                    PS_CHECK(get_uint32(ps, 2, &len));
                    break;
                  case IOP_WIRE_BLK4:
                    PS_CHECK(get_uint32(ps, 4, &len));
                    break;
                  default:
                    /* Here we expect to have a uniq-value packed as a normal
                     * field (data->len == 1) */
                    goto unpack_array;
                }
                PS_WANT(ps_has(ps, len));

                if (fdesc->size == 1) {
                    data->len = len;
                    data->data = ((flags & IOP_UNPACK_COPY_STRINGS)
                                  ? mp_dup(mp, ps->s, len)
                                  : (void *)ps->p);
                } else {
                    assert (fdesc->size == 2);
                    PS_WANT(len % 2 == 0);
                    data->len  = len / 2;
                    data->data = mp_dup(mp, ps->s, len);
                }

                __ps_skip(ps, len);
                v = data->data;
                n = data->len;
                goto next;
            }

          unpack_array:
            data->len  = n;
            data->data = v = mp_imalloc(mp, n * fdesc->size, 8, MEM_RAW);

            while (n-- > 1) {
                if (unpack_value(mp, wt, fdesc, v, ps, flags) < 0) {
                    sb_prepend_field(&iop_err_g.path, fdesc,
                                     data->len - n - 1);
                    return -1;
                }
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
                v  = (char *)v + fdesc->size;
            }
            if (unpack_value(mp, wt, fdesc, v, ps, flags) < 0) {
                sb_prepend_field(&iop_err_g.path, fdesc, 0);
                return -1;
            }
            v = data->data;
            n = data->len;
        } else {
            while (n-- > 1) {
                PS_CHECK(iop_skip_field(ps, wt));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
            }
            if (fdesc->repeat == IOP_R_OPTIONAL && !iop_field_is_class(fdesc))
            {
                v = iop_value_set_here(mp, fdesc, v);
            }
            if (unpack_value(mp, wt, fdesc, v, ps, flags) < 0) {
                sb_prepend_field(&iop_err_g.path, fdesc, 0);
                return -1;
            }
            n = 1;
        }

      next:
        if (unlikely(iop_field_has_constraints(desc, fdesc))) {
            RETHROW(iop_field_check_constraints(desc, fdesc, v, n, false));
        }
        fdesc++;
    }

  end:
    /* consume tags that no longer exists */
    while (!ps_done(ps)
    &&     (desc->fields_len == 0
        ||  tag > desc->fields[desc->fields_len - 1].tag))
    {
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, skipping unknown tag %u",
                      LSTR_FMT_ARG(desc->fullname), tag);
        PS_CHECK(iop_skip_field(ps, wt));
        if (ps_done(ps)) {
            break;
        }
        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
        if (tag == 0) {
            PS_WANT(is_class);
            *class_id_wt = wt;
            break;
        }
    }

    /* consume fields that are not set */
    for (; fdesc < end; fdesc++) {
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, skipping %*pM field",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name));
        PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
    }

    /* return 1 if change of level tag has been found */
    return (tag == 0) ? 1 : 0;
}

static inline int
unpack_skip_all_fields(mem_pool_t *mp, const iop_struct_t *desc, void *value)
{
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = fdesc + desc->fields_len;

    for ( ; fdesc < end; fdesc++) {
        PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
    }
    return 0;
}

static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, unsigned flags)
{
    const iop_struct_t *real_desc;
    iop_wire_type_t wt;
    uint32_t tag;
    uint16_t child_id = 0;

    PS_WANT(!ps_done(ps));

    /* Get the class id of the packed class instance */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    PS_WANT(tag == 0);
    PS_CHECK(__get_class_id(ps, wt, &child_id));

    if (unlikely(!(real_desc = iop_get_class_by_id(desc, child_id)))) {
        e_trace(0, "cannot find child %d of class '%*pM'; missing "
                "IOP_REGISTER_PACKAGES?",
                child_id, LSTR_FMT_ARG(desc->fullname));
        return -1;
    }

    if (real_desc != desc) {
        /* We are trying to unpack a class of type "desc", and the packed
         * class is of type "real_desc". Check that this is authorized. */
        PS_WANT(iop_class_is_a(real_desc, desc));

        e_named_trace(5, "iop/c/unpacker",
                      "unpacking a class of type %*pM, real type %*pM",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(real_desc->fullname));
    }

    if (flags & IOP_UNPACK_FORBID_PRIVATE
    &&  real_desc->class_attrs->is_private)
    {
        iop_set_err("class `%*pM` is private",
                    LSTR_FMT_ARG(real_desc->fullname));
        return -1;
    }

    PS_WANT(!real_desc->class_attrs->is_abstract);
    *value = mp_irealloc(mp, *value, 0, real_desc->size, 8, MEM_RAW);

    /* Set the _vprt pointer */
    *(const iop_struct_t **)(*value) = real_desc;

    /* Unpack the several levels */
    for (;;) {
        uint16_t class_id = 0;
        int res;

        PS_CHECK((res = unpack_struct(mp, real_desc, *value, ps, flags, &wt)));

        if (!(real_desc = real_desc->class_attrs->parent)) {
            return 0;
        }

        if (res != 1) {
            /* "Change of level" tag was not seen yet */
            if (ps_done(ps)) {
                /* Such a tag won't be there because pstream is finished. This
                 * is possible if all the remaining levels have only optional
                 * fields. */
                do {
                    PS_CHECK(unpack_skip_all_fields(mp, real_desc, *value));
                } while ((real_desc = real_desc->class_attrs->parent));
                return 0;
            }
            /* Read it */
            PS_CHECK(__get_tag_wt(ps, &tag, &wt));
            PS_WANT(tag == 0);
        }

        /* Get the next class id, and run the tree up to it; the skipped
         * classes must have only optional fields. */
        PS_CHECK(__get_class_id(ps, wt, &class_id));
        while (class_id != real_desc->class_attrs->class_id) {
            PS_CHECK(unpack_skip_all_fields(mp, real_desc, *value));
            PS_WANT((real_desc = real_desc->class_attrs->parent));
        }
    }
}

/* note: returns 0 on success, -1 on error and 1 if the pstream hasn't been
 * fully consumed. */
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, unsigned flags)
{
    const iop_field_t *fdesc = desc->fields;

    iop_wire_type_t wt;
    uint32_t tag;
    int ifield;

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Write the selected field */
    *((uint16_t *)value) = fdesc->tag;
    value = (char *)value + fdesc->data_offs;

    e_named_trace(5, "iop/c/unpacker", "unpacking union %*pM field %*pM",
                  LSTR_FMT_ARG(desc->fullname), LSTR_FMT_ARG(fdesc->name));
    if (unpack_value(mp, wt, fdesc, value, ps, flags) < 0) {
        sb_prepend_field(&iop_err_g.path, fdesc, 0);
        return -1;
    }
    if (unlikely(iop_field_has_constraints(desc, fdesc))) {
        RETHROW(iop_field_check_constraints(desc, fdesc, value, 1, false));
    }
    return ps_done(ps) ? 0 : 1;
}

int iop_bunpack_flags(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                      pstream_t ps, unsigned flags)
{
    assert (!iop_struct_is_class(desc));
    assert (mp && mp->mem_pool & MEM_BY_FRAME);
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    iop_clear_err();
    if (desc->is_union) {
        return unpack_union(mp, desc, value, &ps, flags) ? -1 : 0;
    }
    return unpack_struct(mp, desc, value, &ps, flags, NULL) < 0 ? -1 : 0;
}

int iop_bunpack_ptr_flags(mem_pool_t *mp, const iop_struct_t *desc,
                          void **value, pstream_t ps, unsigned flags)
{
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    iop_clear_err();

    if (!iop_struct_is_class(desc)) {
        *value = mp_irealloc(mp, *value, 0, desc->size, 8, MEM_RAW);
        return iop_bunpack_flags(mp, desc, *value, ps, flags);
    }
    assert (mp && mp->mem_pool & MEM_BY_FRAME);

    return unpack_class(mp, desc, value, &ps, flags);
}

/* XXX: this function can unpack only union because the struct can't be
 * delimited in a stream.
 * */
int iop_bunpack_multi_flags(mem_pool_t *mp, const iop_struct_t *desc,
                            void *value, pstream_t *ps, unsigned flags)
{
    pstream_t ps_save = *ps;

    assert(desc->is_union);

    e_named_trace(5, "iop/c/unpacker", "unpacking IOP union(s) %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    iop_clear_err();
    if (unpack_union(mp, desc, value, ps, flags) < 0) {
        *ps = ps_save;
        return -1;
    }

    return 0;
}

/* XXX this function doesn't check the IOP content and trust what it reads
 * XXX: this function can unpack only union because the struct can't be
 * delimited in a stream. */
int iop_bskip(const iop_struct_t *desc, pstream_t *ps)
{
    const iop_field_t *fdesc = desc->fields;
    iop_wire_type_t wt;
    uint32_t tag, u32 = 0;
    int ifield;

    assert(desc->is_union);

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Skip union data */
    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_CHECK(ps_skip(ps, u32)); /* Skip block */
        return 0;

      case IOP_WIRE_INT1:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 1));
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 2));
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 4));
        return 0;

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_CHECK(ps_skip(ps, 8));
            return 0;
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE) {
            PS_CHECK(ps_skip(ps, sizeof(double)));
            return 0;
        }
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        PS_CHECK(ps_skip(ps, 8));
        return 0;
      default:
        return -1;
    }
}

ssize_t iop_get_field_len(pstream_t ps)
{
    iop_wire_type_t wt;
    uint32_t tag, u32, tag_len, len_len;

    if (ps_done(&ps))
        return 0;
    wt  = IOP_WIRE_FMT(ps.b[0]);
    tag = IOP_TAG(ps.b[0]);
    if (likely(tag < IOP_LONG_TAG(1))) {
        tag_len = 1;
    } else {
        tag_len = 2 + tag - IOP_LONG_TAG(1);
    }
    switch (wt) {
      case IOP_WIRE_BLK1:
        len_len = 1;
        break;
      case IOP_WIRE_BLK2:
        len_len = 2;
        break;
      case IOP_WIRE_BLK4:
        len_len = 4;
        break;
      case IOP_WIRE_REPEAT: /* not supported by this function */
        return -1;
      case IOP_WIRE_INT1:
        return tag_len + 1;
      case IOP_WIRE_INT2:
        return tag_len + 2;
      case IOP_WIRE_INT4:
        return tag_len + 4;
      case IOP_WIRE_QUAD:
        return tag_len + 8;
      default:
        return -1;
    }
    if (ps_skip(&ps, tag_len) < 0)
        return 0;
    u32 = 0;
    if (get_uint32(&ps, len_len, &u32) < 0)
        return 0;
    return tag_len + len_len + u32;
}

/* }}} */
/* {{{ Introspection */

const iop_iface_t *iop_mod_find_iface(const iop_mod_t *mod, uint32_t tag)
{
    size_t l = 0, r = mod->ifaces_len;

    while (l < r) {
        size_t  i = (l + r) / 2;
        const iop_iface_alias_t *alias = &mod->ifaces[i];

        if (tag == alias->tag) {
            return alias->iface;
        }
        if (tag < alias->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_iface_find_rpc(const iop_iface_t *iface, uint32_t tag)
{
    size_t l = 0, r = iface->funs_len;

    while (l < r) {
        size_t i = (l + r) / 2;
        const iop_rpc_t *rpc = &iface->funs[i];

        if (tag == rpc->tag) {
            return rpc;
        }
        if (tag < rpc->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_mod_find_rpc(const iop_mod_t *mod, uint32_t cmd)
{
    const iop_iface_t *iface = RETHROW_P(iop_mod_find_iface(mod, cmd >> 16));
    return iop_iface_find_rpc(iface, cmd & 0xffff);
}

const iop_field_t *
_iop_class_get_next_field(const iop_struct_t **st, int *it)
{
    while (*st && *it >= (*st)->fields_len) {
        *st = (*st)->class_attrs->parent;
        *it = 0;
    }

    return *st ? (*st)->fields + (*it)++ : NULL;
}

/* }}} */
/* {{{ Introspection - iop_for_each_field() */

/* XXX Intermediary function because the block rewriter don't dig included C
 *     files. */
static int call_field_cb(const iop_struct_t *st_desc, void *st_ptr,
                         const iop_field_t *fdesc, iop_for_each_field_cb_b cb)
{
    return cb(st_desc, fdesc, st_ptr);
}

#define F_NAME    iop_for_each_field
#define F_PROTO   iop_for_each_field_cb_b cb
#define F_ARGS    cb
#define F(x)      x##_blk
#define ON_FIELD  call_field_cb
#include "iop-for-each.in.c"

static int call_field_const_cb(const iop_struct_t *st_desc,
                               const void *st_ptr, const iop_field_t *fdesc,
                               iop_for_each_field_const_cb_b cb)
{
    return cb(st_desc, fdesc, st_ptr);
}

#define F_NAME    iop_for_each_field_const
#define F_PROTO   iop_for_each_field_const_cb_b cb
#define F_ARGS    cb
#define F(x)      x##_blk_const
#define MODIFIER  const
#define ON_FIELD  call_field_const_cb
#include "iop-for-each.in.c"

static int call_st_cb(const iop_struct_t *st_desc, void *st_ptr,
                      iop_for_each_st_cb_b cb)
{
    return cb(st_desc, st_ptr);
}

#define F_NAME     iop_for_each_st
#define F_PROTO    iop_for_each_st_cb_b cb
#define F_ARGS     cb
#define F(x)       x##_st_blk
#define ON_STRUCT  call_st_cb
#include "iop-for-each.in.c"

static int call_st_const_cb(const iop_struct_t *st_desc, void *st_ptr,
                            iop_for_each_st_const_cb_b cb)
{
    return cb(st_desc, st_ptr);
}

#define F_NAME     iop_for_each_st_const
#define F_PROTO    iop_for_each_st_const_cb_b cb
#define F_ARGS     cb
#define F(x)       x##_st_const_blk
#define MODIFIER   const
#define ON_STRUCT  call_st_const_cb
#include "iop-for-each.in.c"

/* }}} */
/* {{{ Signature */

#define ATTRS
#define F(x)  x
#include "iop-signature.in.c"
#undef F
#undef ATTRS

lstr_t t_iop_compute_signature(const iop_struct_t *st, const void *v,
                               unsigned flags)
{
    return t_iop_sign_salt_sha256(st, v, rand32(), flags);
}

/* }}} */
/* {{{ IOP context */

static void iop_env_copy(iop_env_t *dst, iop_env_t *src)
{
    iop_env_init(dst);

    qm_for_each_pos(class_id, pos, &src->classes_by_id) {
        qm_add(class_id, &dst->classes_by_id, &src->classes_by_id.keys[pos],
               src->classes_by_id.values[pos]);
    }
    qm_for_each_pos(class_name, pos, &src->classes_by_name) {
        qm_add(class_name, &dst->classes_by_name, &src->classes_by_name.keys[pos],
               src->classes_by_name.values[pos]);
    }
    qm_for_each_pos(iop_dsos, pos, &src->dsos_by_pkg) {
        qm_add(iop_dsos, &dst->dsos_by_pkg, src->dsos_by_pkg.keys[pos],
               src->dsos_by_pkg.values[pos]);
    }

#define COPY_OBJS(_qm)                                                       \
    do {                                                                     \
        qm_for_each_pos(iop_objs, pos, &src->_qm) {                          \
            qv_t(cvoid) vec;                                                 \
            lstr_t pkg_name = lstr_dup(src->_qm.keys[pos]);                  \
                                                                             \
            qv_init(cvoid, &vec);                                            \
            qv_copy(cvoid, &vec, &src->_qm.values[pos]);                     \
            qm_add(iop_objs, &dst->_qm, &pkg_name, vec);                     \
        }                                                                    \
    } while (0)

    COPY_OBJS(pkgs_by_name);
    COPY_OBJS(enums_by_fullname);
#undef COPY_OBJS
}

void iop_env_set(iop_env_t *env)
{
    iop_env_wipe(&_G.env);
    _G.env = *env;
}

void iop_env_get(iop_env_t *env)
{
    iop_env_copy(env, &_G.env);
}

iop_env_t *iop_env_init(iop_env_t *env)
{
    qm_init(class_id,   &env->classes_by_id);
    qm_init(class_name, &env->classes_by_name);
    qm_init(iop_dsos,   &env->dsos_by_pkg);
    qm_init(iop_objs,   &env->pkgs_by_name);
    qm_init(iop_objs,   &env->enums_by_fullname);
    return env;
}

void iop_env_wipe(iop_env_t *env)
{
    qm_wipe(class_id,      &env->classes_by_id);
    qm_wipe(class_name,    &env->classes_by_name);
    qm_wipe(iop_dsos,      &env->dsos_by_pkg);
    qm_deep_wipe(iop_objs, &env->pkgs_by_name,      lstr_wipe, qv_cvoid_wipe);
    qm_deep_wipe(iop_objs, &env->enums_by_fullname, lstr_wipe, qv_cvoid_wipe);
}

/* }}} */
/* {{{ Class manipulation */

iop_value_t const *
iop_get_class_cvar_desc(const iop_struct_t *desc, lstr_t name)
{
    iop_static_field_t _search = { .name = name };
    iop_static_field_t *search = &_search;

    const iop_class_attrs_t *cls = desc->class_attrs;
    bool found;
    int pos;
    cmp_b cmp = ^int (const void *a, const void *b) {
        const iop_static_field_t **v1 = (const iop_static_field_t **)a;
        const iop_static_field_t **v2 = (const iop_static_field_t **)b;

        return lstr_cmp((*v1)->name, (*v2)->name);
    };

    assert (iop_struct_is_class(desc));

    pos = bisect_blk(&search, cls->static_fields,
                     sizeof(iop_static_field_t *),
                     cls->static_fields_len, &found, cmp);
    if (found) {
        const iop_static_field_t *f;

        f = desc->class_attrs->static_fields[pos];
        return &f->value;
    }
    return NULL;
}

const iop_value_t *iop_get_class_cvar(const void *obj, lstr_t name)
{
    return iop_get_class_cvar_desc(*(iop_struct_t **)obj, name);
}

const iop_value_t *iop_get_cvar_desc(const iop_struct_t *desc, lstr_t name)
{
    assert (iop_struct_is_class(desc));

    do {
        const iop_class_attrs_t *cls = desc->class_attrs;
        const iop_value_t *v;

        if ((v = iop_get_class_cvar_desc(desc, name))) {
            return v;
        }
        desc = cls->parent;
    } while (desc);

    return NULL;
}

const iop_value_t *iop_get_cvar(const void *obj, lstr_t name)
{
    return iop_get_cvar_desc(*(iop_struct_t **)obj, name);
}

bool iop_class_is_a(const iop_struct_t *cls1, const iop_struct_t *cls2)
{
    if (!iop_struct_is_class(cls1) || !iop_struct_is_class(cls2)) {
        assert (false);
        return false;
    }

    do {
        if (cls1 == cls2) {
            return true;
        }
    } while ((cls1 = cls1->class_attrs->parent));

    return false;
}

const iop_struct_t *
iop_get_class_by_fullname(const iop_struct_t *st, lstr_t fullname)
{
    class_name_key_t key = {
        .master = st,
        .child_fullname = &fullname,
    };

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    return qm_get_def_safe(class_name, &_G.env.classes_by_name, &key, NULL);
}

const iop_struct_t *
iop_get_class_by_id(const iop_struct_t *st, uint16_t class_id)
{
    class_id_key_t key = {
        .master   = st,
        .child_id = class_id,
    };

    if (st->class_attrs->class_id == class_id) {
        return st;
    }

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    return qm_get_def_safe(class_id, &_G.env.classes_by_id, &key, NULL);
}

void iop_for_each_registered_classes(iop_for_each_class_b cb)
{
    qm_for_each_pos(class_id, pos, &_G.env.classes_by_id) {
        cb(_G.env.classes_by_id.values[pos]);
    }
}

/* }}} */
/* {{{ Snmp manipulation */

int iop_struct_get_nb_snmp_indexes(const iop_struct_t *st)
{
    int nb = 0;

    for (int i = 0; i < st->fields_len; i++) {
        if (iop_field_is_snmp_index(&st->fields[i])) {
            nb++;
        }
    }
    return nb;
}

int iop_struct_get_nb_snmp_smiv2_indexes(const iop_struct_t *st)
{
    int nb = 0;

    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *field =&st->fields[i];

        if (iop_field_is_snmp_index(field)) {
            if (field->type == IOP_T_STRING) {
                /* there is at most 128 sub-identifiers
                 * (see RFC 2578, section 3.5). */
                return 128;
            } else {
                nb++;
            }
        }
    }

    return MIN(nb, 128);
}

const iop_snmp_attrs_t *iop_get_snmp_attrs(const iop_field_attrs_t *attrs)
{
    for (int i = 0; i < attrs->attrs_len; i++) {
        if (attrs->attrs[i].type == IOP_FIELD_SNMP_INFO) {
            return (iop_snmp_attrs_t*)attrs->attrs[i].args->v.p;
        }
    }
    e_panic("all snmpObj fields should have snmp attribute");
}

const iop_snmp_attrs_t *iop_get_snmp_attr_match_oid(const iop_struct_t *st,
                                                    int oid)
{
    assert (iop_struct_is_snmp_st(st));

    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *field = &st->fields[i];

        if (field->tag == oid) {
            return iop_get_snmp_attrs(&st->fields_attrs[i]);
        }
    }
    e_panic("no field matches wanted OID");
}

const iop_field_attrs_t *iop_get_field_attr_match_oid(const iop_struct_t *st,
                                                      int tag)
{
    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *field = &st->fields[i];

        if (field->tag == tag) {
            return &st->fields_attrs[i];
        }
    }
    e_panic("no field matches wanted OID");
}

/* }}} */
/* {{{ Packages registration / manipulation */

static int iop_register_class(const iop_struct_t *desc, iop_env_t *env,
                              sb_t *err)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };
    uint32_t pos;

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    /* Register in classes_by_id hash table */
    pos = qm_put(class_id, &env->classes_by_id, &key, desc, 0);
    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;
        if (env->classes_by_id.values[pos] != desc) {
            sb_setf(err,
                    "conflicting class id %d: used by both '%*pM' and '%*pM'",
                    desc->class_attrs->class_id, LSTR_FMT_ARG(desc->fullname),
                    LSTR_FMT_ARG(env->classes_by_id.values[pos]->fullname));
            return -1;
        }
    } else {
        class_name_key_t key2 = {
            .master         = key.master,
            .child_fullname = &desc->fullname,
        };

        e_named_trace(5, "iop/package_registration", "registering class "
                      "'%*pM' (%p) as a child of '%*pM' (%p)",
                      LSTR_FMT_ARG(desc->fullname), desc,
                      LSTR_FMT_ARG(key.master->fullname), key.master);

        /* Register in classes_by_name hash table */
        if (qm_add(class_name, &env->classes_by_name, &key2, desc) < 0) {
            sb_setf(err,
                    "conflicting class name '%*pM' as a child of '%*pM'",
                    LSTR_FMT_ARG(desc->fullname),
                    LSTR_FMT_ARG(key.master->fullname));
            return -1;
        }
    }
    return 0;
}

static int
iop_class_check_parents_are_registered(const iop_struct_t *st,
                                       const iop_struct_t *master,
                                       const iop_env_t *env,
                                       qh_t(cptr) *registered,
                                       sb_t *err)
{
    uint32_t pos;
    const iop_struct_t *child = st;

    pos = qh_put(cptr, registered, st, 0);
    if (pos & QHASH_COLLISION) {
        return 0;
    }

    while ((st = st->class_attrs->parent)) {
        class_id_key_t key = {
            .master   = master,
            .child_id = st->class_attrs->class_id,
        };

        pos = qh_put(cptr, registered, st, 0);
        if (pos & QHASH_COLLISION) {
            return 0;
        }

        if (qm_find_safe(class_id, &env->classes_by_id, &key) < 0) {
            sb_setf(err, "class `%*pM` is not registered while its child "
                    "class `%*pM` is", LSTR_FMT_ARG(st->fullname),
                    LSTR_FMT_ARG(child->fullname));
            return -1;
        }
    }

    return 0;
}

int iop_check_registered_classes(const iop_env_t *env, sb_t *err)
{
    /* Check all the parent classes of the registered classes are also
     * registered. */
    t_scope;
    qh_t(cptr) registered;

    t_qh_init(cptr, &registered, qm_len(class_id, &env->classes_by_id));

    qm_for_each_pos(class_id, pos, &env->classes_by_id) {
        const iop_struct_t *st     = env->classes_by_id.values[pos];
        const iop_struct_t *master = env->classes_by_id.keys[pos].master;

        RETHROW(iop_class_check_parents_are_registered(st, master, env,
                                                       &registered, err));
    }

    return 0;
}

static int
iop_register_obj_by_name(qm_t(iop_objs) *qm, const void *obj, lstr_t name,
                         unsigned flags)
{
    qv_t(cvoid) *obj_vec;
    uint32_t pos;

    pos = qm_reserve(iop_objs, qm, &name, 0);
    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;
    } else {
        qm->keys[pos] = lstr_dup(name);
        qv_init(cvoid, &qm->values[pos]);
    }
    obj_vec = &qm->values[pos];
    qv_for_each_entry(cvoid, _obj, obj_vec) {
        if (_obj == obj) {
            return 0;
        }
    }
    if (obj_vec->len && !(flags & IOP_REGPKG_FROM_DSO)) {
        return -1;
    }
    qv_append(cvoid, obj_vec, obj);
    return 1;
}

int iop_register_packages_env(const iop_pkg_t **pkgs, int len, iop_dso_t *dso,
                              iop_env_t *env, unsigned flags, sb_t *err)
{
    if (dso) {
        assert (flags & IOP_REGPKG_FROM_DSO);
    } else {
        assert (!(flags & IOP_REGPKG_FROM_DSO));
    }

    /* Register the packages. */
    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];
        int ret;

        /* Register the package itself. */
        ret = iop_register_obj_by_name(&env->pkgs_by_name, pkg, pkg->name,
                                       flags);
        if (ret < 0) {
            sb_setf(err, "a package named '%*pM' was already registered",
                    LSTR_FMT_ARG(pkg->name));
            return -1;
        }
        if (ret == 0) {
            continue;
        }
        if (dso) {
            qm_add(iop_dsos, &env->dsos_by_pkg, pkg, dso);
        }

        /* Register its classes. */
        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            if (iop_struct_is_class(desc)) {
                RETHROW(iop_register_class(desc, env, err));
            }
        }

        /* Register its enums. */
        for (const iop_enum_t *const *it = pkg->enums; *it; it++) {
            const iop_enum_t *desc = *it;

            if (iop_register_obj_by_name(&env->enums_by_fullname, desc,
                                         desc->fullname, flags) < 0)
            {
                sb_setf(err,
                        "an enumeration named '%*pM' was already registered",
                        LSTR_FMT_ARG(desc->name));
                return -1;
            }
        }
    }

    return 0;
}

void iop_register_packages(const iop_pkg_t **pkgs, int len, unsigned flags)
{
    SB_1k(err);

    if (iop_register_packages_env(pkgs, len, NULL, &_G.env, flags, &err) < 0)
    {
        e_panic("%*pM", SB_FMT_ARG(&err));
    }
}

static const void *iop_get_obj(const qm_t(iop_objs) *qm, lstr_t name)
{
    int32_t pos = qm_find_safe(iop_objs, qm, &name);
    qv_t(cvoid) *vec;

    THROW_NULL_IF(pos < 0);
    vec = &qm->values[pos];
    return vec->len ? vec->tab[0] : NULL;
}

const iop_pkg_t *iop_get_pkg_env(lstr_t pkgname, const iop_env_t *env)
{
    return iop_get_obj(&env->pkgs_by_name, pkgname);
}

const iop_pkg_t *iop_get_pkg(lstr_t pkgname)
{
    return iop_get_pkg_env(pkgname, &_G.env);
}

const iop_enum_t *iop_get_enum(lstr_t fullname)
{
    return iop_get_obj(&_G.env.enums_by_fullname, fullname);
}

iop_dso_t *iop_dso_get_from_pkg(const iop_pkg_t *pkg)
{
    return qm_get_def_safe(iop_dsos, &_G.env.dsos_by_pkg, pkg, NULL);
}

static void iop_unregister_class(const iop_struct_t *desc)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    if (qm_del_key(class_id, &_G.env.classes_by_id, &key) >= 0) {
        class_name_key_t key2 = {
            .master         = key.master,
            .child_fullname = &desc->fullname,
        };

        qm_del_key(class_name, &_G.env.classes_by_name, &key2);
    }
}

static int
iop_unregister_obj(qm_t(iop_objs) *qm, const void *obj, lstr_t name)
{
    int32_t pos = RETHROW(qm_find(iop_objs, qm, &name));
    qv_t(cvoid) *vec = &qm->values[pos];
    bool found = false;

    qv_for_each_pos(cvoid, pos2, vec) {
        const void *obj2 = vec->tab[pos2];

        if (obj2 == obj) {
            qv_remove(cvoid, vec, pos2);
            found = true;
            break;
        }
    }

    if (!vec->len) {
        qv_wipe(cvoid, vec);
        lstr_wipe(&qm->keys[pos]);
        qm_del_at(iop_objs, qm, pos);
    }

    return found ? 0 : -1;
}

void iop_unregister_packages(const iop_pkg_t **pkgs, int len)
{
    SB_1k(err);

    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];

        /* Unregister the package itself. */
        if (iop_unregister_obj(&_G.env.pkgs_by_name, pkg, pkg->name) < 0) {
            continue;
        }
        qm_del_key(iop_dsos, &_G.env.dsos_by_pkg, pkg);

        /* Unregister its classes. */
        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            if (iop_struct_is_class(desc)) {
                iop_unregister_class(desc);
            }
        }

        /* Unregister its enums. */
        for (const iop_enum_t *const *it = pkg->enums; *it; it++) {
            const iop_enum_t *desc = *it;

            iop_unregister_obj(&_G.env.enums_by_fullname, desc,
                               desc->fullname);
        }
    }

    if (iop_check_registered_classes(&_G.env, &err) < 0) {
        e_panic("%*pM", SB_FMT_ARG(&err));
    }
}

void iop_for_each_registered_pkgs(iop_for_each_pkg_b cb)
{
    qm_for_each_pos(iop_objs, pos, &_G.env.pkgs_by_name) {
        qv_for_each_entry(cvoid, pkg, &_G.env.pkgs_by_name.values[pos]) {
            cb(pkg);
        }
    }
}

/* }}} */
/* {{{ Struct printf formatter %*pS */

static int iop_file_write(void *file, const void *buf, int len)
{
    if (fwrite(buf, 1, len, file) != (size_t)len) {
        return -1;
    }
    return len;
}

typedef struct iop_formatter_t {
    char  *buf;
    size_t buf_len;
} iop_formatter_t;

static int iop_formatter_write(void *out, const void *buf, int len)
{
    iop_formatter_t *f = out;
    int to_copy = MIN((size_t)len, f->buf_len);

    if (to_copy) {
        memcpy(f->buf, buf, to_copy);
        f->buf += to_copy;
        f->buf_len -= to_copy;
    }
    return len;
}

static ssize_t
iop_struct_format(const iop_struct_t *st, const void *val, size_t flags,
                  FILE *stream, char *buf, size_t buf_len)
{
    if (!st) {
        /* The struct is an IOP class. */
        st = *(const iop_struct_t **)val;
    }

    if (stream) {
        return iop_jpack(st, val, &iop_file_write, stream, flags);
    } else {
        iop_formatter_t f = {
            .buf = buf,
            .buf_len = buf_len,
        };

        return iop_jpack(st, val, &iop_formatter_write, &f, flags);
    }
}

static ssize_t
iop_struct_formatter(int modifier, const void *_sv, size_t flags,
                     FILE *stream, char *buf, size_t buf_len)
{
    const struct iop_struct_value *sv = _sv;

    return iop_struct_format(sv->st, sv->val, flags, stream, buf, buf_len);
}

/* }}} */
/* {{{ Enum printf formatter %*pE */

static ssize_t
iop_enum_formatter(int modifier, const void *_ev, size_t flags,
                   FILE *stream, char *buf, size_t buf_len)
{
    const struct iop_enum_value *ev = _ev;
    lstr_t s = iop_enum_to_str_desc(ev->desc, ev->v);

    if (flags & IOP_ENUM_FMT_FULL) {
        if (!s.s) {
            return formatter_writef(stream, buf, buf_len, "<unknown>(%d)",
                                    ev->v);
        }

        return formatter_writef(stream, buf, buf_len, "%*pM(%d)",
                                LSTR_FMT_ARG(s), ev->v);
    }

    if (!s.s) {
        return formatter_writef(stream, buf, buf_len, "%d", ev->v);
    }

    return formatter_write(stream, buf, buf_len, s.s, s.len);
}

/* }}} */
/* {{{ Union type formatter */

static ssize_t
iop_union_type_formatter(int modifier, const void *_desc, size_t iop_tag,
                         FILE *stream, char *buf, size_t buf_len)
{
    const iop_struct_t *desc = _desc;
    lstr_t type_s;
    int pos;

    pos = iop_ranges_search(desc->ranges, desc->ranges_len, iop_tag);
    if (unlikely(pos < 0)) {
        return formatter_writef(stream, buf, buf_len, "<unknown>(%zd)",
                                iop_tag);
    }

    type_s = desc->fields[pos].name;

    return formatter_write(stream, buf, buf_len, type_s.s, type_s.len);
}

/* }}} */
/* {{{ Backward compatibility checks */

typedef struct iop_compat_couple_t {
    const void *st1;
    const void *st2;
    unsigned flags;
    unsigned padding;
} iop_compat_couple_t;

static uint32_t qhash_hash_compat_couple(const qhash_t *qh,
                                         const iop_compat_couple_t *ptr)
{
    return mem_hash32(ptr, sizeof(*ptr));
}
static bool qhash_compat_couple_equal(const qhash_t *qh,
                                      const iop_compat_couple_t *ptr1,
                                      const iop_compat_couple_t *ptr2)
{
    return memcmp(ptr1, ptr2, sizeof(*ptr1)) == 0;
}

qh_kvec_t(compat_couple, iop_compat_couple_t,
          qhash_hash_compat_couple, qhash_compat_couple_equal);

struct iop_compat_ctx_t {
    qh_t(compat_couple) seen_couples;
    qh_t(cptr)          seen_opt_st;
    sb_t *err;
    sb_t err_ctx;
    qv_t(i32) err_ctx_offs;
    int indent_lvl;
};

static iop_compat_ctx_t *iop_compat_ctx_init(iop_compat_ctx_t *ctx)
{
    p_clear(ctx, 1);
    qh_init(compat_couple, &ctx->seen_couples);
    qh_init(cptr, &ctx->seen_opt_st);
    sb_init(&ctx->err_ctx);
    qv_init(i32, &ctx->err_ctx_offs);
    return ctx;
}
static void iop_compat_ctx_wipe(iop_compat_ctx_t *ctx)
{
    qh_wipe(compat_couple, &ctx->seen_couples);
    qh_wipe(cptr, &ctx->seen_opt_st);
    sb_wipe(&ctx->err_ctx);
    qv_wipe(i32, &ctx->err_ctx_offs);
}
DO_NEW(iop_compat_ctx_t, iop_compat_ctx);
DO_DELETE(iop_compat_ctx_t, iop_compat_ctx);

static void iop_compat_make_indent(sb_t *sb, int indent_lvl)
{
    for (int i = 0; i < indent_lvl; i++) {
        sb_adds(sb, "  | ");
    }
}

__attr_printf__(2, 3)
static void
iop_compat_push_err_ctx(iop_compat_ctx_t *ctx, const char *fmt, ...)
{
    va_list ap;

    qv_append(i32, &ctx->err_ctx_offs, ctx->err_ctx.len);

    iop_compat_make_indent(&ctx->err_ctx, ctx->indent_lvl);
    va_start(ap, fmt);
    sb_addvf(&ctx->err_ctx, fmt, ap);
    va_end(ap);
    sb_addc(&ctx->err_ctx, '\n');

    ctx->indent_lvl++;
}

static void iop_compat_pop_err_ctx(iop_compat_ctx_t *ctx)
{
    ctx->indent_lvl--;
    assert (ctx->indent_lvl >= 0);
    if (ctx->err_ctx_offs.len > 0) {
        sb_clip(&ctx->err_ctx, *qv_last(i32, &ctx->err_ctx_offs));
        qv_remove_last(i32, &ctx->err_ctx_offs);
    }
}

__attr_printf__(2, 3)
static void iop_compat_add_err(iop_compat_ctx_t *ctx, const char *fmt, ...)
{
    va_list ap;

    if (ctx->err->len > 0) {
        sb_addc(ctx->err, '\n');
    }

    sb_addsb(ctx->err, &ctx->err_ctx);
    sb_reset(&ctx->err_ctx);
    qv_clear(i32, &ctx->err_ctx_offs);

    iop_compat_make_indent(ctx->err, ctx->indent_lvl);

    va_start(ap, fmt);
    sb_addvf(ctx->err, fmt, ap);
    va_end(ap);
}

static int
__iop_struct_check_backward_compat(const iop_struct_t *st1,
                                   const iop_struct_t *st2,
                                   unsigned flags, iop_compat_ctx_t *ctx);

/* Add compat couple into the hash table. A special handler is needed as flags
 * must be added individually. Flags that need to be checked are returned. */
static unsigned
iop_compat_mark_couple(const void *st1, const void *st2,
                       unsigned flags, iop_compat_ctx_t *ctx)
{
    iop_compat_couple_t couple = {
        .st1   = st1,
        .st2   = st2,
    };
    unsigned chk_flags = flags;

    for (unsigned i = 0; flags && i < bitsizeof(flags); i++) {
        if (!TST_BIT(&flags, i)) {
            continue;
        }

        couple.flags = 1 << i;
        if (qh_add(compat_couple, &ctx->seen_couples, &couple) < 0) {
            /* Couple already checked with this flag. */
            RST_BIT(&chk_flags, i);
        }
        RST_BIT(&flags, i);
    }

    return chk_flags;
}

static int
__iop_enum_check_backward_compat(const iop_enum_t *en1,
                                 const iop_enum_t *en2,
                                 unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test en1 == en2 because it allows to easily write
     *      "compatible" z-tests. */

    if (!(flags = iop_compat_mark_couple(en1, en2, flags, ctx))) {
        /* No checks to be done. */
        return 0;
    }

    if (!TST_BIT(&en1->flags, IOP_ENUM_STRICT)
    &&   TST_BIT(&en2->flags, IOP_ENUM_STRICT))
    {
        iop_compat_add_err(ctx, "enum is strict and was not before");
        res = -1;
    }

    for (int i = 0; i < en1->enum_len; i++) {
        int pos2_bin  = -1;
        int pos2_json = -1;

        if (flags & IOP_COMPAT_BIN) {
            pos2_bin = iop_ranges_search(en2->ranges, en2->ranges_len,
                                         en1->values[i]);
            if (pos2_bin < 0) {
                iop_compat_add_err(ctx,
                                   "numeric value %d does not exist anymore",
                                   en1->values[i]);
                res = -1;
            }
        }

        if (flags & IOP_COMPAT_JSON) {
            pos2_json = iop_enum_pos_from_str(en2, en1->names[i].s,
                                              en1->names[i].len);
            if (pos2_json < 0) {
                iop_compat_add_err(ctx, "value `%*pM` does not exist anymore",
                                   LSTR_FMT_ARG(en1->names[i]));
                res = -1;
            }
        }

        if (pos2_bin >= 0 && pos2_json >= 0 && pos2_bin != pos2_json) {
            iop_compat_add_err(ctx, "value `%*pM` (%d): name and value "
                               "lookups mismatch: `%*pM` (%d) != `%*pM` (%d)",
                               LSTR_FMT_ARG(en1->names[i]), en1->values[i],
                               LSTR_FMT_ARG(en2->names[pos2_json]),
                               en2->values[pos2_json],
                               LSTR_FMT_ARG(en2->names[pos2_bin]),
                               en2->values[pos2_bin]);
            res = -1;
        }
    }

    return res;
}

static void
backward_compat_build_tables(uint16_t table_bin[IOP_T_max + 1],
                             uint16_t table_json[IOP_T_max + 1],
                             uint16_t table_bin_r[IOP_T_max + 1])
{
    STATIC_ASSERT (IOP_T_max <= bitsizeof(uint16_t));

    /* Build authorized binary types transition table. */
    table_bin[IOP_T_UNION]  = 1U << IOP_T_UNION;
    table_bin[IOP_T_STRUCT] = 1U << IOP_T_STRUCT;
    table_bin[IOP_T_DOUBLE] = 1U << IOP_T_DOUBLE;
    table_bin[IOP_T_U64]    = 1U << IOP_T_U64;
    table_bin[IOP_T_I64]    = 1U << IOP_T_I64;

    table_bin[IOP_T_U32] = 1U << IOP_T_U32 | 1U << IOP_T_U64
                         | 1U << IOP_T_I64;
    table_bin[IOP_T_I32] = 1U << IOP_T_I32 | 1U << IOP_T_U64
                         | 1U << IOP_T_I64;

    table_bin[IOP_T_U16] = 1U << IOP_T_U16
                         | table_bin[IOP_T_U32] | table_bin[IOP_T_I32];
    table_bin[IOP_T_I16] = 1U << IOP_T_I16
                         | table_bin[IOP_T_U32] | table_bin[IOP_T_I32];

    table_bin[IOP_T_U8] = 1U << IOP_T_U8
                        | table_bin[IOP_T_U16] | table_bin[IOP_T_I16];
    table_bin[IOP_T_I8] = 1U << IOP_T_I8
                        | table_bin[IOP_T_U16] | table_bin[IOP_T_I16];

    table_bin[IOP_T_BOOL] = 1U << IOP_T_BOOL
                          | table_bin[IOP_T_U8] | table_bin[IOP_T_I8];

    table_bin[IOP_T_STRING] = 1U << IOP_T_STRING | 1U << IOP_T_DATA
                            | 1U << IOP_T_XML;
    table_bin[IOP_T_DATA]   = table_bin[IOP_T_STRING];
    table_bin[IOP_T_XML]    = table_bin[IOP_T_STRING];

    table_bin[IOP_T_ENUM]   = 1U << IOP_T_ENUM | table_bin[IOP_T_I32];

    /* Build authorized json types transition table. */
    p_copy(table_json, table_bin, IOP_T_max + 1);
    table_json[IOP_T_ENUM]   = 1U << IOP_T_ENUM;
    table_json[IOP_T_STRING] = 1U << IOP_T_STRING;
    table_json[IOP_T_DATA]   = 1U << IOP_T_DATA;
    table_json[IOP_T_XML]    = 1U << IOP_T_XML;

    /* build repeated table for binary format due to special array packing
     * (cf : IOP_REPEATED_OPTIMIZE_OK) */
    p_copy(table_bin_r, table_bin, IOP_T_max + 1);
    table_bin_r[IOP_T_U16]  = TO_BIT(U16);
    table_bin_r[IOP_T_I16]  = TO_BIT(I16);
    table_bin_r[IOP_T_U8]   = TO_BIT(U8);
    table_bin_r[IOP_T_I8]   = TO_BIT(I8);
    table_bin_r[IOP_T_BOOL] = TO_BIT(U8) | TO_BIT(I8) | TO_BIT(BOOL);

    /* Check that no type was forgotten. */
    for (int i = 0; i < IOP_T_max; i++) {
        assert (table_bin[i]  != 0);
        assert (table_json[i] != 0);
        assert (table_bin_r[i] != 0);
    }
}

static bool
iop_struct_is_optional(const iop_struct_t *st, bool forbid_abstract,
                       iop_compat_ctx_t *ctx);

static int
iop_field_check_backward_compat(const iop_field_t *f1,
                                const iop_field_t *f2,
                                unsigned flags, iop_compat_ctx_t *ctx)
{
    static int first_call = true;
    static uint16_t table_bin[IOP_T_max + 1];
    static uint16_t table_json[IOP_T_max + 1];
    static uint16_t table_bin_r[IOP_T_max + 1];

    if (unlikely(first_call)) {
        first_call = false;
        backward_compat_build_tables(table_bin, table_json, table_bin_r);
    }

    /* Check type transition. */
    if (f1->repeat == IOP_R_REPEATED && f2->repeat == IOP_R_REPEATED) {
        if ((flags & IOP_COMPAT_BIN
             && !TST_BIT(&table_bin_r[f1->type], f2->type))
        ||  (flags & IOP_COMPAT_JSON
             && !TST_BIT(&table_json[f1->type], f2->type)))
        {
            iop_compat_add_err(ctx, "incompatible types");
            return -1;
        }
    } else {
        if ((flags & IOP_COMPAT_BIN
             && !TST_BIT(&table_bin[f1->type], f2->type))
        ||  (flags & IOP_COMPAT_JSON
             && !TST_BIT(&table_json[f1->type], f2->type)))
        {
            iop_compat_add_err(ctx, "incompatible types");
            return -1;
        }
    }

    /* Check repeated -> non-repeated: always forbidden.
     * (non-repeated -> repeated is always supported) */
    if (f1->repeat == IOP_R_REPEATED && f2->repeat != IOP_R_REPEATED) {
        iop_compat_add_err(ctx, "was repeated and is not anymore");
        return -1;
    }

    /* Check non-required -> required:
     * forbidden iff it isn't an optional struct. */
    if ((f1->repeat == IOP_R_DEFVAL || f1->repeat == IOP_R_OPTIONAL)
    &&  f2->repeat == IOP_R_REQUIRED
    &&  (f2->type != IOP_T_STRUCT
         || !iop_struct_is_optional(f2->u1.st_desc, true, ctx)))
    {
        iop_compat_add_err(ctx, "is required and was not before");
        return -1;
    }

    /* Check backward compat of complex types. */
    switch (f2->type) {
      case IOP_T_UNION:
      case IOP_T_STRUCT:
        assert (f1->type == f2->type);
        return __iop_struct_check_backward_compat(f1->u1.st_desc,
                                                  f2->u1.st_desc,
                                                  flags, ctx);

      case IOP_T_ENUM:
        assert (f1->type == f2->type);
        if (!f1->u1.en_desc || !f2->u1.en_desc) {
            /* This happens for SNMP traps using an enumeration... */
            return 0;
        }
        return __iop_enum_check_backward_compat(f1->u1.en_desc,
                                                f2->u1.en_desc,
                                                flags, ctx);
    }

    return 0;
}

static const iop_struct_t *
get_parents_until_id(const iop_struct_t *st, const uint16_t *class_id,
                     qv_t(iop_struct) *vec)
{
    while ((st = st->class_attrs->parent)) {
        if (class_id && st->class_attrs->class_id == *class_id) {
            break;
        }
        qv_append(iop_struct, vec, st);
    }

    return st;
}

static const iop_struct_t *
get_parents_until_name(const iop_struct_t *st, const lstr_t *name,
                       qv_t(iop_struct) *vec)
{
    while ((st = st->class_attrs->parent)) {
        if (name && lstr_equal(st->fullname, *name)) {
            break;
        }
        qv_append(iop_struct, vec, st);
    }

    return st;
}

static bool are_all_parents_empty(const iop_struct_t *st)
{
    while ((st = st->class_attrs->parent)) {
        if (st->fields_len) {
            return false;
        }
    }

    return true;
}

/* Check that none of the classes added as parents contain a required
 * field. */
static int
check_parent_required_fields(const qv_t(iop_struct) *parents,
                             iop_compat_ctx_t *ctx)
{
    qv_for_each_entry(iop_struct, parent, parents) {
        for (int i = 0; i < parent->fields_len; i++) {
            const iop_field_t *f = &parent->fields[i];

            if (f->repeat == IOP_R_REQUIRED
            &&  (f->type != IOP_T_STRUCT
              || !iop_struct_is_optional(f->u1.st_desc, true, ctx)))
            {
                iop_compat_add_err(ctx, "class `%*pM` was added in the "
                                   "parents with a required field `%*pM`",
                                   LSTR_FMT_ARG(parent->fullname),
                                   LSTR_FMT_ARG(f->name));
                return -1;
            }
        }
    }
    return 0;
}

static int
check_class_parent(const iop_struct_t *st1,
                    const iop_struct_t *parent,
                    unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    iop_compat_push_err_ctx(ctx, "parent `%*pM`:",
                            LSTR_FMT_ARG(parent->fullname));
    res = __iop_struct_check_backward_compat(st1->class_attrs->parent,
                                             parent, flags, ctx);
    iop_compat_pop_err_ctx(ctx);

    return res;
}

static int
check_parent_classes(const iop_struct_t *st1, const iop_struct_t *st2,
                    unsigned flags, iop_compat_ctx_t *ctx)
{
    const iop_struct_t *st2_parent_bin = NULL;
    const iop_struct_t *st2_parent_json = NULL;
    qv_t(iop_struct) parents;
    int res = 0;

    if (!st1->class_attrs->parent && !st2->class_attrs->parent) {
        return 0;
    }

    qv_init(iop_struct, &parents);

    /* Get the classes added in the parents between 'st2' and 'st1'. */
    if (flags & IOP_COMPAT_BIN) {
        const uint16_t *class_id = NULL;

        if (st1->class_attrs->parent) {
            class_id = &st1->class_attrs->parent->class_attrs->class_id;
        }
        st2_parent_bin = get_parents_until_id(st2, class_id, &parents);
        if (class_id && !st2_parent_bin) {
            iop_compat_add_err(ctx, "cannot find class with id %d in the "
                               "parents of `%*pM`",
                               *class_id, LSTR_FMT_ARG(st2->fullname));
            res = -1;
        }

        if (res >= 0 && check_parent_required_fields(&parents, ctx) < 0) {
            res = -1;
        }

        qv_clear(iop_struct, &parents);
    }

    if (flags & IOP_COMPAT_JSON) {
        const lstr_t *class_name = NULL;

        if (st1->class_attrs->parent) {
            class_name = &st1->class_attrs->parent->fullname;
        }
        st2_parent_json = get_parents_until_name(st2, class_name, &parents);
        if (class_name && !st2_parent_json
        &&  (!are_all_parents_empty(st1) || !are_all_parents_empty(st2)))
        {
            iop_compat_add_err(ctx, "cannot find class `%*pM` in the parents "
                               "of `%*pM`", LSTR_FMT_ARG(*class_name),
                               LSTR_FMT_ARG(st2->fullname));
            res = -1;
        }

        if (res >= 0 && check_parent_required_fields(&parents, ctx) < 0) {
            res = -1;
        }
    }

    /* Check upper level. */
    if ((st2_parent_bin || st2_parent_json)
    &&  st1->class_attrs->parent)
    {
        if (st2_parent_bin == st2_parent_json) {
            if (check_class_parent(st1, st2_parent_bin, flags, ctx) < 0) {
                res = -1;
            }
        } else {
            if (st2_parent_bin
            &&  check_class_parent(st1, st2_parent_bin,
                                   IOP_COMPAT_BIN, ctx) < 0)
            {
                res = -1;
            }

            if (st2_parent_json
            &&  check_class_parent(st1, st2_parent_json,
                                   IOP_COMPAT_JSON, ctx) < 0)
            {
                res = -1;
            }
        }
    }

    qv_wipe(iop_struct, &parents);
    return res;
}

static bool
iop_struct_is_optional(const iop_struct_t *st, bool forbid_abstract,
                       iop_compat_ctx_t *ctx)
{
    if (forbid_abstract && iop_struct_is_class(st)
    &&  st->class_attrs->is_abstract)
    {
        return false;
    }

    if (qh_find(cptr, &ctx->seen_opt_st, st) >= 0) {
        return true;
    }

    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *f = &st->fields[i];

        if (f->repeat != IOP_R_REQUIRED) {
            continue;
        }
        if (f->type != IOP_T_STRUCT
        ||  !iop_struct_is_optional(f->u1.st_desc, true, ctx))
        {
            return false;
        }
    }

    if (iop_struct_is_class(st) && st->class_attrs->parent
    &&  !iop_struct_is_optional(st->class_attrs->parent, false, ctx))
    {
        return false;
    }

    qh_add(cptr, &ctx->seen_opt_st, st);
    return true;
}

static int
__backward_compat_check_new_field(const iop_struct_t *st1,
                                  const iop_field_t *f1,
                                  const iop_field_t *f2,
                                  unsigned flags, iop_compat_ctx_t *ctx)
{
    if (f1) {
        int res = 0;
        SB(name_fmt, 128);

        if (!lstr_equal(f1->name, f2->name)) {
            sb_addf(&name_fmt, "`%*pM` -> `%*pM`", LSTR_FMT_ARG(f1->name),
                    LSTR_FMT_ARG(f2->name));
        } else
        if (f1->tag != f2->tag) {
            sb_addf(&name_fmt, "`%*pM` %hu -> %hu", LSTR_FMT_ARG(f2->name),
                    f1->tag, f2->tag);
        } else {
            sb_addf(&name_fmt, "`%*pM`", LSTR_FMT_ARG(f2->name));
        }

        iop_compat_push_err_ctx(ctx, "field %*pM:", SB_FMT_ARG(&name_fmt));

        if (iop_field_check_backward_compat(f1, f2, flags, ctx) < 0) {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
        return res;
    }

    if (st1->is_union || f2->repeat != IOP_R_REQUIRED) {
        return 0;
    }

    if (f2->type == IOP_T_STRUCT
    &&  iop_struct_is_optional(f2->u1.st_desc, true, ctx))
    {
        return 0;
    }

    iop_compat_add_err(ctx, "new field `%*pM` must not be required",
                       LSTR_FMT_ARG(f2->name));

    return -1;
}

static unsigned
iop_generic_compat_ignored(unsigned flags,
                           int (^get_gen_attr)(lstr_t, iop_value_t *))
{
    iop_value_t val;

    if (get_gen_attr(LSTR("compat:ignore"), &val) >= 0 && val.b) {
        return 0;
    }
    if (get_gen_attr(LSTR("compat:ignoreJson"), &val) >= 0 && val.b) {
        flags &= ~IOP_COMPAT_JSON;
    }
    if (get_gen_attr(LSTR("compat:ignoreBin"), &val) >= 0 && val.b) {
        flags &= ~IOP_COMPAT_BIN;
    }

    return flags;
}

static unsigned
iop_struct_compat_ignored(const iop_struct_t *new_st, unsigned flags)
{
    return iop_generic_compat_ignored(flags,
                                      ^int (lstr_t attr, iop_value_t *val) {
        return iop_struct_get_gen_attr(new_st, attr, IOP_T_BOOL, NULL, val);
    });
}

static unsigned iop_rpc_compat_ignored(const iop_iface_t *iface,
                                       const iop_rpc_t *rpc, unsigned flags)
{
    return iop_generic_compat_ignored(flags,
                                      ^int (lstr_t attr, iop_value_t *val) {
        return iop_rpc_get_gen_attr(iface, rpc, attr, IOP_T_BOOL, NULL, val);
    });
}

static unsigned
iop_iface_compat_ignored(const iop_iface_t *iface, unsigned flags)
{
    return iop_generic_compat_ignored(flags,
                                      ^int (lstr_t attr, iop_value_t *val) {
        return iop_iface_get_gen_attr(iface, attr, IOP_T_BOOL, NULL, val);
    });
}

static int
__iop_struct_check_backward_compat(const iop_struct_t *st1,
                                   const iop_struct_t *st2,
                                   unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test st1 == st2 because it allows to easily write
     *      "compatible" z-tests. */

    if (!(flags = iop_compat_mark_couple(st1, st2, flags, ctx))) {
        /* No checks to be done. */
        return 0;
    }

    /* Check types of the objects. */
    if (st1->is_union && !st2->is_union) {
        iop_compat_add_err(ctx, "was a union and is now a %s",
                           iop_struct_is_class(st2) ? "class" : "struct");
        return -1;
    }
    if (!st1->is_union && st2->is_union) {
        iop_compat_add_err(ctx, "was a %s and is now a union",
                           iop_struct_is_class(st1) ? "class" : "struct");
        return -1;
    }

    if (iop_struct_is_class(st1) && !iop_struct_is_class(st2)) {
        iop_compat_add_err(ctx, "was a class and is now a struct");
        res = -1;
    }
    if (!iop_struct_is_class(st1) && iop_struct_is_class(st2)) {
        if (!(flags & IOP_COMPAT_JSON) || st2->class_attrs->is_abstract) {
            iop_compat_add_err(ctx, "was a struct and is now a class");
            res = -1;
        }
    }

    if (iop_struct_is_class(st1) && iop_struct_is_class(st2)) {
        if (!st1->class_attrs->is_abstract && st2->class_attrs->is_abstract) {
            iop_compat_add_err(ctx,
                               "is an abstract class but was not abstract");
            res = -1;
        }
        if (flags & IOP_COMPAT_BIN
        &&  st1->class_attrs->class_id != st2->class_attrs->class_id)
        {
            iop_compat_add_err(ctx, "class id changed (%u != %u)",
                               st1->class_attrs->class_id,
                               st2->class_attrs->class_id);
            res = -1;
        }
        if (flags & IOP_COMPAT_JSON
        &&  !lstr_equal(st1->fullname, st2->fullname))
        {
            iop_compat_add_err(ctx,
                               "class fullname changed (`%*pM` != `%*pM`)",
                               LSTR_FMT_ARG(st1->fullname),
                               LSTR_FMT_ARG(st2->fullname));
            res = -1;
        }
    }

    /* Check fields of st2. */
    for (int i = 0; i < st2->fields_len; i++) {
        const iop_field_t *f2 = &st2->fields[i];
        const iop_field_t *f1_name;
        const iop_field_t *f1_tag = NULL;
        bool got_err = false;
        int pos;

        f1_name = __iop_field_find_by_name(st1, f2->name);
        pos = iop_ranges_search(st1->ranges, st1->ranges_len, f2->tag);
        if (pos >= 0) {
            f1_tag = &st1->fields[pos];
        }

#define CHECK_NEW_FIELD(f1, flags)                                           \
        do {                                                                 \
            if (__backward_compat_check_new_field(st1, f1, f2, flags,        \
                                                  ctx) < 0)                  \
            {                                                                \
                got_err = true;                                              \
                res = -1;                                                    \
            }                                                                \
        } while (0)

        if (flags == IOP_COMPAT_JSON) {
            CHECK_NEW_FIELD(f1_name, IOP_COMPAT_JSON);
        } else
        if (flags == IOP_COMPAT_BIN) {
            CHECK_NEW_FIELD(f1_tag, IOP_COMPAT_BIN);
        } else {
            assert (flags == IOP_COMPAT_ALL);
            if (f1_name && f1_tag) {
                if (f1_name == f1_tag) {
                    CHECK_NEW_FIELD(f1_name, IOP_COMPAT_ALL);
                } else {
                    iop_compat_add_err(ctx,
                        "field `%*pM` (%d): name and tag lookups mismatch: "
                        "`%*pM` (%d) != `%*pM` (%d)",
                        LSTR_FMT_ARG(f2->name), f2->tag,
                        LSTR_FMT_ARG(f1_name->name), f1_name->tag,
                        LSTR_FMT_ARG(f1_tag->name), f1_tag->tag);
                    res = -1;
                }
            } else {
                CHECK_NEW_FIELD(f1_name, IOP_COMPAT_JSON);
                if (!got_err) {
                    CHECK_NEW_FIELD(f1_tag, IOP_COMPAT_BIN);
                }
            }
        }
    }
#undef CHECK_NEW_FIELD

    /* Check that no field disappeared for json backward compat and union
     * case. */
    if (st1->is_union || flags & IOP_COMPAT_JSON) {
        for (int i = 0; i < st1->fields_len; i++) {
            const iop_field_t *f1 = &st1->fields[i];

            if (flags & IOP_COMPAT_JSON
            &&  !__iop_field_find_by_name(st2, f1->name))
            {
                iop_compat_add_err(ctx,
                                   "field `%*pM` does not exist anymore",
                                   LSTR_FMT_ARG(f1->name));
                res = -1;
            } else
            if (flags & IOP_COMPAT_BIN
            &&  iop_ranges_search(st2->ranges, st2->ranges_len, f1->tag) < 0)
            {
                iop_compat_add_err(ctx, "field with tag %d (`%*pM`) does "
                                   "not exist anymore", f1->tag,
                                   LSTR_FMT_ARG(f1->name));
                res = -1;
            }
        }
    }

    /* Specific class checks. */
    if (iop_struct_is_class(st1) && iop_struct_is_class(st2)
    &&  check_parent_classes(st1, st2, flags, ctx) < 0)
    {
            res = -1;
    }

    return res;
}

int iop_struct_check_backward_compat(const iop_struct_t *st1,
                                     const iop_struct_t *st2,
                                     unsigned flags, sb_t *err)
{
    int res;
    iop_compat_ctx_t ctx;

    assert (flags & IOP_COMPAT_BIN || flags & IOP_COMPAT_JSON);

    flags = iop_struct_compat_ignored(st2, flags);
    if (!flags) {
        return 0;
    }

    iop_compat_ctx_init(&ctx);
    ctx.err = err;

    res = __iop_struct_check_backward_compat(st1, st2, flags, &ctx);

    iop_compat_ctx_wipe(&ctx);
    return res;
}

static int
__iop_rpc_check_backward_compat(const iop_rpc_t *rpc1,
                                const iop_rpc_t *rpc2,
                                unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

#define CHECK_RPC(_what)  \
    do {                                                                     \
        iop_compat_push_err_ctx(ctx, "RPC `%*pM` " TOSTR(_what) ":",         \
                                LSTR_FMT_ARG(rpc1->name));                   \
        if (__iop_struct_check_backward_compat(rpc1->_what, rpc2->_what,     \
                                               flags, ctx) < 0)              \
        {                                                                    \
            res = -1;                                                        \
        }                                                                    \
        iop_compat_pop_err_ctx(ctx);                                         \
    } while (0)

    CHECK_RPC(args);

    if (rpc1->async && !rpc2->async) {
        iop_compat_add_err(ctx, "RPC `%*pM` was async and is not anymore",
                           LSTR_FMT_ARG(rpc1->name));
        return -1;
    }
    if (!rpc1->async && rpc2->async) {
        iop_compat_add_err(ctx, "RPC `%*pM` is async but was not before",
                           LSTR_FMT_ARG(rpc1->name));
        return -1;
    }

    CHECK_RPC(result);
    CHECK_RPC(exn);
#undef CHECK_RPC

    return res;
}

static const iop_rpc_t *
__iop_iface_get_rpc_by_name(const iop_iface_t *iface, lstr_t name)
{
    for (int i = 0; i < iface->funs_len; i++) {
        if (lstr_equal(iface->funs[i].name, name)) {
            return &iface->funs[i];
        }
    }

    return NULL;
}

static int
__iop_iface_check_backward_compat(const iop_iface_t *if1,
                                  const iop_iface_t *if2,
                                  unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test if1 == if2 because it allows to easily write
     *      "compatible" z-tests. */

    for (int i = 0; i < if1->funs_len; i++) {
        const iop_rpc_t *fun1 = &if1->funs[i];
        const iop_rpc_t *fun2;

        if (flags & IOP_COMPAT_JSON) {
            if ((fun2 = __iop_iface_get_rpc_by_name(if2, fun1->name))) {
                unsigned rpc_flags;

                if ((rpc_flags = iop_rpc_compat_ignored(if2, fun2, flags))
                &&  __iop_rpc_check_backward_compat(fun1, fun2,
                                                    rpc_flags, ctx) < 0)
                {
                    res = -1;
                    continue;
                }
            } else {
                iop_compat_add_err(ctx, "RPC `%*pM` does not exist anymore",
                                   LSTR_FMT_ARG(fun1->name));
                res = -1;
                continue;
            }
        }

        if (flags & IOP_COMPAT_BIN) {
            if ((fun2 = iop_iface_find_rpc(if2, fun1->tag))) {
                unsigned rpc_flags;

                if ((rpc_flags = iop_rpc_compat_ignored(if2, fun2, flags))
                &&  __iop_rpc_check_backward_compat(fun1, fun2,
                                                    rpc_flags, ctx) < 0)
                {
                    res = -1;
                }
            } else {
                iop_compat_add_err(ctx, "RPC with tag %d (`%*pM`) does not "
                                   "exist anymore",
                                   fun1->tag, LSTR_FMT_ARG(fun1->name));
                res = -1;
            }
        }
    }

    return res;
}

static const iop_iface_alias_t *
__iop_mod_get_iface_by_name(const iop_mod_t *mod, lstr_t name)
{
    for (int i = 0; i < mod->ifaces_len; i++) {
        if (lstr_equal(mod->ifaces[i].name, name)) {
            return &mod->ifaces[i];
        }
    }

    return NULL;
}

static int
__iop_mod_check_backward_compat(const iop_mod_t *mod1,
                                const iop_mod_t *mod2,
                                unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test mod1 == mod2 because it allows to easily write
     *      "compatible" z-tests. */

    /* We just perform naive tests here (we check that the interfaces are not
     * renamed or re-tagged without checking their compatibility). The
     * interfaces themselves are tested before anyway.
     */
    for (int i = 0; i < mod1->ifaces_len; i++) {
        const iop_iface_alias_t *if1 = &mod1->ifaces[i];

        if (flags & IOP_COMPAT_JSON) {
            if (!__iop_mod_get_iface_by_name(mod2, if1->name)) {
                iop_compat_add_err(ctx, "interface `%*pM` does not exist "
                                   "anymore", LSTR_FMT_ARG(if1->name));
                res = -1;
            }
        }

        if (flags & IOP_COMPAT_BIN) {
            if (!iop_mod_find_iface(mod2, if1->tag)) {
                iop_compat_add_err(ctx, "interface with tag %d (`%*pM`) does "
                                   "not exist anymore",
                                   if1->tag, LSTR_FMT_ARG(if1->name));
                res = -1;
            }
        }
    }

    return res;
}

static lstr_t iop_get_name_from_fullname(lstr_t fullname)
{
    pstream_t ps = ps_initlstr(&fullname);
    pstream_t elem;

    while (ps_get_ps_chr_and_skip(&ps, '.', &elem) >= 0);

    return LSTR_PS_V(&ps);
}

#define BUILD_GET_BY_NAME(_fun, _type, _vec)                                 \
static const _type *_fun(const iop_pkg_t *pkg, lstr_t name)                  \
{                                                                            \
    for (const _type *const *it = pkg->_vec; *it; it++) {                    \
        const _type *obj = *it;                                              \
                                                                             \
        if (lstr_equal(iop_get_name_from_fullname(obj->fullname), name)) {   \
            return obj;                                                      \
        }                                                                    \
    }                                                                        \
    return NULL;                                                             \
}

BUILD_GET_BY_NAME(iop_pkg_get_struct_by_name, iop_struct_t, structs)
BUILD_GET_BY_NAME(iop_pkg_get_iface_by_name,  iop_iface_t,  ifaces)
BUILD_GET_BY_NAME(iop_pkg_get_mod_by_name,    iop_mod_t,    mods)

#undef BUILD_GET_BY_NAME

int iop_pkg_check_backward_compat_ctx(const iop_pkg_t *pkg1,
                                      const iop_pkg_t *pkg2,
                                      iop_compat_ctx_t *ctx,
                                      unsigned flags, sb_t *err)
{
    int res = 0;

    assert (flags & IOP_COMPAT_BIN || flags & IOP_COMPAT_JSON);

    ctx->err = err;

    iop_compat_push_err_ctx(ctx, "pkg `%*pM`:", LSTR_FMT_ARG(pkg2->name));

    /* Check structs. */
    for (const iop_struct_t *const *it = pkg1->structs; *it; it++) {
        const iop_struct_t *st1 = *it;
        const iop_struct_t *st2;
        lstr_t name = iop_get_name_from_fullname(st1->fullname);
        const char *what;
        unsigned st_flags;

        if (st1->is_union) {
            what = "union";
        } else
        if (iop_struct_is_class(st1)) {
            what = "class";
        } else {
            what = "struct";
        }

        if (!(st2 = iop_pkg_get_struct_by_name(pkg2, name))) {
            iop_compat_add_err(ctx, "%s `%*pM` does not exist anymore",
                               what, LSTR_FMT_ARG(st1->fullname));
            res = -1;
            continue;
        }

        iop_compat_push_err_ctx(ctx, "%s `%*pM`:",
                                what, LSTR_FMT_ARG(st1->fullname));
        if ((st_flags = iop_struct_compat_ignored(st2, flags))
        &&  __iop_struct_check_backward_compat(st1, st2, st_flags, ctx) < 0)
        {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
    }

    /* Check interfaces. */
    for (const iop_iface_t *const *it = pkg1->ifaces; *it; it++) {
        const iop_iface_t *if1 = *it;
        const iop_iface_t *if2;
        lstr_t name = iop_get_name_from_fullname(if1->fullname);
        unsigned if_flags;

        if (!(if2 = iop_pkg_get_iface_by_name(pkg2, name))) {
            iop_compat_add_err(ctx,
                               "interface `%*pM` does not exist anymore",
                               LSTR_FMT_ARG(if1->fullname));
            res = -1;
            continue;
        }

        iop_compat_push_err_ctx(ctx, "interface `%*pM`:",
                                LSTR_FMT_ARG(if1->fullname));
        if ((if_flags = iop_iface_compat_ignored(if2, flags))
        &&  __iop_iface_check_backward_compat(if1, if2, if_flags, ctx) < 0)
        {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
    }

    /* Check modules. */
    for (const iop_mod_t *const *it = pkg1->mods; *it; it++) {
        const iop_mod_t *mod1 = *it;
        const iop_mod_t *mod2;
        lstr_t name = iop_get_name_from_fullname(mod1->fullname);

        if (!(mod2 = iop_pkg_get_mod_by_name(pkg2, name))) {
            iop_compat_add_err(ctx, "module `%*pM` does not exist anymore",
                               LSTR_FMT_ARG(mod1->fullname));
            res = -1;
            continue;
        }

        iop_compat_push_err_ctx(ctx, "module `%*pM`:",
                                LSTR_FMT_ARG(mod1->fullname));
        if (__iop_mod_check_backward_compat(mod1, mod2, flags, ctx) < 0) {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
    }

    iop_compat_pop_err_ctx(ctx);

    return res;
}

int iop_pkg_check_backward_compat(const iop_pkg_t *pkg1,
                                  const iop_pkg_t *pkg2,
                                  unsigned flags, sb_t *err)
{
    int res;
    iop_compat_ctx_t ctx;

    iop_compat_ctx_init(&ctx);

    res = iop_pkg_check_backward_compat_ctx(pkg1, pkg2, &ctx, flags, err);

    iop_compat_ctx_wipe(&ctx);

    return res;
}

/* }}} */

static int iop_initialize(void *arg)
{
    iop_env_init(&_G.env);
    iprintf_register_formatter('S', &iop_struct_formatter);
    iprintf_register_formatter('E', &iop_enum_formatter);
    iprintf_register_formatter('U', &iop_union_type_formatter);
    return 0;
}

static int iop_shutdown(void)
{
    iop_env_wipe(&_G.env);
    return 0;
}

module_t *MODULE(iop);

void iop_module_register(void)
{
    if (!MODULE(iop)) {
        MODULE(iop) = module_register(LSTR("iop"), &iop_module,
                                      &iop_initialize, &iop_shutdown, NULL,
                                      0);
    }
}

iop_struct_t const iop__void__s = {
    .fullname   = LSTR_IMMED("Void"),
    .fields_len = 0,
    .size       = 0,
};
