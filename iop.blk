/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "arith.h"
#include "iop.h"
#include "iop-helpers.inl.c"
#include "thr.h"
#include "container.h"
#include "sort.h"

static void
iop_init_fields(void *value, const iop_field_t *fdesc, const iop_field_t *end)
{
    for (; fdesc < end; fdesc++) {
        void *ptr = (char *)value + fdesc->data_offs;

        if (fdesc->repeat == IOP_R_REQUIRED && fdesc->type == IOP_T_STRUCT) {
            /* We can't handle the unions here since we don't know which field
             * has been selected */
            const iop_struct_t *desc = fdesc->u1.st_desc;

            iop_init_fields(ptr, desc->fields, desc->fields +
                            desc->fields_len);
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            switch (fdesc->type) {
              case IOP_T_I8: case IOP_T_U8:
                *(uint8_t *)ptr  = fdesc->u1.defval_u64;
                break;
              case IOP_T_I16: case IOP_T_U16:
                *(uint16_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_ENUM:
                *(uint32_t *)ptr = fdesc->u0.defval_enum;
                break;
              case IOP_T_I32: case IOP_T_U32:
                *(uint32_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_I64: case IOP_T_U64:
                *(uint64_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_BOOL:
                *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
                break;
              case IOP_T_DOUBLE:
                *(double *)ptr   = fdesc->u1.defval_d;
                break;
              case IOP_T_STRING:
              case IOP_T_XML:
              case IOP_T_DATA:
                *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data,
                                             fdesc->u0.defval_len);
                break;
              default:
                e_panic("unsupported");
                continue;
            }
        }
    }
}
void iop_init(const iop_struct_t *desc, void *value)
{
    memset(value, 0, desc->size);
    iop_init_fields(value, desc->fields, desc->fields + desc->fields_len);
}

/*----- duplicating values -{{{-*/

static size_t iop_dup_size(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    size_t len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n    = ((lstr_t *)ptr)->len;
            ptr  = ((lstr_t *)ptr)->data;
            len += ROUND_UP(n * fdesc->size, 8);
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                ptr  = *(void **)ptr;
                len += ROUND_UP(fdesc->size, 8);
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);
                len += iop_dup_size(fdesc->u1.st_desc, v);
            }
        } else {
            for (int j = 0; j < n; j++) {
                len += ROUND_UP(IOP_FIELD(lstr_t, ptr, j).len + 1, 8);
            }
        }
    }

    return len;
}

static uint8_t *realign(uint8_t *ptr)
{
    return (uint8_t *)ROUND_UP((uintptr_t)ptr, 8);
}

static uint8_t *
__iop_copy(const iop_struct_t *st, uint8_t *dst, void *wval, const void *rval)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        fdesc = get_union_field(st, rval);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *rp = (char *)rval + fdesc->data_offs;
        const void *wp = (char *)wval + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n = ((lstr_t *)rp)->len;
            if (n) {
                rp  = ((lstr_t *)rp)->data;
                wp  = ((lstr_t *)wp)->data = dst;
                dst = realign(mempcpy(dst, rp, n * fdesc->size));
            } else {
                ((lstr_t *)wp)->data = NULL;
                wp  = dst;
                dst = realign(dst);
            }
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, rp))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                rp  = *(void **)rp;
                wp  = *(void **)wp = dst;
                dst = realign(mempcpy(dst, rp, fdesc->size));
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            for (int j = 0; j < n; j++) {
                const void *rv = &IOP_FIELD(const char, rp, j * fdesc->size);
                void *wv = &IOP_FIELD(char, wp, j * fdesc->size);

                dst = __iop_copy(fdesc->u1.st_desc, dst, wv, rv);
            }
        } else {
            assert (fdesc->type == IOP_T_STRING || fdesc->type == IOP_T_XML
                ||  fdesc->type == IOP_T_DATA);

            for (int j = 0; j < n; j++) {
                lstr_t *orig = &IOP_FIELD(lstr_t, rp, j);

                /* We have to fix the lstr_t mem_pool manually because some
                 * naughty programmers could have played with it */
                IOP_FIELD(lstr_t, wp, j).data = dst;
                IOP_FIELD(lstr_t, wp, j).mem_pool = MEM_STATIC;
                dst = realign(mempcpyz(dst, orig->s, orig->len));
            }
        }
    }

    return dst;
}

void *iop_dup(mem_pool_t *mp, const iop_struct_t *st, const void *v)
{
    size_t sz;
    uint8_t *dst, *res;

    RETHROW_P(v);

    sz = ROUND_UP(st->size, 8) + iop_dup_size(st, v);
    res = mp ? mp->malloc(mp, sz, MEM_RAW) : imalloc(sz, MEM_LIBC | MEM_RAW);
    dst = realign(mempcpy(res, v, st->size));
    dst = __iop_copy(st, dst, res, v);
    assert (dst == res + sz);
    return res;
}

void iop_copy(mem_pool_t *mp, const iop_struct_t *st, void **outp, const void *v)
{
    size_t sz;
    uint8_t *dst, *res = *outp;

    if (unlikely(!v)) {
        if (mp) {
            mp_delete(mp, outp);
        } else {
            p_delete(outp);
        }

        return;
    }

    sz = ROUND_UP(st->size, 8) + iop_dup_size(st, v);

    if (mp) {
        res = mp->realloc(mp, res, 0, sz, MEM_RAW);
    } else {
        res = irealloc(res, 0, sz, MEM_LIBC | MEM_RAW);
    }
    dst = realign(mempcpy(res, v, st->size));
    dst = __iop_copy(st, dst, res, v);
    assert (dst == res + sz);
    *outp = res;
}

/*----- duplicating values -}}}-*/
/*----- comparing values -{{{-*/

static bool
__iop_equals(const iop_struct_t *st, const uint8_t *v1, const uint8_t *v2)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        if (*(uint16_t *)v1 != *(uint16_t *)v2)
            return false;
        fdesc = get_union_field(st, v1);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r1 = v1 + fdesc->data_offs;
        const void *r2 = v2 + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            /* Here we just check the length of the repeated field, then we
             * position our pointers on values to compare them later. */
            n   = ((lstr_t *)r1)->len;
            if (((lstr_t *)r2)->len != n)
                return false;
            r1  = ((lstr_t *)r1)->data;
            r2  = ((lstr_t *)r2)->data;
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            /* Optional blocks types cannot be compared using a single memcmp
             * we need to handle absent values first. */
            bool has = iop_value_has(fdesc, r1);

            if (has != iop_value_has(fdesc, r2))
                return false;
            if (!has)
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                /* Structures & unions must be dereferenced */
                r1  = *(void **)r1;
                r2  = *(void **)r2;
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            /* We need to recurse to compare structures & unions. */
            for (int i = 0; i < n; i++) {
                const void *t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                const void *t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if (!__iop_equals(fdesc->u1.st_desc, t1, t2))
                    return false;
            }
        } else
        if ((1 << fdesc->type) & IOP_BLK_OK) {
            /* Blocks (string & co) must be compared one by one */
            for (int i = 0; i < n; i++) {
                const lstr_t *t1 = &IOP_FIELD(const lstr_t, r1, i);
                const lstr_t *t2 = &IOP_FIELD(const lstr_t, r2, i);

                if (t1->len != t2->len || memcmp(t1->data, t2->data, t1->len))
                    return false;
            }
        } else {
            assert (fdesc->size > 0 && "IOPC is probably outdated");
            if (!iop_scalar_equals(fdesc, r1, r2, n))
                return false;
        }
    }

    return true;
}

bool iop_equals(const iop_struct_t *st, const void *v1, const void *v2)
{
    if (v1 && v2) {
        return __iop_equals(st, v1, v2);
    } else {
        return v1 == v2;
    }
}

static inline bool
iop_field_is_defval(const iop_field_t *fdesc, const void *ptr)
{
    assert (fdesc->repeat == IOP_R_DEFVAL);

    switch (fdesc->type) {
      case IOP_T_I8: case IOP_T_U8:
        return *(uint8_t *)ptr == (uint8_t)fdesc->u1.defval_u64;
      case IOP_T_I16: case IOP_T_U16:
        return *(uint16_t *)ptr == (uint16_t)fdesc->u1.defval_u64;
      case IOP_T_ENUM:
        return *(int *)ptr == fdesc->u0.defval_enum;
      case IOP_T_I32: case IOP_T_U32:
        return *(uint32_t *)ptr == (uint32_t)fdesc->u1.defval_u64;
      case IOP_T_I64: case IOP_T_U64:
      case IOP_T_DOUBLE:
        /* XXX double is handled like U64 because we want to compare them as
         * bit to bit */
        return *(uint64_t *)ptr == fdesc->u1.defval_u64;
      case IOP_T_BOOL:
        return fdesc->u1.defval_u64 ? *(bool *)ptr : !*(bool *)ptr;
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        if (!fdesc->u0.defval_len) {
            /* In this case we don't care about the string pointer. An empty
             * string is an empty string whatever its pointer is. */
            return !((lstr_t *)ptr)->len;
        } else {
            /* We consider a NULL string as “take the default value please”
             * and otherwise we check for the pointer equality. */
            return !((lstr_t *)ptr)->data
                || (((lstr_t *)ptr)->data == fdesc->u1.defval_data
                 && ((lstr_t *)ptr)->len  == fdesc->u0.defval_len);
        }
      default:
        e_panic("unsupported");
    }
}

/*----- comparing values -}}}-*/
/*----- sorting values -{{{-*/

/* {{{ Field path */

typedef struct field_step_t {
    uint16_t offset;
    uint16_t union_tag;
    flag_t   is_union   : 1;
} field_step_t;
GENERIC_INIT(field_step_t, field_step);

qvector_t(field_step, field_step_t);

typedef struct field_path_t {
    qv_t(field_step)    steps;
    const iop_field_t  *fdesc;
} field_path_t;
GENERIC_FUNCTIONS(field_path_t, field_path);

/* {{{ Get */

static const void *
iop_get_fieldp(const void *data, const field_path_t *field_path)
{
    const qv_t(field_step)  *steps = &field_path->steps;
    const iop_field_t       *fdesc = field_path->fdesc;

    RETHROW_P(data);

    for (int i = 0; i < steps->len - 1; i++) {
        field_step_t *step = &steps->tab[i];

        data = ((const byte *)data) + step->offset;

        if (step->is_union) {
            /* Check if the selected member of the union is the one we want
             * (the one specified in field_path), and if not this object is
             * considered as NULL in the sort */
            if (*(const uint16_t *)data != step->union_tag) {
                return NULL;
            }
        } else {
            /* Pointed structure or union (optional) */
            data = RETHROW_P(*((void **)data));
        }
    }

    data = ((const byte *)data) + qv_last(field_step, steps)->offset;

    /* XXX we sort union based on the union tag */
    if (fdesc->type == IOP_T_UNION) {
        return (const uint16_t *)data;
    }

    if (fdesc->repeat != IOP_R_OPTIONAL) {
        return data;
    }

    switch (fdesc->type) {
      case IOP_T_I8:
      case IOP_T_U8:
        return IOP_OPT_GET((const iop_opt_u8_t *)data);
      case IOP_T_I16:
      case IOP_T_U16:
        return IOP_OPT_GET((const iop_opt_u16_t *)data);
      case IOP_T_ENUM:
      case IOP_T_I32:
      case IOP_T_U32:
        return IOP_OPT_GET((const iop_opt_u32_t *)data);
      case IOP_T_I64:
      case IOP_T_U64:
        return IOP_OPT_GET((const iop_opt_u64_t *)data);
      case IOP_T_BOOL:
        return IOP_OPT_GET((const iop_opt_bool_t *)data);
      case IOP_T_DOUBLE:
        return IOP_OPT_GET((const iop_opt_double_t *)data);
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        return ((const lstr_t *)data)->s ? data : NULL;
      default:
        assert (false);
        return NULL;
    }
}

/* }}} */
/* {{{ Compile */

static int
t_iop_compile_field_path(const iop_struct_t *st, lstr_t field_path_s,
                         field_path_t *fp)
{
    const iop_field_t *fdesc = NULL;
    pstream_t field_path_ps = ps_initlstr(&field_path_s);
    const iop_struct_t *it = st;
    field_step_t *step;

    if (ps_done(&field_path_ps)) {
        return e_error("iop_sort: cannot process empty field path");
    }
    step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
    while (!ps_done(&field_path_ps)) {
        pstream_t fname;
        int ifield;

        if (ps_get_ps_chr_and_skip(&field_path_ps, '.', &fname) < 0) {
            fname = field_path_ps;
            __ps_skip_upto(&field_path_ps, field_path_ps.p_end);
        }

        if (ps_done(&fname)) {
            return e_error("iop_sort: cannot process field path `%*pM', "
                           "abnormal termination",
                           LSTR_FMT_ARG(field_path_s));
        }

        ifield = __iop_field_find_by_name(it, fname.s, ps_len(&fname));
        if (ifield < 0) {
            return e_error("iop_sort: cannot process field path `%*pM', "
                           "field `%*pM' is unknown",
                           LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname));
        }

        fdesc = it->fields + ifield;
        if (fdesc->repeat == IOP_R_REPEATED) {
            /* XXX we could also sort the repeated fields based on their
             * number of elements
             */
            return e_error("iop_sort: cannot process field path `%*pM', "
                           "field `%*pM' is repeated",
                           LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname));
        }
        if (it->is_union) {
            step->is_union = true;
            step->union_tag = fdesc->tag;
            step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
        }

        step->offset += fdesc->data_offs;
        if (fdesc->type == IOP_T_STRUCT || fdesc->type == IOP_T_UNION) {
            it = fdesc->u1.st_desc;

            if (fdesc->repeat == IOP_R_OPTIONAL) {
                step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
            }
        }
    }

    fp->fdesc = fdesc;

    return 0;
}

/* }}} */

/* }}} */
/* {{{ cmp functions */

static cmp_f const iop_cmp_funs[] = {
    [IOP_T_I8]          = &cmp_i8,
    [IOP_T_U8]          = &cmp_u8,
    [IOP_T_I16]         = &cmp_i16,
    [IOP_T_U16]         = &cmp_u16,
    [IOP_T_ENUM]        = &cmp_i32,
    [IOP_T_I32]         = &cmp_i32,
    [IOP_T_U32]         = &cmp_u32,
    [IOP_T_I64]         = &cmp_i64,
    [IOP_T_U64]         = &cmp_u64,
    [IOP_T_BOOL]        = &cmp_bool,
    [IOP_T_DOUBLE]      = &cmp_double,
    [IOP_T_UNION]       = &cmp_u16,
    [IOP_T_STRING]      = &cmp_lstr_iutf8,
    [IOP_T_XML]         = &cmp_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_lstr_iutf8,
};
static cmp_f const iop_cmp_rev_funs[] = {
    [IOP_T_I8]          = &cmp_rev_i8,
    [IOP_T_U8]          = &cmp_rev_u8,
    [IOP_T_I16]         = &cmp_rev_i16,
    [IOP_T_U16]         = &cmp_rev_u16,
    [IOP_T_ENUM]        = &cmp_rev_i32,
    [IOP_T_I32]         = &cmp_rev_i32,
    [IOP_T_U32]         = &cmp_rev_u32,
    [IOP_T_I64]         = &cmp_rev_i64,
    [IOP_T_U64]         = &cmp_rev_u64,
    [IOP_T_BOOL]        = &cmp_rev_bool,
    [IOP_T_DOUBLE]      = &cmp_rev_double,
    [IOP_T_UNION]       = &cmp_rev_u16,
    [IOP_T_STRING]      = &cmp_rev_lstr_iutf8,
    [IOP_T_XML]         = &cmp_rev_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_rev_lstr_iutf8,
};

/*}}}*/

int iop_sort(const iop_struct_t *st, void *vec, int len,
             lstr_t field_path_s, int flags)
{
    t_scope;
    field_path_t fp;
    cmp_f cmp;

    field_path_init(&fp);
    t_qv_init(field_step, &fp.steps, 16);
    if (t_iop_compile_field_path(st, field_path_s, &fp) < 0) {
        return -1;
    }

    if (fp.fdesc == NULL) {
        return e_error("iop_sort: no field specified");
    }
    if (fp.fdesc->type == IOP_T_STRUCT) {
        return e_error("iop_sort: cannot sort on struct");
    }

    if (flags & IOP_SORT_REVERSE) {
        cmp = iop_cmp_rev_funs[fp.fdesc->type];
    } else {
        cmp = iop_cmp_funs[fp.fdesc->type];
    }

    __qv_sort(vec, st->size, len,
    ^int (const void *d1, const void *d2) {
        d1 = iop_get_fieldp(d1, &fp);
        d2 = iop_get_fieldp(d2, &fp);
        if (d1 == d2)
            return 0;
        if (d1 == NULL)
            return (flags & IOP_SORT_NULL_FIRST) ? -1 : 1;
        if (d2 == NULL)
            return (flags & IOP_SORT_NULL_FIRST) ? 1 : -1;
        return (*cmp)(d1, d2);
    });

    return 0;
}

/* }}} */
/*----- hashing values -{{{-*/

struct iop_hash_ctx {
    size_t   pos;
    uint8_t  buf[1024];
    void   (*hfun)(void *ctx, const void *input, int len);
    void    *ctx;
};

static ALWAYS_INLINE
void iop_hash_update(struct iop_hash_ctx *ctx, const void *d, size_t len)
{
    size_t pos = ctx->pos;

    if (pos + len > sizeof(ctx->buf)) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
        ctx->hfun(ctx->ctx, d, len);
    } else {
        memcpy(ctx->buf + pos, d, len);
        if ((pos += len) > sizeof(ctx->buf) / 2) {
            ctx->pos = 0;
            ctx->hfun(ctx->ctx, ctx->buf, pos);
        } else {
            ctx->pos = pos;
        }
    }
}

static ALWAYS_INLINE
void iop_hash_update_u16(struct iop_hash_ctx *ctx, uint16_t i)
{
    size_t pos = ctx->pos;

    assert (pos + 2 < sizeof(ctx->buf));
    put_unaligned_le16(ctx->buf + pos, i);
    if ((pos += 2) > sizeof(ctx->buf) / 2) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
    } else {
        ctx->pos = pos;
    }
}

static ALWAYS_INLINE
void iop_hash_update_u32(struct iop_hash_ctx *ctx, uint32_t i)
{
    size_t pos = ctx->pos;

    assert (pos + 4 < sizeof(ctx->buf));
    put_unaligned_le32(ctx->buf + pos, i);
    if ((pos += 4) > sizeof(ctx->buf) / 2) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
    } else {
        ctx->pos = pos;
    }
}

static ALWAYS_INLINE
void iop_hash_update_i64(struct iop_hash_ctx *ctx, int64_t i)
{
    size_t pos = ctx->pos;

    assert (pos + 8 < sizeof(ctx->buf));
    put_unaligned_le64(ctx->buf + pos, i);
    if ((pos += 8) > sizeof(ctx->buf) / 2) {
        ctx->pos = 0;
        ctx->hfun(ctx->ctx, ctx->buf, pos);
    } else {
        ctx->pos = pos;
    }
}
#define iop_hash_update_dbl(ctx, d) \
    iop_hash_update_i64(ctx, double_bits_cpu(d))

static void
iop_opt_hash(struct iop_hash_ctx *ctx, const iop_field_t *f, const void *v)
{
    uint8_t b;

    switch (f->type) {
      case IOP_T_BOOL:
        b = !!((iop_opt_bool_t *)v)->v;
        iop_hash_update(ctx, &b, 1);
        break;
      case IOP_T_I8:
        iop_hash_update_i64(ctx, ((iop_opt_i8_t *)v)->v);
        break;
      case IOP_T_U8:
        iop_hash_update_i64(ctx, ((iop_opt_u8_t *)v)->v);
        break;
      case IOP_T_I16:
        iop_hash_update_i64(ctx, ((iop_opt_i16_t *)v)->v);
        break;
      case IOP_T_U16:
        iop_hash_update_i64(ctx, ((iop_opt_u16_t *)v)->v);
        break;
      case IOP_T_I32: case IOP_T_ENUM:
        iop_hash_update_i64(ctx, ((iop_opt_i32_t *)v)->v);
        break;
      case IOP_T_U32:
        iop_hash_update_i64(ctx, ((iop_opt_u32_t *)v)->v);
        break;
      case IOP_T_I64:
        iop_hash_update_i64(ctx, ((iop_opt_i64_t *)v)->v);
        break;
      case IOP_T_U64:
        iop_hash_update_i64(ctx, ((iop_opt_u64_t *)v)->v);
        break;
      case IOP_T_DOUBLE:
        iop_hash_update_dbl(ctx, ((iop_opt_double_t *)v)->v);
        break;
      default:
        e_panic("should not happen");
    }
}

static void
__iop_hash(struct iop_hash_ctx *ctx, const iop_struct_t *st, const uint8_t *v)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        fdesc = get_union_field(st, v);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r = v + fdesc->data_offs;
        int n = 1;

        iop_hash_update_u16(ctx, fdesc->tag);
        iop_hash_update(ctx, fdesc->name.s, fdesc->name.len);

        if (fdesc->repeat == IOP_R_REPEATED) {
            n  = ((lstr_t *)r)->len;
            r  = ((lstr_t *)r)->data;
            iop_hash_update_u32(ctx, n);
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, r))
                continue;

            if ((1 << fdesc->type) & IOP_BLK_OK) {
                if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                    r = *(void **)r;
                }
            } else {
                iop_opt_hash(ctx, fdesc, r);
                continue;
            }
        }
        switch (fdesc->type) {
          case IOP_T_I8:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int8_t *)r)[i]);
            }
            break;
          case IOP_T_BOOL:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, !!((bool *)r)[i]);
            }
            break;
          case IOP_T_U8:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint8_t *)r)[i]);
            }
            break;
          case IOP_T_I16:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int16_t *)r)[i]);
            }
            break;
          case IOP_T_U16:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint16_t *)r)[i]);
            }
            break;
          case IOP_T_I32: case IOP_T_ENUM:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int32_t *)r)[i]);
            }
            break;
          case IOP_T_U32:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint32_t *)r)[i]);
            }
            break;
          case IOP_T_I64:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((int64_t *)r)[i]);
            }
            break;
          case IOP_T_U64:
            for (int i = 0; i < n; i++) {
                iop_hash_update_i64(ctx, ((uint64_t *)r)[i]);
            }
            break;
          case IOP_T_DOUBLE:
            for (int i = 0; i < n; i++) {
                iop_hash_update_dbl(ctx, ((double *)r)[i]);
            }
            break;
          case IOP_T_UNION:
          case IOP_T_STRUCT:
            for (int i = 0; i < n; i++) {
                __iop_hash(ctx, fdesc->u1.st_desc,
                           &IOP_FIELD(const uint8_t, r, i * fdesc->size));
            }
            break;
          case IOP_T_XML:
          case IOP_T_STRING:
          case IOP_T_DATA:
            for (int i = 0; i < n; i++) {
                const lstr_t *s = &IOP_FIELD(const lstr_t, r, i);

                iop_hash_update_u32(ctx, s->len);
                iop_hash_update(ctx, s->data, s->len);
            }
            break;
          default:
            e_panic("should not happen");
        }
    }
}

void iop_hash(const iop_struct_t *st, const void *v,
              void (*hfun)(void *ctx, const void *input, int ilen),
              void *hctx)
{
    struct iop_hash_ctx ctx = {
        .hfun = hfun,
        .ctx  = hctx,
    };
    __iop_hash(&ctx, st, v);
    if (ctx.pos)
        hfun(hctx, ctx.buf, ctx.pos);
}

/*----- duplicating values -}}}-*/
/*----- check constraints before packing -{{{-*/

static __thread sb_t iop_err_g;

__attribute__((constructor))
static void iop_init_err(void)
{
    if (unlikely(iop_err_g.size == 0))
        sb_init(&iop_err_g);
}

static void iop_wipe_err(void)
{
    if (iop_err_g.size)
        sb_wipe(&iop_err_g);
}

thr_hooks(iop_init_err, iop_wipe_err);

void iop_set_verr(const char *fmt, va_list ap)
{
    sb_setvf(&iop_err_g, fmt, ap);
}

int iop_set_err(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    iop_set_verr(fmt, ap);
    va_end(ap);
    return -1;
}

int iop_set_err2(const lstr_t *s)
{
    sb_set(&iop_err_g, s->s, s->len);
    return -1;
}

void iop_clear_err(void)
{
    sb_reset(&iop_err_g);
}

const char *iop_get_err(void)
{
    if (iop_err_g.len)
        return iop_err_g.data;
    return NULL;
}

lstr_t iop_get_err_lstr(void)
{
    if (iop_err_g.len)
        return LSTR_INIT_V(iop_err_g.data, iop_err_g.len);
    return LSTR_NULL_V;
}

bool iop_field_has_constraints(const iop_struct_t *desc, const iop_field_t
                               *fdesc)
{
    if (iop_field_get_constraints_cb(desc, fdesc))
        return true;
    if (fdesc->type == IOP_T_ENUM && fdesc->u1.en_desc->flags)
        return true;
    return false;
}

int iop_field_check_constraints(const iop_struct_t *desc, const iop_field_t
                                *fdesc, const void *ptr, int n, bool recurse)
{
    check_constraints_f check_constraints = NULL;
    if ((check_constraints = iop_field_get_constraints_cb(desc, fdesc))) {
        RETHROW(check_constraints(ptr, n));
    }
    switch (fdesc->type) {
      case IOP_T_ENUM:
        if (TST_BIT(&fdesc->u1.en_desc->flags, IOP_ENUM_STRICT)) {
            const iop_enum_t *en_desc = fdesc->u1.en_desc;

            for (int j = 0; j < n; j++) {
                int32_t intval = IOP_FIELD(int32_t, ptr, j);

                if (iop_ranges_search(en_desc->ranges,
                                      en_desc->ranges_len, intval) != -1)
                {
                    continue;
                }
                return iop_set_err("%d is not a valid value for enum %*pM",
                                   intval, LSTR_FMT_ARG(en_desc->fullname));
            }
        }
        break;
      case IOP_T_I8:
      case IOP_T_U8:
      case IOP_T_I16:
      case IOP_T_U16:
      case IOP_T_I32:
      case IOP_T_U32:
      case IOP_T_I64:
      case IOP_T_U64:
      case IOP_T_BOOL:
      case IOP_T_DOUBLE:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        break;
      case IOP_T_UNION:
      case IOP_T_STRUCT:
      default:
        if (!recurse)
            return 0;
        for (int j = 0; j < n; j++) {
            const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

            RETHROW(iop_check_constraints(fdesc->u1.st_desc, v));
        }
        break;
    }

    return 0;
}

int iop_check_constraints(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    unsigned           desc_flags = desc->flags;

    if (!TST_BIT(&desc_flags, IOP_STRUCT_HAS_CONSTRAINTS))
        return 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0) {
                unsigned fdesc_flags = fdesc->flags;

                if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
                    iop_set_err("empty array not allowed for field `%*pM`",
                                LSTR_FMT_ARG(fdesc->name));
                    return -1;
                }
                continue;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field is it's still equal to its default value */
            if (iop_field_is_defval(fdesc, ptr))
                continue;
        }

        RETHROW(iop_field_check_constraints(desc, fdesc, ptr, n, true));
    }

    return 0;
}

/*-}}}-*/
/*----- get value encoding size -{{{-*/

static int __iop_bpack_size(const iop_struct_t *desc, const void *val,
                            const unsigned flags, qv_t(i32) *szs)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    int len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0)
                continue;
            if (n > 1) {
                if ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    int32_t i32 = n * fdesc->size;

                    len += 1 + fdesc->tag_len;
                    len += get_len_len(i32) + i32;
                    continue;
                }
                len += 4 + n;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field is it's still equal to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&   iop_field_is_defval(fdesc, ptr))
            {
                continue;
            }
        }

        len += 1 + fdesc->tag_len;
        switch (fdesc->type) {
          case IOP_T_I8:
            len += n;
            break;
          case IOP_T_U8:
            len += n;
            for (int j = 0; j < n; j++)
                len += IOP_FIELD(uint8_t, ptr, j) >> 7;
            break;
          case IOP_T_I16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int16_t, ptr, j));
            break;
          case IOP_T_U16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(uint16_t, ptr, j));
            break;
          case IOP_T_I32:
          case IOP_T_ENUM:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int32_t, ptr, j));
            break;
          case IOP_T_U32:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(uint32_t, ptr, j));
            break;
          case IOP_T_I64:
          case IOP_T_U64:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(int64_t, ptr, j));
            break;
          case IOP_T_BOOL:
            len += n;
            break;
          case IOP_T_DOUBLE:
            len += n * 8;
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            for (int j = 0; j < n; j++) {
                int32_t i32 = IOP_FIELD(lstr_t, ptr, j).len;
                len += get_len_len(i32 + 1) + i32 + 1;
            }
            break;
          case IOP_T_UNION:
          case IOP_T_STRUCT:
          default:
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);
                int32_t offs = szs->len, i32;

                qv_growlen(i32, szs, 1);
                i32  = __iop_bpack_size(fdesc->u1.st_desc, v, flags, szs);
                szs->tab[offs] = i32;
                len += get_len_len(i32) + i32;
            }
            break;
        }
    }

    return len;
}

int iop_bpack_size_flags(const iop_struct_t *desc, const void *val,
                         const unsigned flags, qv_t(i32) *szs)
{
    /* Put the packer flags in first to reuse them when packing */
    qv_append(i32, szs, flags);

    return __iop_bpack_size(desc, val, flags, szs);
}

/*-}}}-*/
/*----- packing -{{{-*/

static uint8_t *pack_struct(void *dst, const iop_struct_t *, const void *,
                            const unsigned, const int **);
static uint8_t *pack_union(void *dst, const iop_struct_t *, const void *,
                           const unsigned, const int **);

static uint8_t *
pack_value(uint8_t *dst, const iop_field_t *f, const void *v,
           const unsigned flags, const int **szsp)
{
    uint32_t len;

    switch (f->type) {
      case IOP_T_I8:
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = *(int8_t *)v;
        return dst;
      case IOP_T_U8:
        return pack_int32(dst, f->tag, f->tag_len, *(uint8_t *)v);
      case IOP_T_I16:
        return pack_int32(dst, f->tag, f->tag_len, *(int16_t *)v);
      case IOP_T_U16:
        return pack_int32(dst, f->tag, f->tag_len, *(uint16_t *)v);
      case IOP_T_I32:
      case IOP_T_ENUM:
        return pack_int32(dst, f->tag, f->tag_len, *(int32_t *)v);
      case IOP_T_U32:
        return pack_int64(dst, f->tag, f->tag_len, *(uint32_t *)v);
      case IOP_T_I64:
      case IOP_T_U64:
        return pack_int64(dst, f->tag, f->tag_len, *(int64_t *)v);
      case IOP_T_BOOL:
        /* bool are mapped to 0 or 1 */
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = !!*(bool *)v;
        return dst;
      case IOP_T_DOUBLE:
        dst = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(QUAD));
        return put_unaligned_double_le(dst, *(double *)v);
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        len = ((lstr_t *)v)->len;
        dst = pack_len(dst, f->tag, f->tag_len, len + 1);
        dst = mempcpyz(dst, ((lstr_t *)v)->data, len);
        return dst;
      case IOP_T_UNION:
        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        return pack_union(dst, f->u1.st_desc, v, flags, szsp);
      case IOP_T_STRUCT:
      default:
        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        return pack_struct(dst, f->u1.st_desc, v, flags, szsp);
    }
}

static uint8_t *
pack_value_vec(uint8_t *dst, const iop_field_t *f, const void *v, uint32_t n,
               const unsigned flags, const int **szsp)
{
    const lstr_t *d;
    uint32_t len;

    switch (f->type) {
      case IOP_T_I32:
      case IOP_T_ENUM:
        do {
            dst = pack_int32(dst, 0, 0, *(int32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_U32:
        do {
            dst = pack_int64(dst, 0, 0, *(uint32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_I64:
      case IOP_T_U64:
        do {
            dst = pack_int64(dst, 0, 0, *(int64_t *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_DOUBLE:
        do {
            dst = pack_tag(dst, 0, 0, IOP_WIRE_MASK(QUAD));
            dst = put_unaligned_double_le(dst, *(double *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        do {
            d = v;
            len = d->len;
            dst = pack_len(dst, 0, 0, len + 1);
            dst = mempcpyz(dst, d->data, len);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_UNION:
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            dst = pack_union(dst, f->u1.st_desc, v, flags, szsp);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_STRUCT:
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            dst = pack_struct(dst, f->u1.st_desc, v, flags, szsp);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;

      default:
        e_panic("should not happen");
    }
}

static uint8_t *
pack_struct(void *dst, const iop_struct_t *desc, const void *v,
            const unsigned flags, const int **szsp)
{
    assert(!desc->is_union); /* We don't want a union here */

    for (int i = 0; i < desc->fields_len; i++) {
        const iop_field_t *f = desc->fields + i;
        const void *ptr = (char *)v + f->data_offs;

        if (f->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(f, ptr))
                continue;
            if ((1 << f->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (f->repeat == IOP_R_REPEATED) {
            const lstr_t *data = ptr;

            if (data->len == 0)
                continue;
            ptr = data->data;
            if (data->len > 1) {
                if ((1 << f->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    /* When data unit is really small (byte, bool, …) we
                     * prefer to pack them in one big block */
                    uint32_t sz = data->len * f->size;

                    assert (f->size <= 2);
                    dst = pack_len(dst, f->tag, f->tag_len, sz);
                    dst = mempcpy(dst, data->data, sz);
                } else {
                    dst = pack_tag(dst, f->tag, f->tag_len,
                                   IOP_WIRE_MASK(REPEAT));
                    dst = put_unaligned_le32(dst, data->len);
                    dst = pack_value_vec(dst, f, ptr, data->len, flags, szsp);
                }
                continue;
            }
        } else
        if (f->repeat == IOP_R_DEFVAL) {
            /* Skip the field is it's still equal to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&  iop_field_is_defval(f, ptr))
            {
                continue;
            }
        }

        dst = pack_value(dst, f, ptr, flags, szsp);
    }
    return dst;
}

static uint8_t *
pack_union(void *dst, const iop_struct_t *desc, const void *v,
           const unsigned flags, const int **szsp)
{
    const iop_field_t *f = get_union_field(desc, v);
    assert(f->repeat == IOP_R_REQUIRED);

    return pack_value(dst, f, (char *)v + f->data_offs, flags, szsp);
}

void iop_bpack(void *dst, const iop_struct_t *desc, const void *v,
               const int *szs)
{
    /* Read packing flags from first `szs' value */
    const unsigned flags = *szs++;

    if (desc->is_union) {
        pack_union(dst, desc, v, flags, &szs);
    } else {
        pack_struct(dst, desc, v, flags, &szs);
    }
}

lstr_t t_iop_bpack_struct_flags(const iop_struct_t *st, const void *v,
                                const unsigned flags)
{
    qv_t(i32) sizes;
    byte *data;
    int len;

    if (!v)
        return LSTR_NULL_V;

    qv_inita(i32, &sizes, 1024);

    len  = iop_bpack_size_flags(st, v, flags, &sizes);
    data = t_new_raw(byte, len + 1);
    data[len] = '\0';

    iop_bpack(data, st, v, sizes.tab);
    qv_wipe(i32, &sizes);
    return lstr_init_(data, len, MEM_STACK);
}

/*-}}}-*/
/*----- unpacking -{{{-*/

static int get_uint32(pstream_t *ps, int ilen, uint32_t *u32)
{
    PS_WANT(ps_has(ps, ilen));
    *u32 = 0;
    memcpy(u32, ps->p, ilen);
#if __BYTE_ORDER == __BIG_ENDIAN
    *u32 = __builtin_bswap32(*u32);
#endif
    return __ps_skip(ps, ilen);
}

/*
 * XXX: an iop_range helps doing run-length encoded binary search. We know
 * that IOPs tags are mostly contiguous, hence we encode "full" runs of tags
 * this way:
 *   [ offset0, start_tag0, offset1, ..., start_tag_n, offset_n]
 *
 * This means that the offset0-th up to the offset1-th values described by
 * this iop_range take values contiguously from the range:
 *   [ start_tag0 .. start_tag0 + offset1 - offset0 [
 *
 * Of course, offset0 is always equal to 0, and offset_n should be equal to
 * ranges_len.
 *
 * Example: the iop_range for "10 11 12 13 100 101 102" is "0 10 4 100 7"
 *  - positions [0 .. 4[ have values in [10  .. 10 + 4 - 0[
 *  - positions [4 .. 7[ have values in [100 .. 100 + 7 - 4[
 *
 */
int iop_ranges_search(int const * ranges, int ranges_len, int tag)
{
    int l = 0, r = ranges_len;

    while (l < r) {
        int i = (l + r) / 2;
        int offs  = ranges[i * 2];
        int start = ranges[i * 2 + 1];

        if (tag < start) {
            r = i;
            continue;
        }
        if (tag + offs >= start + ranges[i * 2 + 2]) {
            l = i + 1;
            continue;
        }
        return ranges[i * 2] + (tag - start);
    }
    return -1;
}

int iop_enum_from_str2(const iop_enum_t *e, const char *s, int len, bool *found)
{
    if (len < 0)
        len = strlen(s);
    *found = false;
    for (int i = 0; i < e->enum_len; i++) {
        if (len == e->names[i].len && !strncasecmp(e->names[i].s, s, len)) {
            *found = true;
            return e->values[i];
        }
    }
    return -1;
}

int iop_enum_from_str(const iop_enum_t *e, const char *s, int len, int err)
{
    bool found;
    int val = iop_enum_from_str2(e, s, len, &found);

    return (found) ? val : err;
}

int iop_enum_from_lstr(const iop_enum_t *e, const lstr_t s, bool *found)
{
    *found = false;
    for (int i = 0; i < e->enum_len; i++) {
        if (s.len == e->names[i].len
        &&  strncasecmp(e->names[i].s, s.s, s.len) == 0)
        {
            *found = true;
            return e->values[i];
        }
    }
    return -1;
}


static int iop_skip_field(pstream_t *ps, iop_wire_type_t wt)
{
    uint32_t u32;

    switch (wt) {
      case IOP_WIRE_BLK1: PS_CHECK(get_uint32(ps, 1, &u32)); break;
      case IOP_WIRE_BLK2: PS_CHECK(get_uint32(ps, 2, &u32)); break;
      case IOP_WIRE_BLK4: PS_CHECK(get_uint32(ps, 4, &u32)); break;

      case IOP_WIRE_INT1:
      case IOP_WIRE_INT2:
      case IOP_WIRE_INT4:
        u32 = 1 << (wt - IOP_WIRE_INT1);
        break;
      case IOP_WIRE_QUAD:
        u32 = 8;
        break;
      default:
        return -1;
    }

    return ps_skip(ps, u32);
}

static ALWAYS_INLINE
int iop_patch_int(const iop_field_t *fdesc, void *ptr, int64_t i64)
{
    switch (fdesc->type) {
      case IOP_T_I8: case IOP_T_U8:
        *(int8_t *)ptr  = i64;
        break;
      case IOP_T_I16: case IOP_T_U16:
        *(int16_t *)ptr = i64;
        break;
      case IOP_T_ENUM:
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_I32: case IOP_T_U32:
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        *(int64_t *)ptr = i64;
        break;
      case IOP_T_BOOL:
        *(bool *)ptr    = i64;
        break;
    }
    return 0;
}

static ALWAYS_INLINE int
__get_tag_wt(pstream_t *ps, uint32_t *tag, iop_wire_type_t *wt)
{
    *wt  = IOP_WIRE_FMT(ps->b[0]);
    *tag = IOP_TAG(__ps_getc(ps));
    if (likely(*tag < IOP_LONG_TAG(1)))
        return 0;
    if (likely(*tag == IOP_LONG_TAG(1)))
        return get_uint32(ps, 1, tag);
    return get_uint32(ps, 2, tag);
}

int __iop_skip_absent_field_desc(void *value, const iop_field_t *fdesc)
{
    void *ptr = (char *)value + fdesc->data_offs;

    if (fdesc->repeat == IOP_R_REQUIRED) {
        const iop_struct_t *desc = fdesc->u1.st_desc;

        /* For a required field, only structs can be absents, be careful that
         * union must be presents */
        PS_WANT(fdesc->type == IOP_T_STRUCT);
        for (int i = 0; i < desc->fields_len; i++)
            PS_CHECK(__iop_skip_absent_field_desc(ptr, desc->fields + i));
        return 0;
    } else
    if (fdesc->repeat == IOP_R_DEFVAL) {
        switch (fdesc->type) {
          case IOP_T_I8: case IOP_T_U8:
            *(uint8_t *)ptr  = fdesc->u1.defval_u64;
            break;
          case IOP_T_I16: case IOP_T_U16:
            *(uint16_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_ENUM:
            *(uint32_t *)ptr = fdesc->u0.defval_enum;
            break;
          case IOP_T_I32: case IOP_T_U32:
            *(uint32_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_I64: case IOP_T_U64:
            *(uint64_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_BOOL:
            *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
            break;
          case IOP_T_DOUBLE:
            *(double *)ptr   = fdesc->u1.defval_d;
            break;
          case IOP_T_STRING:
          case IOP_T_XML:
          case IOP_T_DATA:
            *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data,
                                         fdesc->u0.defval_len);
            break;
          default:
            return -1;
        }
    } else
    if (fdesc->repeat == IOP_R_REPEATED) {
        unsigned fdesc_flags = fdesc->flags;

        if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
            iop_set_err("empty array not allowed for field `%*pM`",
                        LSTR_FMT_ARG(fdesc->name));
            return -1;
        }
        p_clear((lstr_t *)ptr, 1);
    } else {
        iop_value_set_absent(fdesc, ptr);
    }
    return 0;
}

static int unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                         pstream_t *ps, bool copy);
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, bool copy);

static int unpack_value(mem_pool_t *mp, iop_wire_type_t wt,
                        const iop_field_t *fdesc, void *v,
                        pstream_t *ps, bool copy)
{
    uint32_t u32;
    pstream_t ps_tmp;

    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_WANT(ps_has(ps, u32));
        switch (fdesc->type) {
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            *(lstr_t *)v = LSTR_INIT_V((copy ? mp_dup(mp, ps->s, u32)
                                        : ps->p), u32 - 1);
            return __ps_skip(ps, u32);
          case IOP_T_UNION:
            ps_tmp = __ps_get_ps(ps, u32);
            return unpack_union(mp, fdesc->u1.st_desc, v, &ps_tmp, copy);
          case IOP_T_STRUCT:
            ps_tmp = __ps_get_ps(ps, u32);
            return unpack_struct(mp, fdesc->u1.st_desc, v, &ps_tmp, copy);
        }
        return -1;

      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int8_t)__ps_getc(ps));

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int16_t)__ps_get_le16(ps));

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int32_t)__ps_get_le32(ps));

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_WANT(ps_has(ps, 8));
            return iop_patch_int(fdesc, v, __ps_get_le64(ps));
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE)
            return ps_get_double_le(ps, v);
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        return ps_get_le64(ps, v);
      default:
        return -1;
    }
}

static int unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                         pstream_t *ps, bool copy)
{
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = desc->fields + desc->fields_len;

    while (fdesc < end && !ps_done(ps)) {
        iop_wire_type_t wt;
        uint32_t tag, n = 1;
        void *v;

        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
        while (unlikely(tag > fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking struct %*pM, skipping %*pM field",
                          LSTR_FMT_ARG(desc->fullname),
                          LSTR_FMT_ARG(fdesc->name));
            PS_CHECK(__iop_skip_absent_field_desc(value, fdesc));
            if (++fdesc == end)
                return 0;
        }
        if (unlikely(tag < fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking struct %*pM, skipping %*pM field",
                          LSTR_FMT_ARG(desc->fullname),
                          LSTR_FMT_ARG(fdesc->name));
            PS_CHECK(iop_skip_field(ps, wt));
            continue;
        }

        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, unpacking %*pM field",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name));

        if (wt == IOP_WIRE_REPEAT) {
            PS_CHECK(get_uint32(ps, 4, &n));
            PS_WANT(n >= 1);
            PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
            wt = IOP_WIRE_FMT(__ps_getc(ps));
        }

        v = (char *)value + fdesc->data_offs;
        if (fdesc->repeat == IOP_R_REPEATED) {
            lstr_t *data = v;

            if (wt != IOP_WIRE_REPEAT
            &&  ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK))
            {
                /* optimized version of repeated fields are packed in simples
                 * IOP blocks */
                uint32_t len;

                switch (wt) {
                  case IOP_WIRE_BLK1:
                    PS_CHECK(get_uint32(ps, 1, &len));
                    break;
                  case IOP_WIRE_BLK2:
                    PS_CHECK(get_uint32(ps, 2, &len));
                    break;
                  case IOP_WIRE_BLK4:
                    PS_CHECK(get_uint32(ps, 4, &len));
                    break;
                  default:
                    /* Here we expect to have a uniq-value packed as a normal
                     * field (data->len == 1) */
                    goto unpack_array;
                }
                PS_WANT(ps_has(ps, len));

                if (fdesc->size == 1) {
                    data->len = len;
                    data->data = (copy ? mp_dup(mp, ps->s, len)
                                       : (void *)ps->p);
                } else {
                    assert (fdesc->size == 2);
                    PS_WANT(len % 2 == 0);
                    data->len  = len / 2;
                    data->data = mp_dup(mp, ps->s, len);
                }

                __ps_skip(ps, len);
                v = data->data;
                n = data->len;
                goto next;
            }

          unpack_array:
            data->len  = n;
            data->data = v = mp->malloc(mp, n * fdesc->size, MEM_RAW);

            while (n-- > 1) {
                PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
                v  = (char *)v + fdesc->size;
            }
            PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
            v = data->data;
            n = data->len;
        } else {
            if (fdesc->repeat == IOP_R_OPTIONAL) {
                v = iop_value_set_here(mp, fdesc, v);
            }
            while (n-- > 1) {
                PS_CHECK(iop_skip_field(ps, wt));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
            }
            PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
            n = 1;
        }

      next:
        if (unlikely(iop_field_has_constraints(desc, fdesc))) {
            RETHROW(iop_field_check_constraints(desc, fdesc, v, n, false));
        }
        fdesc++;
    }

    for (; fdesc < end; fdesc++) {
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, skipping %*pM field",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name));
        PS_CHECK(__iop_skip_absent_field_desc(value, fdesc));
    }
    return 0;
}

/* note: returns 0 on success, -1 on error and 1 if the pstream hasn't been
 * fully consumed. */
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, bool copy)
{
    const iop_field_t *fdesc = desc->fields;

    iop_wire_type_t wt;
    uint32_t tag;
    int ifield;

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Write the selected field */
    *((uint16_t *)value) = fdesc->tag;
    value = (char *)value + fdesc->data_offs;

    e_named_trace(5, "iop/c/unpacker", "unpacking union %*pM field %*pM",
                  LSTR_FMT_ARG(desc->fullname), LSTR_FMT_ARG(fdesc->name));
    PS_CHECK(unpack_value(mp, wt, fdesc, value, ps,
                          copy));
    if (unlikely(iop_field_has_constraints(desc, fdesc))) {
        RETHROW(iop_field_check_constraints(desc, fdesc, value, 1, false));
    }
    return ps_done(ps) ? 0 : 1;
}

int iop_bunpack(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                pstream_t ps, bool copy)
{
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);
    if (desc->is_union) {
        return unpack_union(mp, desc, value, &ps, copy) ? -1 : 0;
    }
    return unpack_struct(mp, desc, value, &ps, copy);
}

/* This function act like `iop_bunpack` but consume the pstream and doesn't
 * check that the pstream has been fully consumed. This allows to unpack
 * a suite of union.
 *
 * XXX: this function can unpack only union because the struct can't be
 * delimited in a stream.
 * */
int iop_bunpack_multi(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                pstream_t *ps, bool copy)
{
    assert(desc->is_union);

    e_named_trace(5, "iop/c/unpacker", "unpacking IOP union(s) %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);
    return (unpack_union(mp, desc, value, ps, copy) < 0) ? -1 : 0;
}

/* XXX this function doesn't check the IOP content and trust what it reads
 * XXX: this function can unpack only union because the struct can't be
 * delimited in a stream. */
int iop_bskip(const iop_struct_t *desc, pstream_t *ps)
{
    const iop_field_t *fdesc = desc->fields;
    iop_wire_type_t wt;
    uint32_t tag, u32;
    int ifield;

    assert(desc->is_union);

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Skip union data */
    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_CHECK(ps_skip(ps, u32)); /* Skip block */
        return 0;

      case IOP_WIRE_INT1:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 1));
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 2));
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 4));
        return 0;

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_CHECK(ps_skip(ps, 8));
            return 0;
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE) {
            PS_CHECK(ps_skip(ps, sizeof(double)));
            return 0;
        }
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        PS_CHECK(ps_skip(ps, 8));
        return 0;
      default:
        return -1;
    }
}

ssize_t iop_get_field_len(pstream_t ps)
{
    iop_wire_type_t wt;
    uint32_t tag, u32, tag_len, len_len;

    if (ps_done(&ps))
        return 0;
    wt  = IOP_WIRE_FMT(ps.b[0]);
    tag = IOP_TAG(ps.b[0]);
    if (likely(tag < IOP_LONG_TAG(1))) {
        tag_len = 1;
    } else {
        tag_len = 2 + tag - IOP_LONG_TAG(1);
    }
    switch (wt) {
      case IOP_WIRE_BLK1:
        len_len = 1;
        break;
      case IOP_WIRE_BLK2:
        len_len = 2;
        break;
      case IOP_WIRE_BLK4:
        len_len = 4;
        break;
      case IOP_WIRE_REPEAT: /* not supported by this function */
        return -1;
      case IOP_WIRE_INT1:
        return tag_len + 1;
      case IOP_WIRE_INT2:
        return tag_len + 2;
      case IOP_WIRE_INT4:
        return tag_len + 4;
      case IOP_WIRE_QUAD:
        return tag_len + 8;
      default:
        return -1;
    }
    if (ps_skip(&ps, tag_len) < 0)
        return 0;
    if (get_uint32(&ps, len_len, &u32) < 0)
        return 0;
    return tag_len + len_len + u32;
}

/*-}}}-*/
/*------ introspection -{{{-*/

const iop_iface_t *iop_mod_find_iface(const iop_mod_t *mod, uint32_t tag)
{
    size_t l = 0, r = mod->ifaces_len;

    while (l < r) {
        size_t  i = (l + r) / 2;
        const iop_iface_alias_t *alias = &mod->ifaces[i];

        if (tag == alias->tag) {
            return alias->iface;
        }
        if (tag < alias->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_iface_find_rpc(const iop_iface_t *iface, uint32_t tag)
{
    size_t l = 0, r = iface->funs_len;

    while (l < r) {
        size_t i = (l + r) / 2;
        const iop_rpc_t *rpc = &iface->funs[i];

        if (tag == rpc->tag) {
            return rpc;
        }
        if (tag < rpc->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_mod_find_rpc(const iop_mod_t *mod, uint32_t cmd)
{
    const iop_iface_t *iface = RETHROW_P(iop_mod_find_iface(mod, cmd >> 16));
    return iop_iface_find_rpc(iface, cmd & 0xffff);
}

/*------ introspection -}}}-*/
/*------ Signature -{{{-*/

static
lstr_t t_iop_sign_salt_sha256(const iop_struct_t *st, const void *v, uint32_t salt)
{
    uint8_t buf[SHA256_DIGEST_SIZE];
    be32_t  s = cpu_to_be32(salt);

    iop_hmac_sha256(st, v, LSTR_INIT_V((void *)&s, sizeof(s)), buf);
    return t_lstr_fmt("$256:%*pX$%*pX", (int)sizeof(s), &s,
                      SHA256_DIGEST_SIZE, buf);
}

lstr_t t_iop_compute_signature(const iop_struct_t *st, const void *v)
{
    return t_iop_sign_salt_sha256(st, v, ha_rand());
}

__must_check__
static int iop_signature_get_salt(lstr_t signature, be32_t *salt)
{
    if (lstr_startswith(signature, LSTR_IMMED_V("$256:"))) {
        if (signature.len != 5 + 8 + 1 + SHA256_DIGEST_SIZE * 2)
        {
#ifdef NDEBUG
            return -1;
#else
            return e_error("invalid $256 signature (invalid length)");
#endif
        }
        if (strconv_hexdecode(salt, sizeof(salt), signature.s + 5, 8) < 0
        ||  signature.s[5 + 8] != '$')
        {
#ifdef NDEBUG
            return -1;
#else
            return e_error("invalid $256 signature (invalid salt)");
#endif
        }
    } else {
#ifdef NDEBUG
        return -1;
#else
        return e_error("unparseable signature: <%*pM>",
                       LSTR_FMT_ARG(signature));
#endif
    }
    return 0;
}

int iop_check_signature(const iop_struct_t *st, const void *v, lstr_t sig)
{
    t_scope;
    lstr_t exp;
    be32_t salt;

#ifndef NDEBUG
    if (lstr_equal2(sig, LSTR_IMMED_V("$42:defeca7e$")))
        return 0;
#endif

    if (iop_signature_get_salt(sig, &salt) < 0) {
#ifdef NDEBUG
        return -1;
#else
        return e_error("error while getting salt");
#endif
    }

    exp = t_iop_sign_salt_sha256(st, v, be_to_cpu32(salt));
    if (!lstr_equal2(sig, exp)) {
#ifdef NDEBUG
        return -1;
#else
        return e_error("invalid signature (invalid value)");
#endif
    }

    return 0;
}

__attribute__((constructor))
static void iop_signature_initialize(void)
{
    ha_srand();
}

/*------ Signature -}}}-*/

iop_struct_t const iop__void__s = {
    .fullname   = LSTR_IMMED("Void"),
    .fields_len = 0,
    .size       = 0,
};
