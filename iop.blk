/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2015 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "arith.h"
#include "iop.h"
#include "iop-helpers.inl.c"
#include "thr.h"
#include "sort.h"

/*------ Local declarations -{{{-*/

typedef struct class_id_key_t {
    const iop_struct_t *master;
    uint16_t            child_id;
} class_id_key_t;

static inline uint32_t
class_id_key_hash(const qhash_t *h, const class_id_key_t *key)
{
    return mem_hash32(key, offsetof(class_id_key_t, child_id) + 2);
}
static inline bool
class_id_key_equal(const qhash_t *h, const class_id_key_t *k1,
                   const class_id_key_t *k2)
{
    return (k1->master == k2->master) && (k1->child_id == k2->child_id);
}

qm_kvec_t(class_id, class_id_key_t, const iop_struct_t *,
          class_id_key_hash, class_id_key_equal);

typedef struct class_name_key_t {
    const iop_struct_t *master;
    const lstr_t       *child_fullname;
} class_name_key_t;

static inline uint32_t
class_name_key_hash(const qhash_t *h, const class_name_key_t *key)
{
    return qhash_hash_ptr(h, key->master)
         ^ qhash_lstr_hash(h, key->child_fullname);
}
static inline bool
class_name_key_equal(const qhash_t *h, const class_name_key_t *k1,
                   const class_name_key_t *k2)
{
    return (k1->master == k2->master)
         && lstr_equal(k1->child_fullname, k2->child_fullname);
}

qm_kvec_t(class_name, class_name_key_t, const iop_struct_t *,
          class_name_key_hash, class_name_key_equal);

/*------ Local declarations -}}}-*/

static struct {
    qm_t(class_id)   classes_by_id;
    qm_t(class_name) classes_by_name;
    qm_t(iop_pkg)    pkgs_by_name;
} iop_g = {
#define _G  iop_g
    .classes_by_id   = QM_INIT(class_id,   _G.classes_by_id),
    .classes_by_name = QM_INIT(class_name, _G.classes_by_name),
    .pkgs_by_name    = QM_INIT(iop_pkg,    _G.pkgs_by_name),
};

/*------ various helpers -{{{-*/

static inline int
__iop_field_find_by_name2(const iop_struct_t *desc, const void *s, int len)
{
    const iop_field_t *field = desc->fields;

    for (int i = 0; i < desc->fields_len; i++) {
        if (len == field->name.len && !memcmp(field->name.s, s, len))
            return i;
        field++;
    }
    return -1;
}

int __iop_field_find_by_name(const iop_struct_t *st, const void *s, int len,
                             const iop_struct_t **found_st,
                             const iop_field_t  **found_fdesc)
{
    int acc = 0;
    bool is_class = iop_struct_is_class(st);

    do {
        int pos = __iop_field_find_by_name2(st, s, len);

        if (pos >= 0) {
            if (found_st) {
                *found_st = st;
            }
            if (found_fdesc) {
                *found_fdesc = st->fields + pos;
            }
            return acc + pos;
        }
        acc += st->fields_len;
    } while (is_class && (st = st->class_attrs->parent));

    return -1;
}

const iop_field_t *iop_get_field(const void *ptr, const iop_struct_t *st,
                                 lstr_t path, const void **out_ptr)
{
    pstream_t ps = ps_initlstr(&path);
    const iop_field_t *iop_field = NULL;

    while (!ps_done(&ps)) {
        pstream_t s;

        if (ps_get_ps_chr_and_skip(&ps, '.', &s) < 0) {
            s = ps;
            ps = ps_init(NULL, 0);
        }

        RETHROW_NP(__iop_field_find_by_name(st, s.s, ps_len(&s), NULL,
                                            &iop_field));
        ptr = (const byte *)ptr + iop_field->data_offs;
        switch (iop_field->type) {
          case IOP_T_UNION:
            if (iop_field->repeat == IOP_R_OPTIONAL
            ||  iop_field_is_reference(iop_field))
            {
                ptr = *(const void **)ptr;
            }
            st = iop_field->u1.st_desc;
            break;
          case IOP_T_STRUCT:
            if (iop_field->repeat == IOP_R_OPTIONAL
            ||  iop_field_is_class(iop_field)
            ||  iop_field_is_reference(iop_field))
            {
                ptr = *(const void **)ptr;
            }

            if (iop_field_is_class(iop_field)) {
                st = (iop_struct_t *)*(const void **)ptr;
            } else {
                st = iop_field->u1.st_desc;
            }
            break;
          default:
            if (iop_field_is_reference(iop_field)) {
                ptr = *(const void **)ptr;
            }
            THROW_NULL_IF(!ps_done(&ps));
            break;
        }
    }
    if (out_ptr) {
        *out_ptr = ptr;
    }
    return iop_field;
}

int iop_value_from_field(const void *ptr, const iop_field_t *field,
                         iop_value_t *value)
{
    THROW_ERR_IF(field->repeat == IOP_R_REPEATED);

    ptr = (byte *)ptr + field->data_offs;

#define GET_SCALAR(type, opt, f)                                             \
        if (field->repeat == IOP_R_OPTIONAL) {                               \
            const opt *o = ptr;                                              \
                                                                             \
            if (OPT_ISSET(*o)) {                                             \
                value->f = OPT_VAL(*o);                                      \
            } else {                                                         \
                return -1;                                                   \
            }                                                                \
        } else {                                                             \
            value->f = *(const type *)ptr;                                   \
        }

    switch (field->type) {
      case IOP_T_I8:
        GET_SCALAR(int8_t, opt_i8_t, i);
        return 0;

      case IOP_T_U8:
        GET_SCALAR(uint8_t, opt_u8_t, u);
        return 0;

      case IOP_T_I16:
        GET_SCALAR(int16_t, opt_i16_t, i);
        return 0;

      case IOP_T_U16:
        GET_SCALAR(uint16_t, opt_u16_t, u);
        return 0;

      case IOP_T_ENUM:
      case IOP_T_I32:
        GET_SCALAR(int32_t, opt_i32_t, i);
        return 0;

      case IOP_T_U32:
        GET_SCALAR(uint32_t, opt_u32_t, u);
        return 0;

      case IOP_T_I64:
        GET_SCALAR(int64_t, opt_i64_t, i);
        return 0;

      case IOP_T_U64:
        GET_SCALAR(uint64_t, opt_u64_t, u);
        return 0;

      case IOP_T_BOOL:
        GET_SCALAR(bool, opt_bool_t, b);
        return 0;

      case IOP_T_DOUBLE:
        GET_SCALAR(double, opt_double_t, d);
        return 0;

#undef GET_SCALAR

      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA: {
        const lstr_t *str = ptr;

        if (field->repeat == IOP_R_OPTIONAL && !str->s) {
            return -1;
        } else {
            value->s = lstr_dupc(*str);
        }
        return 0;
      }
      case IOP_T_STRUCT:
      case IOP_T_UNION: {
        if (iop_field_is_class(field)
        || iop_field_is_reference(field)
        || field->repeat == IOP_R_OPTIONAL)
        {
            ptr = *(const void **)ptr;
        }

        value->p = (void *)ptr;
        return 0;
      }
    }
    return -1;
}

int iop_value_to_field(void *ptr, const iop_field_t *field,
                       const iop_value_t *value)
{
    THROW_ERR_IF(field->repeat == IOP_R_REPEATED);

    ptr = (byte *)ptr + field->data_offs;

#define SET_SCALAR(type, opt, f)                                             \
        if (field->repeat == IOP_R_OPTIONAL) {                               \
            opt *o = ptr;                                                    \
                                                                             \
            OPT_SET(*o, value->f);                                           \
        } else {                                                             \
            *(type *)ptr = value->f;                                         \
        }

    switch (field->type) {
      case IOP_T_I8:
        SET_SCALAR(int8_t, opt_i8_t, i);
        return 0;

      case IOP_T_U8:
        SET_SCALAR(uint8_t, opt_u8_t, u);
        return 0;

      case IOP_T_I16:
        SET_SCALAR(int16_t, opt_i16_t, i);
        return 0;

      case IOP_T_U16:
        SET_SCALAR(uint16_t, opt_u16_t, u);
        return 0;

      case IOP_T_ENUM:
      case IOP_T_I32:
        SET_SCALAR(int32_t, opt_i32_t, i);
        return 0;

      case IOP_T_U32:
        SET_SCALAR(uint32_t, opt_u32_t, u);
        return 0;

      case IOP_T_I64:
        SET_SCALAR(int64_t, opt_i64_t, i);
        return 0;

      case IOP_T_U64:
        SET_SCALAR(uint64_t, opt_u64_t, u);
        return 0;

      case IOP_T_BOOL:
        SET_SCALAR(bool, opt_bool_t, b);
        return 0;

      case IOP_T_DOUBLE:
        SET_SCALAR(double, opt_double_t, d);
        return 0;

#undef SET_SCALAR

      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA: {
        lstr_t *str = ptr;

        if (field->repeat == IOP_R_OPTIONAL && !str->s) {
            return -1;
        } else {
            *str = lstr_dupc(value->s);
        }
        return 0;
      }
      case IOP_T_STRUCT:
      case IOP_T_UNION: {
        if (iop_field_is_class(field)
        || field->repeat == IOP_R_OPTIONAL
        || iop_field_is_reference(field))
        {
            *(void **)ptr = (void *)value->p;
        } else {
            memcpy(ptr, value->p, field->size);
        }

        return 0;
      }
    }
    return -1;
}

iop_struct_t *
iop_type_vector_to_iop_struct(mem_pool_t *mp, lstr_t fullname,
                              const qv_t(iop_field_info) *fields_info)
{
    iop_struct_t *st;
    iop_field_t *field;
    int *ranges;
    int data_offs = 0;
    int max_align = 1;
    int len = fields_info->len;
    int names_len = 0;
    char *names;

    if (!expect(len > 0)) {
        return mp_dup(mp, &iop__void__s, 1);
    }

    qv_for_each_ptr(iop_field_info, field_info, fields_info) {
        names_len += field_info->name.len;
    }

    /* single allocation for output iop_struct_t */
    st = mp_new_extra(mp, iop_struct_t, sizeof(iop_field_t) * len +
                      3 * sizeof(int) +
                      fullname.len * sizeof(char) +
                      names_len * sizeof(char));
    st->fields = (iop_field_t *)&st[1];
    st->ranges = (int *)&st->fields[len];
    ((lstr_t *)&st->fullname)->v = (char *)&st->ranges[3];
    names = st->fullname.v + fullname.len;

    /* fields */
    field = (iop_field_t *)st->fields;
    qv_for_each_ptr(iop_field_info, field_info, fields_info) {
        unsigned field_size = 1;
        int field_align = 1;
        iop_type_t type = field_info->type;

        switch (type) {
          case IOP_T_I8:
          case IOP_T_U8:
          case IOP_T_BOOL:
            field_size = 1;
            field_align = field_size;
            break;
          case IOP_T_I16:
          case IOP_T_U16:
            field_size = 2;
            field_align = field_size;
            break;
          case IOP_T_I32:
          case IOP_T_U32:
          case IOP_T_ENUM:
            field_size = 4;
            field_align = field_size;
            break;
          case IOP_T_I64:
          case IOP_T_U64:
          case IOP_T_DOUBLE:
            field_size = 8;
            field_align = field_size;
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            field_size = sizeof(lstr_t);
            field_align = alignof(lstr_t);
            break;
          case IOP_T_STRUCT:
          case IOP_T_UNION:
            field_size = field_info->u1.st_desc->size;
            field_align = field_size;
            break;
          default:
            /* type not handled */
            assert (0);
            break;
        }

        /* update alignement */
        data_offs   = ROUND_UP(data_offs, field_align);
        max_align   = MAX(max_align, field_align);

        /* update field attributes */
        *field = (iop_field_t){
            .name      = LSTR_NULL,
            .tag       = field - st->fields + 1,
            .tag_len   = 0,
            .repeat    = field_info->repeat,
            .type      = type,
            .size      = field_size,
            .data_offs = data_offs
        };

        /* set name */
        field->name.s = names;
        field->name.len = field_info->name.len;
        p_copy(field->name.v, field_info->name.v, field_info->name.len);
        names += field_info->name.len;

        if (type == IOP_T_STRUCT || type == IOP_T_UNION) {
            field->u1.st_desc = field_info->u1.st_desc;
        } else
        if (type == IOP_T_ENUM) {
            field->u1.en_desc = field_info->u1.en_desc;
        }

        /* next */
        data_offs += field_size;
        field++;
    }

    /* ranges */
    ranges = (int *)st->ranges;
    ranges[0] = 0;
    ranges[1] = 1;
    ranges[2] = len;

    /* build iop structure for record */
    memcpy((void *)st->fullname.s, fullname.s, fullname.len);
    *(int *)&st->fullname.len = fullname.len;

    st->fields_len = len;
    st->ranges_len = 1;
    st->size       = ROUND_UP(data_offs, max_align);

    return st;
}

/*------ various helpers -}}}-*/
/*------ iop type string description -{{{-*/

const char *iop_type_get_string_desc(iop_type_t type)
{
    switch (type) {
      case IOP_T_I8:
        return "byte";
      case IOP_T_I16:
        return "short";
      case IOP_T_I32:
        return "int";
      case IOP_T_I64:
        return "long";
      case IOP_T_U8:
        return "ubyte";
      case IOP_T_U16:
        return "ushort";
      case IOP_T_U32:
        return "uint";
      case IOP_T_U64:
        return "ulong";
      case IOP_T_BOOL:
        return "bool";
      case IOP_T_ENUM:
        return "enum";
      case IOP_T_DOUBLE:
        return "double";
      case IOP_T_STRING:
        return "string";
      case IOP_T_DATA:
        return "bytes";
      case IOP_T_UNION:
        return "union";
      case IOP_T_STRUCT:
        return "struct";
      case IOP_T_XML:
        return "xml";
    }
    e_panic("iop_type unsupported");
}

/*------ iop type string description -}}}-*/
/*------ generic attributes -{{{-*/

#define ATTR_IS_GENERIC(_attr, _what)                                        \
    (_attr->type == IOP_##_what##_GEN_ATTR_S                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_O                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_I                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_D)

#define __get_gen_attr_value(_attrs, _len, _key, _what, _what_l, _val)     \
    ({                                                                     \
        int _res = -1;                                                     \
                                                                           \
        for (int _i = 0; _i < _len; _i++) {                                \
            const iop_##_what_l##_attr_t *_attr = _attrs + _i;             \
                                                                           \
            if (!ATTR_IS_GENERIC(_attr, _what)                             \
            ||  !lstr_equal2(_key, _attr->args[0].v.s))                    \
            {                                                              \
                continue;                                                  \
            }                                                              \
                                                                           \
            _res = 0;                                                      \
                                                                           \
            switch (_attr->type) {                                         \
              case IOP_##_what##_GEN_ATTR_O:                               \
              case IOP_##_what##_GEN_ATTR_S:                               \
                _val->s = _attr->args[1].v.s;                              \
                break;                                                     \
              case IOP_##_what##_GEN_ATTR_I:                               \
                _val->i64 = _attr->args[1].v.i64;                          \
                break;                                                     \
              case IOP_##_what##_GEN_ATTR_D:                               \
                _val->d = _attr->args[1].v.d;                              \
                break;                                                     \
              default:                                                     \
                assert (false);                                            \
            }                                                              \
            break;                                                         \
        }                                                                  \
                                                                           \
        _res;                                                              \
    })

int iop_struct_get_gen_attr(const iop_struct_t *st, lstr_t key,
                            iop_value_t *value)
{
    unsigned flags = st->flags;

    if (!TST_BIT(&flags, IOP_STRUCT_EXTENDED) || !st->st_attrs) {
        return -1;
    }
    return __get_gen_attr_value(st->st_attrs->attrs, st->st_attrs->attrs_len,
                                key, STRUCT, struct, value);
}

int iop_enum_get_gen_attr(const iop_enum_t *en, lstr_t key,
                          iop_value_t *value)
{
    if (!TST_BIT(&en->flags, IOP_ENUM_EXTENDED) || !en->en_attrs) {
        return -1;
    }
    return __get_gen_attr_value(en->en_attrs->attrs, en->en_attrs->attrs_len,
                                key, ENUM, enum, value);
}

static int iop_enum_pos_from_val(const iop_enum_t *e, int val);
static int iop_enum_pos_from_str(const iop_enum_t *e, const char *s, int len);

int iop_enum_get_gen_attr_from_val(const iop_enum_t *ed, int val,
                                   lstr_t key, iop_value_t *value)
{
    const iop_enum_value_attrs_t *va;
    int pos;

    if (!TST_BIT(&ed->flags, IOP_ENUM_EXTENDED) || !ed->values_attrs) {
        return -1;
    }
    pos = RETHROW(iop_enum_pos_from_val(ed, val));
    va = &ed->values_attrs[pos];
    return __get_gen_attr_value(va->attrs, va->attrs_len, key, ENUM_VALUE,
                                enum_value, value);
}

int iop_enum_get_gen_attr_from_str(const iop_enum_t *ed, lstr_t val,
                                   lstr_t key, iop_value_t *value)
{
    const iop_enum_value_attrs_t *va;
    int pos;

    if (!TST_BIT(&ed->flags, IOP_ENUM_EXTENDED) || !ed->values_attrs) {
        return -1;
    }
    pos = RETHROW(iop_enum_pos_from_str(ed, val.s, val.len));
    va = &ed->values_attrs[pos];
    return __get_gen_attr_value(va->attrs, va->attrs_len, key, ENUM_VALUE,
                                enum_value, value);
}

int iop_iface_get_gen_attr(const iop_iface_t *iface, lstr_t key,
                           iop_value_t *value)
{
    if (!TST_BIT(&iface->flags, IOP_IFACE_HAS_ATTRS) || !iface->iface_attrs) {
        return -1;
    }
    return __get_gen_attr_value(iface->iface_attrs->attrs,
                                iface->iface_attrs->attrs_len, key, IFACE,
                                iface, value);
}

int iop_rpc_get_gen_attr(const iop_iface_t *iface, const iop_rpc_t *rpc,
                         lstr_t key, iop_value_t *value)
{
    const iop_rpc_attrs_t *attrs = RETHROW_PN(iop_rpc_get_attrs(iface, rpc));

    return __get_gen_attr_value(attrs->attrs, attrs->attrs_len, key, RPC,
                                rpc, value);
}

int iop_field_get_gen_attr(const iop_struct_t *st, const iop_field_t *field,
                           lstr_t key, iop_value_t *value)
{
    const iop_field_attrs_t *attrs = RETHROW_PN(iop_field_get_attrs(st,
                                                                    field));

    return __get_gen_attr_value(attrs->attrs, attrs->attrs_len, key, FIELD,
                                field, value);
}

int iop_field_by_name_get_gen_attr(const iop_struct_t *st, lstr_t f_name,
                                   lstr_t key, iop_value_t *value)
{
    int pos = RETHROW(__iop_field_find_by_name2(st, f_name.s, f_name.len));
    const iop_field_t *field = st->fields + pos;

    return iop_field_get_gen_attr(st, field, key, value);
}

/*------ generic attributes -}}}-*/
/*------ iop_init / iop_new -{{{-*/

static void
iop_init_fields(void *value, const iop_field_t *fdesc, const iop_field_t *end)
{
    for (; fdesc < end; fdesc++) {
        void *ptr = (char *)value + fdesc->data_offs;

        if (fdesc->repeat == IOP_R_REQUIRED && fdesc->type == IOP_T_STRUCT) {
            /* We can't handle the unions here since we don't know which field
             * has been selected */
            const iop_struct_t *desc = fdesc->u1.st_desc;

            if (iop_field_is_reference(fdesc) || iop_field_is_class(fdesc)) {
                /* Field is a mandatory class instance, and should be init as
                 * an optional field: NULL pointer. */
                continue;
            }

            iop_init_fields(ptr, desc->fields, desc->fields +
                            desc->fields_len);
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            switch (fdesc->type) {
              case IOP_T_I8: case IOP_T_U8:
                *(uint8_t *)ptr  = fdesc->u1.defval_u64;
                break;
              case IOP_T_I16: case IOP_T_U16:
                *(uint16_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_ENUM:
                *(uint32_t *)ptr = fdesc->u0.defval_enum;
                break;
              case IOP_T_I32: case IOP_T_U32:
                *(uint32_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_I64: case IOP_T_U64:
                *(uint64_t *)ptr = fdesc->u1.defval_u64;
                break;
              case IOP_T_BOOL:
                *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
                break;
              case IOP_T_DOUBLE:
                *(double *)ptr   = fdesc->u1.defval_d;
                break;
              case IOP_T_STRING:
              case IOP_T_XML:
                *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data, fdesc->u0.defval_len);
                break;
              case IOP_T_DATA:
                ((lstr_t *)ptr)->len      = fdesc->u0.defval_len;
                ((lstr_t *)ptr)->data     = (void *)fdesc->u1.defval_data;
                ((lstr_t *)ptr)->mem_pool = 0;
                break;
              default:
                e_panic("unsupported");
                continue;
            }
        }
    }
}
void iop_init(const iop_struct_t *desc, void *value)
{
    memset(value, 0, desc->size);

    if (iop_struct_is_class(desc)) {
        const iop_struct_t **__vptr = value;
        const iop_struct_t *parent = desc;

        e_assert(panic, !desc->class_attrs->is_abstract,
                 "initialization of abstract class '%*pM' is forbidden",
                 LSTR_FMT_ARG(desc->fullname));

        *__vptr = desc;

        while ((parent = parent->class_attrs->parent)) {
            iop_init_fields(value, parent->fields,
                            parent->fields + parent->fields_len);
        }
    }

    iop_init_fields(value, desc->fields, desc->fields + desc->fields_len);
}

void *mp_iop_new_desc(mem_pool_t *mp, const iop_struct_t *st)
{
    void *res = mp_imalloc(mp, st->size, 8, MEM_RAW);

    iop_init(st, res);

    return res;
}

/*------ iop_init -}}}-*/
/*----- duplicating values -{{{-*/

static size_t iop_dup_size(const iop_struct_t *desc, const void *val);

static size_t __iop_dup_size(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    size_t len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        bool is_class = iop_field_is_class(fdesc);
        bool is_ref   = iop_field_is_reference(fdesc);
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n    = ((lstr_t *)ptr)->len;
            ptr  = ((lstr_t *)ptr)->data;
            len += ROUND_UP(n * fdesc->size, 8);
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                ptr = *(void **)ptr;
                if (is_class) {
                    /* Do not take the field size, but the size of the
                     * actually instanciated class */
                    len += ROUND_UP((*(const iop_struct_t **)ptr)->size, 8);
                } else {
                    len += ROUND_UP(fdesc->size, 8);
                }
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional reference fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    v = *(void **)v;
                    if (is_class) {
                        len += ROUND_UP((*(const iop_struct_t **)v)->size, 8);
                    }
                }
                if (is_class) {
                    len += iop_dup_size(fdesc->u1.st_desc, v);
                } else {
                    if (is_ref) {
                        len += ROUND_UP(fdesc->size, 8);
                    }
                    len += __iop_dup_size(fdesc->u1.st_desc, v);
                }
            }
        } else {
            for (int j = 0; j < n; j++) {
                len += ROUND_UP(IOP_FIELD(lstr_t, ptr, j).len + 1, 8);
            }
        }
    }

    return len;
}

static size_t iop_dup_size(const iop_struct_t *desc, const void *val)
{
    if (iop_struct_is_class(desc)) {
        size_t len = 0;

        desc = *(const iop_struct_t **)val;
        do {
            len += __iop_dup_size(desc, val);
        } while ((desc = desc->class_attrs->parent));

        return len;
    } else {
        return __iop_dup_size(desc, val);
    }
}

static uint8_t *realign(uint8_t *ptr)
{
    return (uint8_t *)ROUND_UP((uintptr_t)ptr, 8);
}

static uint8_t *__iop_copy_class(const iop_struct_t *st, uint8_t *dst,
                                 void *wval, const void *rval);

static uint8_t *
__iop_copy(const iop_struct_t *st, uint8_t *dst, void *wval, const void *rval)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        fdesc = get_union_field(st, rval);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *rp = (char *)rval + fdesc->data_offs;
        const void *wp = (char *)wval + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n = ((lstr_t *)rp)->len;
            if (n) {
                rp  = ((lstr_t *)rp)->data;
                wp  = ((lstr_t *)wp)->data = dst;
                dst = realign(mempcpy(dst, rp, n * fdesc->size));
            } else {
                ((lstr_t *)wp)->data = NULL;
                wp  = dst;
                dst = realign(dst);
            }
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, rp))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                rp = *(void **)rp;
                wp = *(void **)wp = dst;
                if (!iop_field_is_class(fdesc)) {
                    /* Will be done in __iop_copy_class for classes */
                    dst = realign(mempcpy(dst, rp, fdesc->size));
                }
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);

            for (int j = 0; j < n; j++) {
                const void *rv = &IOP_FIELD(const char, rp, j * fdesc->size);
                void       *wv = &IOP_FIELD(char,       wp, j * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional referenced fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    rv = *(void **)rv;
                    wv = *(void **)wv = dst;
                }
                if (is_class) {
                    dst = __iop_copy_class(fdesc->u1.st_desc, dst, wv, rv);
                } else {
                    if (is_ref) {
                        /* Will be done in __iop_copy_class for classes */
                        dst = realign(mempcpy(dst, rv, fdesc->size));
                    }
                    dst = __iop_copy(fdesc->u1.st_desc, dst, wv, rv);
                }
            }
        } else
        if (fdesc->type == IOP_T_STRING || fdesc->type == IOP_T_XML) {
            for (int j = 0; j < n; j++) {
                lstr_t *orig = &IOP_FIELD(lstr_t, rp, j);

                /* We have to fix the lstr_t mem_pool manually because some
                 * naughty programmers could have played with it */
                IOP_FIELD(lstr_t, wp, j).s = (const char *)dst;
                IOP_FIELD(lstr_t, wp, j).mem_pool = MEM_STATIC;
                dst = realign(mempcpyz(dst, orig->s, orig->len));
            }
        } else {
            for (int j = 0; j < n; j++) {
                lstr_t *orig = &IOP_FIELD(lstr_t, rp, j);

                IOP_FIELD(lstr_t, wp, j).data = dst;
                dst = realign(mempcpyz(dst, orig->data, orig->len));
            }
        }
    }

    return dst;
}

static uint8_t *__iop_copy_class(const iop_struct_t *st, uint8_t *dst,
                                 void *wval, const void *rval)
{
    st = *(const iop_struct_t **)rval;
    dst = realign(mempcpy(dst, rval, st->size));

    do {
        dst = __iop_copy(st, dst, wval, rval);
    } while ((st = st->class_attrs->parent));

    return dst;
}

void *iop_dup(mem_pool_t *mp, const iop_struct_t *st, const void *v,
              size_t *psz)
{
    bool is_class;
    size_t sz;
    uint8_t *dst, *res;

    RETHROW_P(v);

    if ((is_class = iop_struct_is_class(st))) {
        st = *(const iop_struct_t **)v;
        sz = ROUND_UP(st->size, 8) + iop_dup_size(st, v);
    } else {
        sz = ROUND_UP(st->size, 8) + __iop_dup_size(st, v);
    }
    if (psz) {
        *psz = sz;
    }

    res = mp_imalloc(mp, sz, 8, MEM_RAW);
    dst = realign(mempcpy(res, v, st->size));

    if (is_class) {
        do {
            dst = __iop_copy(st, dst, res, v);
        } while ((st = st->class_attrs->parent));
    } else {
        dst = __iop_copy(st, dst, res, v);
    }

    assert (dst == res + sz);
    return res;
}

void iop_copy(mem_pool_t *mp, const iop_struct_t *st, void **outp,
              const void *v, size_t *psz)
{
    bool is_class;
    size_t sz;
    uint8_t *dst, *res = *outp;

    if (unlikely(!v)) {
        mp_delete(mp, outp);
        return;
    }

    if ((is_class = iop_struct_is_class(st))) {
        st = *(const iop_struct_t **)v;
        sz = ROUND_UP(st->size, 8) + iop_dup_size(st, v);
    } else {
        sz = ROUND_UP(st->size, 8) + __iop_dup_size(st, v);
    }

    if (psz) {
        *psz = sz;
    }

    res = mp_irealloc(mp, res, 0, sz, 8, MEM_RAW);
    dst = realign(mempcpy(res, v, st->size));

    if (is_class) {
        do {
            dst = __iop_copy(st, dst, res, v);
        } while ((st = st->class_attrs->parent));
    } else {
        dst = __iop_copy(st, dst, res, v);
    }

    assert (dst == res + sz);
    *outp = res;
}

void iop_obj_copy(mem_pool_t *mp, void *out, const void *v, unsigned flags)
{
    size_t offset = sizeof(iop_struct_t *);
    const iop_struct_t *v_desc = *(const iop_struct_t **)v;

    assert (iop_obj_is_a_desc(out, v_desc));

    if (flags & IOP_OBJ_DEEP_COPY) {
        assert (0 && "DEEP COPY UNIMPLEMENTED");
    }

    memcpy((char *)out + offset, (const char *)v + offset,
           v_desc->size - offset);
}

/*----- duplicating values -}}}-*/
/*----- comparing values -{{{-*/

static bool
__iop_equals(const iop_struct_t *st, const uint8_t *v1, const uint8_t *v2)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        if (*(uint16_t *)v1 != *(uint16_t *)v2)
            return false;
        fdesc = get_union_field(st, v1);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r1 = v1 + fdesc->data_offs;
        const void *r2 = v2 + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            /* Here we just check the length of the repeated field, then we
             * position our pointers on values to compare them later. */
            n   = ((lstr_t *)r1)->len;
            if (((lstr_t *)r2)->len != n)
                return false;
            r1  = ((lstr_t *)r1)->data;
            r2  = ((lstr_t *)r2)->data;
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            /* Optional blocks types cannot be compared using a single memcmp
             * we need to handle absent values first. */
            bool has = iop_value_has(fdesc, r1);

            if (has != iop_value_has(fdesc, r2))
                return false;
            if (!has)
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                /* Structures & unions must be dereferenced */
                r1  = *(void **)r1;
                r2  = *(void **)r2;
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);

            /* We need to recurse to compare structures & unions. */
            for (int i = 0; i < n; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done just
                     *  above).
                     */
                    t1  = *(void **)t1;
                    t2  = *(void **)t2;
                }
                if (is_class) {
                    THROW_IF(!iop_equals(fdesc->u1.st_desc, t1, t2), false);
                } else {
                    THROW_IF(!__iop_equals(fdesc->u1.st_desc, t1, t2), false);
                }
            }
        } else
        if ((1 << fdesc->type) & IOP_BLK_OK) {
            /* Blocks (string & co) must be compared one by one */
            for (int i = 0; i < n; i++) {
                const lstr_t *t1 = &IOP_FIELD(const lstr_t, r1, i);
                const lstr_t *t2 = &IOP_FIELD(const lstr_t, r2, i);

                if (t1->len != t2->len || memcmp(t1->data, t2->data, t1->len))
                    return false;
            }
        } else {
            assert (fdesc->size > 0 && "IOPC is probably outdated");
            if (!iop_scalar_equals(fdesc, r1, r2, n))
                return false;
        }
    }

    return true;
}

bool iop_equals(const iop_struct_t *st, const void *v1, const void *v2)
{
    if (v1 && v2) {
        if (iop_struct_is_class(st)) {
            const iop_struct_t *st2 = *(const iop_struct_t **)v2;

            st = *(const iop_struct_t **)v1;
            if (st != st2) {
                return false;
            }

            do {
                if (!__iop_equals(st, v1, v2)) {
                    return false;
                }
            } while ((st = st->class_attrs->parent));

            return true;
        }

        return __iop_equals(st, v1, v2);
    } else {
        return v1 == v2;
    }
}

/*----- comparing values -}}}-*/
/*----- sorting values -{{{-*/

/* {{{ Field path */

typedef struct field_step_t {
    uint16_t offset;
    uint16_t union_tag;
    flag_t   is_union   : 1;
} field_step_t;
GENERIC_INIT(field_step_t, field_step);

qvector_t(field_step, field_step_t);

typedef struct field_path_t {
    qv_t(field_step)    steps;
    const iop_field_t  *fdesc;
} field_path_t;
GENERIC_FUNCTIONS(field_path_t, field_path);

/* {{{ Get */

static const void *
iop_get_fieldp(const void *data, const field_path_t *field_path)
{
    const qv_t(field_step)  *steps = &field_path->steps;
    const iop_field_t       *fdesc = field_path->fdesc;

    RETHROW_P(data);

    for (int i = 0; i < steps->len - 1; i++) {
        field_step_t *step = &steps->tab[i];

        data = ((const byte *)data) + step->offset;

        if (step->is_union) {
            /* Check if the selected member of the union is the one we want
             * (the one specified in field_path), and if not this object is
             * considered as NULL in the sort */
            if (*(const uint16_t *)data != step->union_tag) {
                return NULL;
            }
        } else {
            /* Pointed structure or union (optional), or classes */
            data = RETHROW_P(*((void **)data));
        }
    }

    data = ((const byte *)data) + qv_last(field_step, steps)->offset;

    /* XXX we sort union based on the union tag */
    if (fdesc->type == IOP_T_UNION) {
        return (const uint16_t *)data;
    }

    if (fdesc->repeat != IOP_R_OPTIONAL) {
        return data;
    }

    switch (fdesc->type) {
      case IOP_T_I8:
      case IOP_T_U8:
        return OPT_GET((const opt_u8_t *)data);
      case IOP_T_I16:
      case IOP_T_U16:
        return OPT_GET((const opt_u16_t *)data);
      case IOP_T_ENUM:
      case IOP_T_I32:
      case IOP_T_U32:
        return OPT_GET((const opt_u32_t *)data);
      case IOP_T_I64:
      case IOP_T_U64:
        return OPT_GET((const opt_u64_t *)data);
      case IOP_T_BOOL:
        return OPT_GET((const opt_bool_t *)data);
      case IOP_T_DOUBLE:
        return OPT_GET((const opt_double_t *)data);
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        return ((const lstr_t *)data)->s ? data : NULL;
      default:
        assert (false);
        return NULL;
    }
}

/* }}} */
/* {{{ Compile */

static int
t_iop_compile_field_path(const iop_struct_t *st, lstr_t field_path_s,
                         field_path_t *fp, sb_t *err)
{
    const iop_field_t *fdesc = NULL;
    pstream_t field_path_ps = ps_initlstr(&field_path_s);
    const iop_struct_t *it = st;
    field_step_t *step;

    if (ps_done(&field_path_ps)) {
        if (err) {
            sb_adds(err, "cannot process empty field path");
        }
        return -1;
    }
    step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
    while (!ps_done(&field_path_ps)) {
        pstream_t fname;

        if (ps_get_ps_chr_and_skip(&field_path_ps, '.', &fname) < 0) {
            fname = field_path_ps;
            __ps_skip_upto(&field_path_ps, field_path_ps.p_end);
        }

        if (ps_done(&fname)) {
            if (err) {
                sb_addf(err, "cannot process field path `%*pM' "
                        "abnormal termination",
                        LSTR_FMT_ARG(field_path_s));
            }
            return -1;
        }

        if (__iop_field_find_by_name(it, fname.s, ps_len(&fname),
                                     NULL, &fdesc) < 0)
        {
            if (err) {
                sb_addf(err, "cannot process field path `%*pM', "
                        "field `%*pM' is unknown in structure `%*pM'",
                        LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname),
                        LSTR_FMT_ARG(it->fullname));
            }
            return -1;
        }

        if (fdesc->repeat == IOP_R_REPEATED) {
            /* XXX we could also sort the repeated fields based on their
             * number of elements
             */
            if (err) {
                sb_addf(err, "cannot process field path `%*pM', "
                        "field `%*pM' is repeated in structure `%*pM'",
                        LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname),
                        LSTR_FMT_ARG(it->fullname));
            }
            return -1;
        }
        if (it->is_union) {
            step->is_union = true;
            step->union_tag = fdesc->tag;
            step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
        }

        step->offset += fdesc->data_offs;
        if (fdesc->type == IOP_T_STRUCT || fdesc->type == IOP_T_UNION) {
            it = fdesc->u1.st_desc;

            if (fdesc->repeat == IOP_R_OPTIONAL
            ||  iop_field_is_class(fdesc)
            ||  iop_field_is_reference(fdesc))
            {
                step = field_step_init(qv_growlen(field_step, &fp->steps, 1));
            }
        }
    }

    fp->fdesc = fdesc;

    return 0;
}

/* }}} */
/* }}} */
/* {{{ cmp functions */

static cmp_f const iop_cmp_funs[] = {
    [IOP_T_I8]          = &cmp_i8,
    [IOP_T_U8]          = &cmp_u8,
    [IOP_T_I16]         = &cmp_i16,
    [IOP_T_U16]         = &cmp_u16,
    [IOP_T_ENUM]        = &cmp_i32,
    [IOP_T_I32]         = &cmp_i32,
    [IOP_T_U32]         = &cmp_u32,
    [IOP_T_I64]         = &cmp_i64,
    [IOP_T_U64]         = &cmp_u64,
    [IOP_T_BOOL]        = &cmp_bool,
    [IOP_T_DOUBLE]      = &cmp_double,
    [IOP_T_UNION]       = &cmp_u16,
    [IOP_T_STRING]      = &cmp_lstr_iutf8,
    [IOP_T_XML]         = &cmp_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_lstr_iutf8,
};
static cmp_f const iop_cmp_rev_funs[] = {
    [IOP_T_I8]          = &cmp_rev_i8,
    [IOP_T_U8]          = &cmp_rev_u8,
    [IOP_T_I16]         = &cmp_rev_i16,
    [IOP_T_U16]         = &cmp_rev_u16,
    [IOP_T_ENUM]        = &cmp_rev_i32,
    [IOP_T_I32]         = &cmp_rev_i32,
    [IOP_T_U32]         = &cmp_rev_u32,
    [IOP_T_I64]         = &cmp_rev_i64,
    [IOP_T_U64]         = &cmp_rev_u64,
    [IOP_T_BOOL]        = &cmp_rev_bool,
    [IOP_T_DOUBLE]      = &cmp_rev_double,
    [IOP_T_UNION]       = &cmp_rev_u16,
    [IOP_T_STRING]      = &cmp_rev_lstr_iutf8,
    [IOP_T_XML]         = &cmp_rev_lstr_iutf8,
    [IOP_T_DATA]        = &cmp_rev_lstr_iutf8,
};

/*}}}*/

typedef struct iop_sort_priv_t {
    field_path_t fp;
    int flags;
    cmp_f cmp;
} iop_sort_priv_t;

qvector_t(iop_sort_p, iop_sort_priv_t);

static
int t_prepare_field(const iop_struct_t *st, const iop_sort_t *sort,
                    iop_sort_priv_t *priv, sb_t *err)
{
    field_path_init(&priv->fp);
    t_qv_init(field_step, &priv->fp.steps, 16);
    RETHROW(t_iop_compile_field_path(st, sort->field_path, &priv->fp, err));

    if (priv->fp.fdesc == NULL) {
        if (err) {
            sb_addf(err, "no description for field `%*pM' "
                    "in the structure `%*pM'",
                    LSTR_FMT_ARG(sort->field_path),
                    LSTR_FMT_ARG(st->fullname));
        }
        return -1;
    }
    if (priv->fp.fdesc->type == IOP_T_STRUCT) {
        if (err) {
            sb_addf(err, "cannot sort on sub-structure `%*pM'",
                    LSTR_FMT_ARG(sort->field_path));
        }
        return -1;
    }

    priv->flags = sort->flags;
    if (priv->flags & IOP_SORT_REVERSE) {
        priv->cmp = iop_cmp_rev_funs[priv->fp.fdesc->type];
    } else {
        priv->cmp = iop_cmp_funs[priv->fp.fdesc->type];
    }
    return 0;
}

static
int compare_field(const void *d1, const void *d2, const iop_sort_priv_t *priv)
{
    d1 = iop_get_fieldp(d1, &priv->fp);
    d2 = iop_get_fieldp(d2, &priv->fp);
    if (d1 == d2)
        return 0;
    if (d1 == NULL)
        return (priv->flags & IOP_SORT_NULL_FIRST) ? -1 : 1;
    if (d2 == NULL)
        return (priv->flags & IOP_SORT_NULL_FIRST) ? 1 : -1;
    return priv->cmp(d1, d2);
}

int iop_msort(const iop_struct_t *st, void *vec, int len,
              const qv_t(iop_sort) *params, sb_t *err)
{
    t_scope;
    bool is_class = iop_struct_is_class(st);
    qv_t(iop_sort_p) sorts;

    t_qv_init(iop_sort_p, &sorts, params->len);
    qv_growlen(iop_sort_p, &sorts, params->len);
    qv_for_each_pos(iop_sort, pos, params) {
        RETHROW(t_prepare_field(st, &params->tab[pos], &sorts.tab[pos], err));
    }

    __qv_sort(vec, is_class ? sizeof(void *) : st->size, len,
        ^int (const void *d1, const void *d2) {
            if (is_class) {
                d1 = *(void **)d1;
                d2 = *(void **)d2;
            }

            qv_for_each_ptr(iop_sort_p, sort, &sorts) {
                int ret = compare_field(d1, d2, sort);

                if (ret) {
                    return ret;
                }
            }
            return 0;
        });

    return 0;
}

int iop_sort(const iop_struct_t *st, void *vec, int len,
             lstr_t field_path, int flags, sb_t *err)
{
    qv_t(iop_sort) params;
    iop_sort_t param = {
        .field_path = field_path,
        .flags = flags,
    };

    qv_init_static(iop_sort, &params, &param, 1);
    return iop_msort(st, vec, len, &params, err);
}

/* }}} */
/*----- hashing values -{{{-*/

#define ATTRS
#define F(x)  x
#include "iop-hashing-values.in.c"
#undef F
#undef ATTRS

/*----- duplicating values -}}}-*/
/*----- check constraints before packing -{{{-*/

static __thread sb_t iop_err_g;

__attribute__((constructor))
static void iop_init_err(void)
{
    if (unlikely(iop_err_g.size == 0))
        sb_init(&iop_err_g);
}

static void iop_wipe_err(void)
{
    if (iop_err_g.size)
        sb_wipe(&iop_err_g);
}

thr_hooks(iop_init_err, iop_wipe_err);

void iop_set_verr(const char *fmt, va_list ap)
{
    sb_setvf(&iop_err_g, fmt, ap);
}

int iop_set_err(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    iop_set_verr(fmt, ap);
    va_end(ap);
    return -1;
}

int iop_set_err2(const lstr_t *s)
{
    sb_set(&iop_err_g, s->s, s->len);
    return -1;
}

void iop_clear_err(void)
{
    sb_reset(&iop_err_g);
}

const char *iop_get_err(void)
{
    if (iop_err_g.len)
        return iop_err_g.data;
    return NULL;
}

lstr_t iop_get_err_lstr(void)
{
    if (iop_err_g.len)
        return LSTR_INIT_V(iop_err_g.data, iop_err_g.len);
    return LSTR_NULL_V;
}

int __iop_check_constraints(const iop_struct_t *desc, const void *val);

int iop_field_check_constraints(const iop_struct_t *desc, const iop_field_t
                                *fdesc, const void *ptr, int n, bool recurse)
{
    check_constraints_f check_constraints = NULL;

    if ((check_constraints = iop_field_get_constraints_cb(desc, fdesc))) {
        RETHROW(check_constraints(ptr, n));
    }
    switch (fdesc->type) {
      case IOP_T_ENUM:
        if (TST_BIT(&fdesc->u1.en_desc->flags, IOP_ENUM_STRICT)) {
            const iop_enum_t *en_desc = fdesc->u1.en_desc;

            for (int j = 0; j < n; j++) {
                int32_t intval = IOP_FIELD(int32_t, ptr, j);

                if (iop_ranges_search(en_desc->ranges,
                                      en_desc->ranges_len, intval) != -1)
                {
                    continue;
                }
                return iop_set_err("%d is not a valid value for enum %*pM",
                                   intval, LSTR_FMT_ARG(en_desc->fullname));
            }
        }
        break;

      case IOP_T_I8:
      case IOP_T_U8:
      case IOP_T_I16:
      case IOP_T_U16:
      case IOP_T_I32:
      case IOP_T_U32:
      case IOP_T_I64:
      case IOP_T_U64:
      case IOP_T_BOOL:
      case IOP_T_DOUBLE:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        break;

      case IOP_T_UNION:
      case IOP_T_STRUCT:
      default: {
        bool is_class;
        bool is_ref;

        if (!recurse) {
            return 0;
        }

        is_class = iop_field_is_class(fdesc);
        is_ref   = iop_field_is_reference(fdesc);
        for (int j = 0; j < n; j++) {
            const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

            if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                /* Non-optional class fields have to be dereferenced
                 * (dereferencing of optional fields was already done
                 *  by the caller).
                 */
                v = *(void **)v;
            }
            if (is_class) {
                RETHROW(iop_check_constraints(fdesc->u1.st_desc, v));
            } else {
                RETHROW(__iop_check_constraints(fdesc->u1.st_desc, v));
            }
        }
        break;
      }
    }

    return 0;
}

int __iop_check_constraints(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    unsigned           desc_flags = desc->flags;

    if (!TST_BIT(&desc_flags, IOP_STRUCT_HAS_CONSTRAINTS))
        return 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0) {
                unsigned fdesc_flags = fdesc->flags;

                if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
                    iop_set_err("empty array not allowed for field `%*pM`",
                                LSTR_FMT_ARG(fdesc->name));
                    return -1;
                }
                continue;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field if it's still equal to its default value */
            if (iop_field_is_defval(fdesc, ptr, true))
                continue;
        }

        RETHROW(iop_field_check_constraints(desc, fdesc, ptr, n, true));
    }

    return 0;
}

int iop_check_constraints(const iop_struct_t *desc, const void *val)
{
    if (iop_struct_is_class(desc)) {
        desc = *(const iop_struct_t **)val;

        if (unlikely(desc->class_attrs->is_abstract)) {
            return iop_set_err("'%*pM' is an abstract class",
                               LSTR_FMT_ARG(desc->fullname));
        }

        do {
            RETHROW(__iop_check_constraints(desc, val));
        } while ((desc = desc->class_attrs->parent));

        return 0;
    } else {
        return __iop_check_constraints(desc, val);
    }
}

/*-}}}-*/
/*----- get value encoding size -{{{-*/

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  const unsigned flags, qv_t(i32) *szs);

static int __iop_bpack_size(const iop_struct_t *desc, const void *val,
                            const unsigned flags, qv_t(i32) *szs)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    int len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(fdesc, ptr))
                continue;
            if ((1 << fdesc->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0)
                continue;
            if (n > 1) {
                if ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    int32_t i32 = n * fdesc->size;

                    len += 1 + fdesc->tag_len;
                    len += get_len_len(i32) + i32;
                    continue;
                }
                /* Add:
                 * - 4 to encode the len on 32 bits,
                 * - n because there will be n tags 0 to separate elements.
                 */
                len += 4 + n;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field if still equals to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&   iop_field_is_defval(fdesc, ptr, true))
            {
                continue;
            }
        }

        len += 1 + fdesc->tag_len;
        switch (fdesc->type) {
          case IOP_T_I8:
            len += n;
            break;
          case IOP_T_U8:
            len += n;
            for (int j = 0; j < n; j++)
                len += IOP_FIELD(uint8_t, ptr, j) >> 7;
            break;
          case IOP_T_I16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int16_t, ptr, j));
            break;
          case IOP_T_U16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(uint16_t, ptr, j));
            break;
          case IOP_T_I32:
          case IOP_T_ENUM:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int32_t, ptr, j));
            break;
          case IOP_T_U32:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(uint32_t, ptr, j));
            break;
          case IOP_T_I64:
          case IOP_T_U64:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(int64_t, ptr, j));
            break;
          case IOP_T_BOOL:
            len += n;
            break;
          case IOP_T_DOUBLE:
            len += n * 8;
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            for (int j = 0; j < n; j++) {
                int32_t i32 = IOP_FIELD(lstr_t, ptr, j).len;
                len += get_len_len(i32 + 1) + i32 + 1;
            }
            break;

          case IOP_T_UNION:
          case IOP_T_STRUCT:
          default: {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);

            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);
                int32_t offs = szs->len, i32;

                qv_growlen(i32, szs, 1);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    v = *(void **)v;
                }
                if (is_class) {
                    i32 = __iop_bpack_size_class(fdesc->u1.st_desc, v, flags,
                                                 szs);
                } else {
                    i32 = __iop_bpack_size(fdesc->u1.st_desc, v, flags, szs);
                }

                szs->tab[offs] = i32;
                len += get_len_len(i32) + i32;
            }
            break;
          }
        }
    }

    return len;
}

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  const unsigned flags, qv_t(i32) *szs)
{
    int size = 0, level_size;
    bool first = true;

    desc = *(const iop_struct_t **)val;

    e_assert(panic, !desc->class_attrs->is_abstract,
             "packing of abstract class '%*pM' is forbidden",
             LSTR_FMT_ARG(desc->fullname));

    do {
        int szs_pos = szs->len;

        qv_growlen(i32, szs, 1);
        level_size = __iop_bpack_size(desc, val, flags, szs);
        szs->tab[szs_pos] = level_size;
        size += level_size;
        if (first || level_size) {
            /* Add 1 for tag 0, followed by the class id */
            size += 1 + get_vint32_len(desc->class_attrs->class_id);
            first = false;
        }
    } while ((desc = desc->class_attrs->parent));

    return size;
}

int iop_bpack_size_flags(const iop_struct_t *desc, const void *val,
                         const unsigned flags, qv_t(i32) *szs)
{
    /* Put the packer flags in first to reuse them when packing */
    qv_append(i32, szs, flags);

    if (iop_struct_is_class(desc)) {
        return __iop_bpack_size_class(desc, val, flags, szs);
    } else {
        return __iop_bpack_size(desc, val, flags, szs);
    }
}

/*-}}}-*/
/*----- packing -{{{-*/

static uint8_t *pack_struct(void *dst, const iop_struct_t *, const void *,
                            const unsigned, const int **);
static uint8_t *pack_class(void *dst, const iop_struct_t *, const void *,
                           const unsigned, const int **);
static uint8_t *pack_union(void *dst, const iop_struct_t *, const void *,
                           const unsigned, const int **);

static uint8_t *
pack_value(uint8_t *dst, const iop_field_t *f, const void *v,
           const unsigned flags, const int **szsp)
{
    uint32_t len;

    switch (f->type) {
      case IOP_T_I8:
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = *(int8_t *)v;
        return dst;
      case IOP_T_U8:
        return pack_int32(dst, f->tag, f->tag_len, *(uint8_t *)v);
      case IOP_T_I16:
        return pack_int32(dst, f->tag, f->tag_len, *(int16_t *)v);
      case IOP_T_U16:
        return pack_int32(dst, f->tag, f->tag_len, *(uint16_t *)v);
      case IOP_T_I32:
      case IOP_T_ENUM:
        return pack_int32(dst, f->tag, f->tag_len, *(int32_t *)v);
      case IOP_T_U32:
        return pack_int64(dst, f->tag, f->tag_len, *(uint32_t *)v);
      case IOP_T_I64:
      case IOP_T_U64:
        return pack_int64(dst, f->tag, f->tag_len, *(int64_t *)v);
      case IOP_T_BOOL:
        /* bool are mapped to 0 or 1 */
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = !!*(bool *)v;
        return dst;
      case IOP_T_DOUBLE:
        dst = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(QUAD));
        return put_unaligned_double_le(dst, *(double *)v);
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        len = ((lstr_t *)v)->len;
        dst = pack_len(dst, f->tag, f->tag_len, len + 1);
        dst = mempcpyz(dst, ((lstr_t *)v)->data, len);
        return dst;
      case IOP_T_UNION:
        if (iop_field_is_reference(f)) {
            v = *(void **)v;
        }
        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        return pack_union(dst, f->u1.st_desc, v, flags, szsp);
      case IOP_T_STRUCT:
      default: {
        bool is_class = iop_field_is_class(f);
        bool is_ref   = iop_field_is_reference(f);

        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        if ((is_class || is_ref) && f->repeat != IOP_R_OPTIONAL) {
            /* Non-optional class fields have to be dereferenced
             * (dereferencing of optional fields was done in pack_struct).
             */
            v = *(void **)v;
        }
        if (is_class) {
            return pack_class(dst, f->u1.st_desc, v, flags, szsp);
        } else {
            return pack_struct(dst, f->u1.st_desc, v, flags, szsp);
        }
      }
    }
}

static uint8_t *
pack_value_vec(uint8_t *dst, const iop_field_t *f, const void *v, uint32_t n,
               const unsigned flags, const int **szsp)
{
    const lstr_t *d;
    uint32_t len;
    bool is_class;

    switch (f->type) {
      case IOP_T_I32:
      case IOP_T_ENUM:
        do {
            dst = pack_int32(dst, 0, 0, *(int32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_U32:
        do {
            dst = pack_int64(dst, 0, 0, *(uint32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_I64:
      case IOP_T_U64:
        do {
            dst = pack_int64(dst, 0, 0, *(int64_t *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_DOUBLE:
        do {
            dst = pack_tag(dst, 0, 0, IOP_WIRE_MASK(QUAD));
            dst = put_unaligned_double_le(dst, *(double *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        do {
            d = v;
            len = d->len;
            dst = pack_len(dst, 0, 0, len + 1);
            dst = mempcpyz(dst, d->data, len);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_UNION:
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            dst = pack_union(dst, f->u1.st_desc, v, flags, szsp);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_STRUCT:
        is_class = iop_field_is_class(f);
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            if (is_class) {
                dst = pack_class(dst, f->u1.st_desc, *(void **)v, flags,
                                 szsp);
            } else {
                dst = pack_struct(dst, f->u1.st_desc, v, flags, szsp);
            }
            v = (char *)v + f->size;
        } while (--n > 0);
        return dst;

      default:
        e_panic("should not happen");
    }
}

static uint8_t *
pack_struct(void *dst, const iop_struct_t *desc, const void *v,
            const unsigned flags, const int **szsp)
{
    assert(!desc->is_union); /* We don't want a union here */

    for (int i = 0; i < desc->fields_len; i++) {
        const iop_field_t *f = desc->fields + i;
        const void *ptr = (char *)v + f->data_offs;

        if (f->repeat == IOP_R_OPTIONAL) {
            if (!iop_value_has(f, ptr))
                continue;
            if ((1 << f->type) & IOP_STRUCTS_OK)
                ptr = *(void **)ptr;
        } else
        if (f->repeat == IOP_R_REPEATED) {
            const lstr_t *data = ptr;

            if (data->len == 0)
                continue;
            ptr = data->data;
            if (data->len > 1) {
                if ((1 << f->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    /* When data unit is really small (byte, bool, …) we
                     * prefer to pack them in one big block */
                    uint32_t sz = data->len * f->size;

                    assert (f->size <= 2);
                    dst = pack_len(dst, f->tag, f->tag_len, sz);
                    dst = mempcpy(dst, data->data, sz);
                } else {
                    dst = pack_tag(dst, f->tag, f->tag_len,
                                   IOP_WIRE_MASK(REPEAT));
                    dst = put_unaligned_le32(dst, data->len);
                    dst = pack_value_vec(dst, f, ptr, data->len, flags, szsp);
                }
                continue;
            }
        } else
        if (f->repeat == IOP_R_DEFVAL) {
            /* Skip the field if it's still equal to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&  iop_field_is_defval(f, ptr, true))
            {
                continue;
            }
        }

        dst = pack_value(dst, f, ptr, flags, szsp);
    }
    return dst;
}

static uint8_t *pack_class(void *dst, const iop_struct_t *desc, const void *v,
                           const unsigned flags, const int **szsp)
{
    bool first = true;

    desc = *(const iop_struct_t **)v;

    do {
        int level_size = *(*szsp)++;

        if (first || level_size) {
            /* We write the class id in a tag 0 only if:
             *  - this is the first level, because we always want to write the
             *    real class id of the packed object,
             *  - if there is actually something to pack.
             */
            dst = pack_int32(dst, 0, 0, desc->class_attrs->class_id);
            first = false;
        }
        if (level_size) {
            dst = pack_struct(dst, desc, v, flags, szsp);
        }
    } while ((desc = desc->class_attrs->parent));

    return dst;
}

static uint8_t *
pack_union(void *dst, const iop_struct_t *desc, const void *v,
           const unsigned flags, const int **szsp)
{
    const iop_field_t *f = get_union_field(desc, v);
    assert(f->repeat == IOP_R_REQUIRED);

    return pack_value(dst, f, (char *)v + f->data_offs, flags, szsp);
}

void iop_bpack(void *dst, const iop_struct_t *desc, const void *v,
               const int *szs)
{
    /* Read packing flags from first `szs' value */
    const unsigned flags = *szs++;

    if (desc->is_union) {
        pack_union(dst, desc, v, flags, &szs);
    } else
    if (iop_struct_is_class(desc)) {
        pack_class(dst, desc, v, flags, &szs);
    } else {
        pack_struct(dst, desc, v, flags, &szs);
    }
}

lstr_t mp_iop_bpack_struct_flags(mem_pool_t *mp, const iop_struct_t *st,
                                 const void *v, const unsigned flags)
{
    qv_t(i32) sizes;
    byte *data;
    int len;

    if (!v)
        return LSTR_NULL_V;

    qv_inita(i32, &sizes, 1024);

    len  = iop_bpack_size_flags(st, v, flags, &sizes);
    data = mp_new_raw(mp, byte, len + 1);
    data[len] = '\0';

    iop_bpack(data, st, v, sizes.tab);
    qv_wipe(i32, &sizes);
    return mp_lstr_init(mp, data, len);
}

lstr_t t_iop_bpack_struct_flags(const iop_struct_t *st, const void *v,
                                const unsigned flags)
{
    return mp_iop_bpack_struct_flags(t_pool(), st, v, flags);
}

/*-}}}-*/
/*----- unpacking -{{{-*/

static inline int get_uint32(pstream_t *ps, int ilen, uint32_t *u32)
{
    switch (ilen) {
      case 1:
        *u32 = RETHROW(ps_getc(ps));
        return 0;

      case 2: {
        uint16_t u16 = 0;
        RETHROW(ps_get_le16(ps, &u16));
        *u32 = u16;
      } return 0;

      case 4:
        return ps_get_le32(ps, u32);
    }
    e_panic("this should not happen");
}

/*
 * XXX: an iop_range helps doing run-length encoded binary search. We know
 * that IOPs tags are mostly contiguous, hence we encode "full" runs of tags
 * this way:
 *   [ offset0, start_tag0, offset1, ..., start_tag_n, offset_n]
 *
 * This means that the offset0-th up to the offset1-th values described by
 * this iop_range take values contiguously from the range:
 *   [ start_tag0 .. start_tag0 + offset1 - offset0 [
 *
 * Of course, offset0 is always equal to 0, and offset_n should be equal to
 * ranges_len.
 *
 * Example: the iop_range for "10 11 12 13 100 101 102" is "0 10 4 100 7"
 *  - positions [0 .. 4[ have values in [10  .. 10 + 4 - 0[
 *  - positions [4 .. 7[ have values in [100 .. 100 + 7 - 4[
 *
 */
int iop_ranges_search(int const * ranges, int ranges_len, int tag)
{
    int l = 0, r = ranges_len;

    while (l < r) {
        int i = (l + r) / 2;
        int offs  = ranges[i * 2];
        int start = ranges[i * 2 + 1];

        if (tag < start) {
            r = i;
            continue;
        }
        if (tag + offs >= start + ranges[i * 2 + 2]) {
            l = i + 1;
            continue;
        }
        return ranges[i * 2] + (tag - start);
    }
    return -1;
}

static int iop_enum_pos_from_val(const iop_enum_t *e, int val)
{
    return iop_ranges_search(e->ranges, e->ranges_len, val);
}

static int iop_enum_pos_from_str(const iop_enum_t *e, const char *s, int len)
{
    if (len < 0) {
        len = strlen(s);
    }
    for (int i = 0; i < e->enum_len; i++) {
        if (len == e->names[i].len && !strncasecmp(e->names[i].s, s, len)) {
            return i;
        }
    }
    return -1;
}

int iop_enum_from_str2(const iop_enum_t *e, const char *s, int len,
                       bool *found)
{
    int pos = iop_enum_pos_from_str(e, s, len);

    if (pos < 0) {
        *found = false;
        return -1;
    }
    *found = true;
    return e->values[pos];
}

int iop_enum_from_str(const iop_enum_t *e, const char *s, int len, int err)
{
    bool found;
    int val = iop_enum_from_str2(e, s, len, &found);

    return (found) ? val : err;
}

int iop_enum_from_lstr(const iop_enum_t *e, const lstr_t s, bool *found)
{
    return iop_enum_from_str2(e, s.s, s.len, found);
}


static int iop_skip_field(pstream_t *ps, iop_wire_type_t wt)
{
    uint32_t u32 = 0;

    switch (wt) {
      case IOP_WIRE_BLK1: PS_CHECK(get_uint32(ps, 1, &u32)); break;
      case IOP_WIRE_BLK2: PS_CHECK(get_uint32(ps, 2, &u32)); break;
      case IOP_WIRE_BLK4: PS_CHECK(get_uint32(ps, 4, &u32)); break;

      case IOP_WIRE_INT1:
      case IOP_WIRE_INT2:
      case IOP_WIRE_INT4:
        u32 = 1 << (wt - IOP_WIRE_INT1);
        break;
      case IOP_WIRE_QUAD:
        u32 = 8;
        break;
      default:
        return -1;
    }

    return ps_skip(ps, u32);
}

static ALWAYS_INLINE
int iop_patch_int(const iop_field_t *fdesc, void *ptr, int64_t i64)
{
    switch (fdesc->type) {
      case IOP_T_I8: case IOP_T_U8:
        *(int8_t *)ptr  = i64;
        break;
      case IOP_T_I16: case IOP_T_U16:
        *(int16_t *)ptr = i64;
        break;
      case IOP_T_ENUM:
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_I32: case IOP_T_U32:
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        *(int64_t *)ptr = i64;
        break;
      case IOP_T_BOOL:
        *(bool *)ptr    = i64;
        break;
    }
    return 0;
}

static ALWAYS_INLINE int
__get_tag_wt(pstream_t *ps, uint32_t *tag, iop_wire_type_t *wt)
{
    *wt  = IOP_WIRE_FMT(ps->b[0]);
    *tag = IOP_TAG(__ps_getc(ps));
    if (likely(*tag < IOP_LONG_TAG(1)))
        return 0;
    if (likely(*tag == IOP_LONG_TAG(1)))
        return get_uint32(ps, 1, tag);
    return get_uint32(ps, 2, tag);
}

static ALWAYS_INLINE int
__get_class_id(pstream_t *ps, iop_wire_type_t wt, uint16_t *class_id)
{
    switch (wt) {
      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        *class_id = (int8_t)__ps_getc(ps);
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        *class_id = (int16_t)__ps_get_le16(ps);
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        *class_id = (int16_t)__ps_get_le32(ps);
        return 0;

      default:
        return -1;
    }
}

int __iop_skip_absent_field_desc(mem_pool_t *mp, void *value,
                                 const iop_field_t *fdesc)
{
    void *ptr = (char *)value + fdesc->data_offs;

    switch (fdesc->repeat) {
      case IOP_R_REQUIRED: {
        const iop_struct_t *desc = fdesc->u1.st_desc;
        bool is_class;

        /* For a required field, only structs can be absents, be careful that
         * union must be present */
        PS_WANT(fdesc->type == IOP_T_STRUCT);

        if ((is_class = iop_field_is_class(fdesc))) {
            /* For classes, we consider that the absent object is of the
             * expected type, and not a child.
             * We have to allocate it since it's pointed. */
            PS_WANT(!desc->class_attrs->is_abstract);
            *(void **)ptr = mp_imalloc(mp, desc->size, 8, MEM_RAW);
            ptr = *(void **)ptr;
            *(const iop_struct_t **)ptr = desc;
        } else
        if (iop_field_is_reference(fdesc)) {
            *(void **)ptr = mp_imalloc(mp, desc->size, 8, MEM_RAW);
            ptr = *(void **)ptr;
        }
        do {
            for (int i = 0; i < desc->fields_len; i++) {
                PS_CHECK(__iop_skip_absent_field_desc(mp, ptr,
                                                      desc->fields + i));
            }
        } while (is_class && (desc = desc->class_attrs->parent));
      } return 0;

      case IOP_R_DEFVAL:
        switch (fdesc->type) {
          case IOP_T_I8: case IOP_T_U8:
            *(uint8_t *)ptr  = fdesc->u1.defval_u64;
            break;
          case IOP_T_I16: case IOP_T_U16:
            *(uint16_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_ENUM:
            *(uint32_t *)ptr = fdesc->u0.defval_enum;
            break;
          case IOP_T_I32: case IOP_T_U32:
            *(uint32_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_I64: case IOP_T_U64:
            *(uint64_t *)ptr = fdesc->u1.defval_u64;
            break;
          case IOP_T_BOOL:
            *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
            break;
          case IOP_T_DOUBLE:
            *(double *)ptr   = fdesc->u1.defval_d;
            break;
          case IOP_T_STRING:
          case IOP_T_XML:
            *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data, fdesc->u0.defval_len);
            break;
          case IOP_T_DATA:
            ((lstr_t *)ptr)->len      = fdesc->u0.defval_len;
            ((lstr_t *)ptr)->data     = (void *)fdesc->u1.defval_data;
            ((lstr_t *)ptr)->mem_pool = MEM_STATIC;
            break;
          default:
            return -1;
        }
        break;

      case IOP_R_REPEATED: {
        unsigned fdesc_flags = fdesc->flags;

        if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
            iop_set_err("empty array not allowed for field `%*pM`",
                        LSTR_FMT_ARG(fdesc->name));
            return -1;
        }
        p_clear((lstr_t *)ptr, 1);
      } break;

      case IOP_R_OPTIONAL:
        iop_value_set_absent(fdesc, ptr);
        break;
    }
    return 0;
}

static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, bool copy, iop_wire_type_t *class_id_wt);
static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, bool copy);
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, bool copy);

static int unpack_value(mem_pool_t *mp, iop_wire_type_t wt,
                        const iop_field_t *fdesc, void *v,
                        pstream_t *ps, bool copy)
{
    uint32_t u32 = 0;
    pstream_t ps_tmp;

    if (iop_field_is_reference(fdesc)) {
        v = iop_value_set_here(mp, fdesc, v);
    }

    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_WANT(ps_has(ps, u32));
        switch (fdesc->type) {
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            *(lstr_t *)v = LSTR_INIT_V((copy ? mp_dup(mp, ps->s, u32)
                                        : ps->p), u32 - 1);
            return __ps_skip(ps, u32);
          case IOP_T_UNION:
            ps_tmp = __ps_get_ps(ps, u32);
            return unpack_union(mp, fdesc->u1.st_desc, v, &ps_tmp, copy);
          case IOP_T_STRUCT:
            ps_tmp = __ps_get_ps(ps, u32);
            if (iop_field_is_class(fdesc)) {
                *(void **)v = NULL;
                return unpack_class(mp, fdesc->u1.st_desc, v, &ps_tmp, copy);
            } else {
                return unpack_struct(mp, fdesc->u1.st_desc, v, &ps_tmp, copy,
                                     NULL);
            }
        }
        return -1;

      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int8_t)__ps_getc(ps));

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int16_t)__ps_get_le16(ps));

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int32_t)__ps_get_le32(ps));

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_WANT(ps_has(ps, 8));
            return iop_patch_int(fdesc, v, __ps_get_le64(ps));
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE)
            return ps_get_double_le(ps, v);
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        return ps_get_le64(ps, v);
      default:
        return -1;
    }
}

/* Returns:
 * * 1 when "change of level" (used for classes) tag was seen; in that case,
 *   the wire type associated to this tag is written in class_id_wt.
 * * 0 otherwise on success.
 * * a negative value on error.
 */
static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, bool copy, iop_wire_type_t *class_id_wt)
{
    bool is_class = iop_struct_is_class(desc);
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = desc->fields + desc->fields_len;
    iop_wire_type_t wt;
    uint32_t tag;

    while (fdesc < end && !ps_done(ps)) {
        uint32_t n = 1;
        void *v;

        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
        if (tag == 0) {
            /* This is a "change of level" tag in a packed class; check that
             * all the remaining fields at this level are optional. */
            PS_WANT(is_class);
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking class %*pM, got change of level tag",
                          LSTR_FMT_ARG(desc->fullname));
            do {
                PS_CHECK(__iop_skip_absent_field_desc(mp, value, fdesc));
            } while (++fdesc != end);
            *class_id_wt = wt;
            return 1;
        }
        while (unlikely(tag > fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker", "unpacking struct %*pM, "
                          "skipping absent field %*pM (tag %u)",
                          LSTR_FMT_ARG(desc->fullname),
                          LSTR_FMT_ARG(fdesc->name), fdesc->tag);
            PS_CHECK(__iop_skip_absent_field_desc(mp, value, fdesc));
            if (++fdesc == end) {
                return 0;
            }
        }
        if (unlikely(tag < fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking struct %*pM, skipping unknown tag %u",
                          LSTR_FMT_ARG(desc->fullname), tag);
            PS_CHECK(iop_skip_field(ps, wt));
            continue;
        }

        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, unpacking field %*pM (tag %u)",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name), tag);

        if (wt == IOP_WIRE_REPEAT) {
            PS_CHECK(get_uint32(ps, 4, &n));
            PS_WANT(n >= 1);
            PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
            wt = IOP_WIRE_FMT(__ps_getc(ps));
        }

        v = (char *)value + fdesc->data_offs;
        if (fdesc->repeat == IOP_R_REPEATED) {
            lstr_t *data = v;

            if (wt != IOP_WIRE_REPEAT
            &&  ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK))
            {
                /* optimized version of repeated fields are packed in simples
                 * IOP blocks */
                uint32_t len = 0;

                switch (wt) {
                  case IOP_WIRE_BLK1:
                    PS_CHECK(get_uint32(ps, 1, &len));
                    break;
                  case IOP_WIRE_BLK2:
                    PS_CHECK(get_uint32(ps, 2, &len));
                    break;
                  case IOP_WIRE_BLK4:
                    PS_CHECK(get_uint32(ps, 4, &len));
                    break;
                  default:
                    /* Here we expect to have a uniq-value packed as a normal
                     * field (data->len == 1) */
                    goto unpack_array;
                }
                PS_WANT(ps_has(ps, len));

                if (fdesc->size == 1) {
                    data->len = len;
                    data->data = (copy ? mp_dup(mp, ps->s, len)
                                       : (void *)ps->p);
                } else {
                    assert (fdesc->size == 2);
                    PS_WANT(len % 2 == 0);
                    data->len  = len / 2;
                    data->data = mp_dup(mp, ps->s, len);
                }

                __ps_skip(ps, len);
                v = data->data;
                n = data->len;
                goto next;
            }

          unpack_array:
            data->len  = n;
            data->data = v = mp_imalloc(mp, n * fdesc->size, 8, MEM_RAW);

            while (n-- > 1) {
                PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
                v  = (char *)v + fdesc->size;
            }
            PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
            v = data->data;
            n = data->len;
        } else {
            while (n-- > 1) {
                PS_CHECK(iop_skip_field(ps, wt));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
            }
            if (fdesc->repeat == IOP_R_OPTIONAL && !iop_field_is_class(fdesc))
            {
                v = iop_value_set_here(mp, fdesc, v);
            }
            PS_CHECK(unpack_value(mp, wt, fdesc, v, ps, copy));
            n = 1;
        }

      next:
        if (unlikely(iop_field_has_constraints(desc, fdesc))) {
            RETHROW(iop_field_check_constraints(desc, fdesc, v, n, false));
        }
        fdesc++;
    }

    for (; fdesc < end; fdesc++) {
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, skipping %*pM field",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name));
        PS_CHECK(__iop_skip_absent_field_desc(mp, value, fdesc));
    }

    return 0;
}

static inline int
unpack_skip_all_fields(mem_pool_t *mp, const iop_struct_t *desc, void *value)
{
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = fdesc + desc->fields_len;

    for ( ; fdesc < end; fdesc++) {
        PS_CHECK(__iop_skip_absent_field_desc(mp, value, fdesc));
    }
    return 0;
}

static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, bool copy)
{
    const iop_struct_t *real_desc;
    iop_wire_type_t wt;
    uint32_t tag;
    uint16_t child_id = 0;

    PS_WANT(!ps_done(ps));

    /* Get the class id of the packed class instance */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    PS_WANT(tag == 0);
    PS_CHECK(__get_class_id(ps, wt, &child_id));

    if (unlikely(!(real_desc = iop_get_class_by_id(desc, child_id)))) {
        e_trace(0, "cannot find child %d of class '%*pM'; missing "
                "IOP_REGISTER_PACKAGES?",
                child_id, LSTR_FMT_ARG(desc->fullname));
        return -1;
    }

    if (real_desc != desc) {
        /* We are trying to unpack a class of type "desc", and the packed
         * class is of type "real_desc". Check that this is authorized. */
        PS_WANT(iop_class_is_a(real_desc, desc));

        e_named_trace(5, "iop/c/unpacker",
                      "unpacking a class of type %*pM, real type %*pM",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(real_desc->fullname));
    }

    PS_WANT(!real_desc->class_attrs->is_abstract);
    *value = mp_irealloc(mp, *value, 0, real_desc->size, 8, MEM_RAW);

    /* Set the _vprt pointer */
    *(const iop_struct_t **)(*value) = real_desc;

    /* Unpack the several levels */
    for (;;) {
        uint16_t class_id = 0;
        int res;

        PS_CHECK((res = unpack_struct(mp, real_desc, *value, ps, copy, &wt)));

        if (!(real_desc = real_desc->class_attrs->parent)) {
            return 0;
        }

        if (res != 1) {
            /* "Change of level" tag was not seen yet */
            if (ps_done(ps)) {
                /* Such a tag won't be there because pstream is finished. This
                 * is possible if all the remaining levels have only optional
                 * fields. */
                do {
                    PS_CHECK(unpack_skip_all_fields(mp, real_desc, *value));
                } while ((real_desc = real_desc->class_attrs->parent));
                return 0;
            }
            /* Read it */
            PS_CHECK(__get_tag_wt(ps, &tag, &wt));
            PS_WANT(tag == 0);
        }

        /* Get the next class id, and run the tree up to it; the skipped
         * classes must have only optional fields. */
        PS_CHECK(__get_class_id(ps, wt, &class_id));
        while (class_id != real_desc->class_attrs->class_id) {
            PS_CHECK(unpack_skip_all_fields(mp, real_desc, *value));
            PS_WANT((real_desc = real_desc->class_attrs->parent));
        }
    }
}

/* note: returns 0 on success, -1 on error and 1 if the pstream hasn't been
 * fully consumed. */
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, bool copy)
{
    const iop_field_t *fdesc = desc->fields;

    iop_wire_type_t wt;
    uint32_t tag;
    int ifield;

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Write the selected field */
    *((uint16_t *)value) = fdesc->tag;
    value = (char *)value + fdesc->data_offs;

    e_named_trace(5, "iop/c/unpacker", "unpacking union %*pM field %*pM",
                  LSTR_FMT_ARG(desc->fullname), LSTR_FMT_ARG(fdesc->name));
    PS_CHECK(unpack_value(mp, wt, fdesc, value, ps, copy));
    if (unlikely(iop_field_has_constraints(desc, fdesc))) {
        RETHROW(iop_field_check_constraints(desc, fdesc, value, 1, false));
    }
    return ps_done(ps) ? 0 : 1;
}

int iop_bunpack(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                pstream_t ps, bool copy)
{
    assert (!iop_struct_is_class(desc));
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);
    if (desc->is_union) {
        return unpack_union(mp, desc, value, &ps, copy) ? -1 : 0;
    }
    return unpack_struct(mp, desc, value, &ps, copy, NULL);
}

int iop_bunpack_ptr(mem_pool_t *mp, const iop_struct_t *desc, void **value,
                    pstream_t ps, bool copy)
{
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);

    if (!iop_struct_is_class(desc)) {
        *value = mp_irealloc(mp, *value, 0, desc->size, 8, MEM_RAW);
        return iop_bunpack(mp, desc, *value, ps, copy);
    }

    return unpack_class(mp, desc, value, &ps, copy);
}

/* XXX: this function can unpack only union because the struct can't be
 * delimited in a stream.
 * */
int iop_bunpack_multi(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                pstream_t *ps, bool copy)
{
    assert(desc->is_union);

    e_named_trace(5, "iop/c/unpacker", "unpacking IOP union(s) %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    sb_reset(&iop_err_g);
    return (unpack_union(mp, desc, value, ps, copy) < 0) ? -1 : 0;
}

/* XXX this function doesn't check the IOP content and trust what it reads
 * XXX: this function can unpack only union because the struct can't be
 * delimited in a stream. */
int iop_bskip(const iop_struct_t *desc, pstream_t *ps)
{
    const iop_field_t *fdesc = desc->fields;
    iop_wire_type_t wt;
    uint32_t tag, u32 = 0;
    int ifield;

    assert(desc->is_union);

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Skip union data */
    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_CHECK(ps_skip(ps, u32)); /* Skip block */
        return 0;

      case IOP_WIRE_INT1:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 1));
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 2));
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 4));
        return 0;

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_CHECK(ps_skip(ps, 8));
            return 0;
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE) {
            PS_CHECK(ps_skip(ps, sizeof(double)));
            return 0;
        }
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        PS_CHECK(ps_skip(ps, 8));
        return 0;
      default:
        return -1;
    }
}

ssize_t iop_get_field_len(pstream_t ps)
{
    iop_wire_type_t wt;
    uint32_t tag, u32, tag_len, len_len;

    if (ps_done(&ps))
        return 0;
    wt  = IOP_WIRE_FMT(ps.b[0]);
    tag = IOP_TAG(ps.b[0]);
    if (likely(tag < IOP_LONG_TAG(1))) {
        tag_len = 1;
    } else {
        tag_len = 2 + tag - IOP_LONG_TAG(1);
    }
    switch (wt) {
      case IOP_WIRE_BLK1:
        len_len = 1;
        break;
      case IOP_WIRE_BLK2:
        len_len = 2;
        break;
      case IOP_WIRE_BLK4:
        len_len = 4;
        break;
      case IOP_WIRE_REPEAT: /* not supported by this function */
        return -1;
      case IOP_WIRE_INT1:
        return tag_len + 1;
      case IOP_WIRE_INT2:
        return tag_len + 2;
      case IOP_WIRE_INT4:
        return tag_len + 4;
      case IOP_WIRE_QUAD:
        return tag_len + 8;
      default:
        return -1;
    }
    if (ps_skip(&ps, tag_len) < 0)
        return 0;
    u32 = 0;
    if (get_uint32(&ps, len_len, &u32) < 0)
        return 0;
    return tag_len + len_len + u32;
}

/*-}}}-*/
/*------ introspection -{{{-*/

const iop_iface_t *iop_mod_find_iface(const iop_mod_t *mod, uint32_t tag)
{
    size_t l = 0, r = mod->ifaces_len;

    while (l < r) {
        size_t  i = (l + r) / 2;
        const iop_iface_alias_t *alias = &mod->ifaces[i];

        if (tag == alias->tag) {
            return alias->iface;
        }
        if (tag < alias->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_iface_find_rpc(const iop_iface_t *iface, uint32_t tag)
{
    size_t l = 0, r = iface->funs_len;

    while (l < r) {
        size_t i = (l + r) / 2;
        const iop_rpc_t *rpc = &iface->funs[i];

        if (tag == rpc->tag) {
            return rpc;
        }
        if (tag < rpc->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_mod_find_rpc(const iop_mod_t *mod, uint32_t cmd)
{
    const iop_iface_t *iface = RETHROW_P(iop_mod_find_iface(mod, cmd >> 16));
    return iop_iface_find_rpc(iface, cmd & 0xffff);
}

const iop_field_t *
_iop_class_get_next_field(const iop_struct_t **st, int *it)
{
    while (*st && *it >= (*st)->fields_len) {
        *st = (*st)->class_attrs->parent;
        *it = 0;
    }

    return *st ? (*st)->fields + (*it)++ : NULL;
}

/*------ introspection -}}}-*/
/*------ Signature -{{{-*/

#define ATTRS
#define F(x)  x
#include "iop-signature.in.c"
#undef F
#undef ATTRS

lstr_t t_iop_compute_signature(const iop_struct_t *st, const void *v,
                               unsigned flags)
{
    return t_iop_sign_salt_sha256(st, v, ha_rand(), flags);
}

__attribute__((constructor))
static void iop_signature_initialize(void)
{
    ha_srand();
}

/*------ Signature -}}}-*/
/*------ class manipulation -{{{-*/

iop_value_t const *
iop_get_class_cvar_desc(const iop_struct_t *desc, lstr_t name)
{
    iop_static_field_t _search = { .name = name };
    iop_static_field_t *search = &_search;

    const iop_class_attrs_t *cls = desc->class_attrs;
    bool found;
    int pos;
    cmp_b cmp = ^int (const void *a, const void *b) {
        const iop_static_field_t **v1 = (const iop_static_field_t **)a;
        const iop_static_field_t **v2 = (const iop_static_field_t **)b;

        return lstr_cmp(&(*v1)->name, &(*v2)->name);
    };

    assert (iop_struct_is_class(desc));

    pos = bisect_blk(&search, cls->static_fields,
                     sizeof(iop_static_field_t *),
                     cls->static_fields_len, &found, cmp);
    if (found) {
        const iop_static_field_t *f;

        f = desc->class_attrs->static_fields[pos];
        return &f->value;
    }
    return NULL;
}

const iop_value_t *iop_get_class_cvar(const void *obj, lstr_t name)
{
    return iop_get_class_cvar_desc(*(iop_struct_t **)obj, name);
}

const iop_value_t *iop_get_cvar_desc(const iop_struct_t *desc, lstr_t name)
{
    assert (iop_struct_is_class(desc));

    while (desc) {
        const iop_class_attrs_t *cls = desc->class_attrs;
        const iop_value_t *v;

        if ((v = iop_get_class_cvar_desc(desc, name))) {
            return v;
        }
        desc = cls->parent;
    }

    return NULL;
}

const iop_value_t *iop_get_cvar(const void *obj, lstr_t name)
{
    return iop_get_cvar_desc(*(iop_struct_t **)obj, name);
}

bool iop_class_is_a(const iop_struct_t *cls1, const iop_struct_t *cls2)
{
    if (!iop_struct_is_class(cls1) || !iop_struct_is_class(cls2)) {
        assert (false);
        return false;
    }

    do {
        if (cls1 == cls2) {
            return true;
        }
    } while ((cls1 = cls1->class_attrs->parent));

    return false;
}

const iop_struct_t *
iop_get_class_by_fullname(const iop_struct_t *st, lstr_t fullname)
{
    class_name_key_t key = {
        .master = st,
        .child_fullname = &fullname,
    };

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    return qm_get_def(class_name, &_G.classes_by_name, &key, NULL);
}

const iop_struct_t *
iop_get_class_by_id(const iop_struct_t *st, uint16_t class_id)
{
    class_id_key_t key = {
        .master   = st,
        .child_id = class_id,
    };

    if (st->class_attrs->class_id == class_id) {
        return st;
    }

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    return qm_get_def(class_id, &_G.classes_by_id, &key, NULL);
}

void iop_for_each_registered_classes(iop_for_each_class_b cb)
{
    qm_for_each_pos(class_id, pos, &_G.classes_by_id) {
        cb(_G.classes_by_id.values[pos]);
    }
}

/*------ class manipulation -}}}-*/
/*------ Packages registration -{{{-*/

static void iop_register_class(const iop_struct_t *desc)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };
    uint32_t pos;

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    /* Register in classes_by_id hash table */
    pos = qm_put(class_id, &_G.classes_by_id, &key, desc, 0);
    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;
        if (_G.classes_by_id.values[pos] != desc) {
            e_fatal("conflicting class id %d: used by both '%*pM' and '%*pM'",
                    desc->class_attrs->class_id, LSTR_FMT_ARG(desc->fullname),
                    LSTR_FMT_ARG(_G.classes_by_id.values[pos]->fullname));
        }
    } else {
        class_name_key_t key2 = {
            .master         = key.master,
            .child_fullname = &desc->fullname,
        };

        e_named_trace(5, "iop/package_registration",
                      "registering class '%*pM' as a child of '%*pM' (%p)",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(key.master->fullname), key.master);

        /* Register in classes_by_name hash table */
        if (qm_add(class_name, &_G.classes_by_name, &key2, desc) < 0) {
            e_fatal("conflicting class name '%*pM' as a child of '%*pM'",
                    LSTR_FMT_ARG(desc->fullname),
                    LSTR_FMT_ARG(key.master->fullname));
        }

        if (desc->class_attrs->parent) {
            /* Register the parent only if the class was not registered
             * yet, because if it is, we are sure the parent is already
             * registered. */
            iop_register_class(desc->class_attrs->parent);
        }
    }
}

void iop_register_packages(const iop_pkg_t **pkgs, int len)
{
    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];

        qm_add(iop_pkg, &_G.pkgs_by_name, &pkg->name, pkg);
        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            if (iop_struct_is_class(desc)) {
                iop_register_class(desc);
            }
        }
    }
}

const iop_pkg_t *iop_get_pkg(lstr_t pkgname)
{
    return qm_get_def(iop_pkg, &_G.pkgs_by_name, &pkgname, NULL);
}

static void iop_unregister_class(const iop_struct_t *desc)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    if (qm_del_key(class_id, &_G.classes_by_id, &key) >= 0) {
        class_name_key_t key2 = {
            .master         = key.master,
            .child_fullname = &desc->fullname,
        };

        qm_del_key(class_name, &_G.classes_by_name, &key2);

        if (desc->class_attrs->parent) {
            /* Unregister the parent only if the class was registered,
             * because if not we are sure the parent won't be. */
            iop_unregister_class(desc->class_attrs->parent);
        }
    }
}

void iop_unregister_packages(const iop_pkg_t **pkgs, int len)
{
    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];

        qm_del_key(iop_pkg, &_G.pkgs_by_name, &pkg->name);
        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            if (iop_struct_is_class(desc)) {
                iop_unregister_class(desc);
            }
        }
    }
}

/*------ Packages registration -}}}-*/

__attribute__((destructor))
static void iop_shutdown(void)
{
    qm_wipe(class_id,   &_G.classes_by_id);
    qm_wipe(class_name, &_G.classes_by_name);
    qm_wipe(iop_pkg,    &_G.pkgs_by_name);
}

iop_struct_t const iop__void__s = {
    .fullname   = LSTR_IMMED("Void"),
    .fields_len = 0,
    .size       = 0,
};
