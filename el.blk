/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include <sys/wait.h>
#include <pthread.h>
#include "container.h"
#include "datetime.h"
#include "el.h"

static pthread_mutex_t big_lock_g;
static bool use_big_lock_g = false;

/** \addtogroup lc_el
 * \{
 */

/** \file lib-inet/el.c
 * \brief Event Loop module implementation.
 */

/*
 * TODO:
 *
 * - timer things:
 *   + monotonic clocks are very seldomly implemented (only on x86 for Linux).
 *     Have a way to detect timewarps, and avoid clock_gettime so that we can
 *     drop -lrt.
 *
 * - fd things:
 *   + implement a solaris port using event ports (see what libev does).
 *   + implement a windows port.
 *
 */

typedef enum ev_type_t {
    EV_UNUSED,
    EV_BLOCKER,
    EV_BEFORE,
    EV_SIGNAL,
    EV_CHILD,
    EV_FD,
    EV_TIMER,
    EV_PROXY,
    EV_IDLE,
    EV_FS_WATCH,
} ev_type_t;

enum ev_flags_t {
    EV_FLAG_REFS          = (1U <<  0),
    EV_FLAG_TRACE         = (1U <<  1),
    EV_FLAG_IS_BLK        = (1U <<  2),

    EV_FLAG_TIMER_NOMISS  = (1U <<  8),
    EV_FLAG_TIMER_LOWRES  = (1U <<  9),
    EV_FLAG_TIMER_UPDATED = (1U << 10),

    EV_FLAG_FD_WATCHED    = (1U <<  8),

    EV_FLAG_FSW_ACTIVE    = (1U <<  8),
#define EV_FLAG_HAS(ev, f)   ((ev)->flags & EV_FLAG_##f)
#define EV_FLAG_SET(ev, f)   ((ev)->flags |= EV_FLAG_##f)
#define EV_FLAG_RST(ev, f)   ((ev)->flags &= ~EV_FLAG_##f)

#ifndef NDEBUG
#define EV_IS_TRACED(ev)   unlikely(EV_FLAG_HAS(ev, TRACE))
#else
#define EV_IS_TRACED(ev)   0
#endif
};

typedef struct ev_t {
    uint8_t   type;             /* ev_type_t */
    union {
        uint8_t   signo;            /* EV_SIGNAL */
        uint8_t   generation;       /* EV_FD */
    };
    uint16_t  flags     : 14;
    uint16_t  priority  : 2;
    union {
        uint16_t  events_avail; /* EV_PROXY */
        uint16_t  events_act;   /* EV_FD    */
    };
    uint16_t  events_wanted;    /* EV_PROXY, EV_FD */

    union {
        el_cb_f       *cb;
        el_signal_f   *signal;
        el_child_f    *child;
        el_fd_f       *fd;
        el_proxy_f    *prox;
        el_fs_watch_f *fs_watch;

        el_cb_b       cb_blk;
        el_signal_b   signal_blk;
        el_child_b    child_blk;
        el_fd_b       fd_blk;
        el_proxy_b    proxy_blk;
        el_fs_watch_b fs_watch_blk;
    } cb;
    union {
        el_data_t priv;
        block_t   wipe;
    };

    union {
        dlist_t ev_list;        /* EV_BEFORE, EV_SIGNAL, EV_PROXY */
        int     fd;             /* EV_FD */
        pid_t   pid;            /* EV_CHILD */
        struct {
            uint64_t expiry;
            int      repeat;
            int      heappos;
        } timer;                /* EV_TIMER */
        struct {
            char *path;
            int   wd;
        } fs_watch;             /* EV_FS_WATCH */
    };
} ev_t;

#define TIMER_CMP(ev1, op, ev2)  \
    ((ev1)->timer.expiry op (ev2)->timer.expiry)

static ALWAYS_INLINE void ev_set_qhp_pos(ev_t *ev, int pos)
{
    ev->timer.heappos = pos;
}

qvector_t(ev, ev_t *);
qhp_min_t(timer, ev_t *, TIMER_CMP, ev_set_qhp_pos);
qm_k32_t(ev_assoc, ev_t *);
qm_k64_t(ev, ev_t *);

static struct {
    volatile uint32_t gotsigs;
    int       inotify_fd;     /* fd for inotify                             */
    int       active;         /* number of ev_t keeping the el_loop running */
    uint8_t   unloop;         /* @see el_unloop()                           */
    uint8_t   has_run;        /* true if we did something during a loop     */
    bool      worker_running; /* true if the worker is currently running    */
    int       loop_depth;     /* depth of el_loop_timeout() recursion       */
    uint64_t  lp_clk;         /* low precision monotonic clock              */

    dlist_t   idle;           /* ev_t to run when we're "idle"              */
    dlist_t   idle_parked;    /* list to hide idle hooks for a while        */
    dlist_t   before;         /* ev_t to run just before the epoll call     */
    dlist_t   sigs;           /* signals el_t's                             */
    dlist_t   proxy, proxy_ready;
    qhp_t(timer) timers;      /* relative timers heap (see comments after)  */
    qv_t(ev)  cache;
    qm_t(ev_assoc) childs;    /* el_t's watching for processes              */
    qm_t(ev)  fd_act;         /* el_t's timers to el_t fds map              */
    qm_t(ev)  fs_watches;     /* el_t's for fs watch events                 */
    el_t      fs_watch;       /* inotify el_t                               */
    el_worker_f *worker;      /* worker callback                            */
    uint64_t     worker_end;  /* worker end time                            */

    /*----- allocation stuff -----*/
#define EV_ALLOC_FACTOR  10   /* basic segment is 1024 events               */
    ev_t   evs_initial[1 << EV_ALLOC_FACTOR];
    ev_t  *evs_alloc_next, *evs_alloc_end;
    ev_t  *evs[32 - EV_ALLOC_FACTOR];
    int    evs_len;
    dlist_t evs_free;
    dlist_t evs_gc;
} el_g = {
#define _G el_g
    .evs[0]         = _G.evs_initial,
    .evs_len        = 1,
    .evs_alloc_next = &_G.evs_initial[0],
    .evs_alloc_end  = &_G.evs_initial[countof(_G.evs_initial)],

    .idle           = DLIST_INIT(_G.idle),
    .idle_parked    = DLIST_INIT(_G.idle_parked),
    .before         = DLIST_INIT(_G.before),
    .sigs           = DLIST_INIT(_G.sigs),
    .proxy          = DLIST_INIT(_G.proxy),
    .proxy_ready    = DLIST_INIT(_G.proxy_ready),
    .evs_free       = DLIST_INIT(_G.evs_free),
    .evs_gc         = DLIST_INIT(_G.evs_gc),
    .childs         = QM_INIT(ev_assoc, _G.childs, false),
    .fd_act         = QM_INIT(ev, _G.fd_act, false),
    .fs_watches     = QM_INIT(ev, _G.fs_watches, false),
    .inotify_fd     = -1,
};

#define ASSERT(msg, expr)  assert (((void)msg, likely(expr)))
#define CHECK_EV(ev)   \
    ASSERT("ev is uninitialized", (ev)->type)
#define CHECK_EV_TYPE(ev, typ) \
    ASSERT("incorrect type", (ev)->type == typ)

static ev_t *ev_add(dlist_t *l, ev_t *ev)
{
    dlist_add(l, &ev->ev_list);
    return ev;
}

static void ev_cache_list(dlist_t *l)
{
    ev_t *ev;

    qv_clear(ev, &_G.cache);
    dlist_for_each_entry(ev, l, ev_list) {
        qv_append(ev, &_G.cache, ev);
    }
}

static ev_t *el_create(ev_type_t type, void *cb, el_data_t priv, bool ref)
{
    ev_t *res;

    if (unlikely(dlist_is_empty(&_G.evs_free))) {
        if (unlikely(_G.evs_alloc_next >= _G.evs_alloc_end)) {
            int   bucket_len = 1 << (_G.evs_len++ + EV_ALLOC_FACTOR);
            ev_t *bucket     = p_new(ev_t, bucket_len);

            if (unlikely(_G.evs_len > countof(_G.evs)))
                e_panic(E_PREFIX("insane amount of events"));
            _G.evs[_G.evs_len - 1] = bucket;
            _G.evs_alloc_next = bucket;
            _G.evs_alloc_end  = bucket + bucket_len;
        }
        res = _G.evs_alloc_next++;
    } else {
        res = container_of(_G.evs_free.next, ev_t, ev_list);
        dlist_remove(&res->ev_list);
    }

    *res = (ev_t){
        .type   = type,
        .cb.cb  = cb,
    };
    res->priv = priv;

    return ref ? el_ref(res) : res;
}

static ev_t *el_blk_register(ev_t *ev, void *cb, block_t wipe)
{
    el_cb_b blk = cb;

    EV_FLAG_SET(ev, IS_BLK);
    ev->cb.cb_blk = Block_copy(blk);
    ev->wipe      = wipe ? Block_copy(wipe) : NULL;
    return ev;
}

static el_data_t el_destroy(ev_t **evp, bool move)
{
    ev_t *ev = *evp;

    if (EV_FLAG_HAS(ev, IS_BLK)) {
        block_t wipe = ev->wipe;

        if (wipe) {
            wipe();
            Block_release(wipe);
        }
        Block_release(ev->cb.cb);
        EV_FLAG_RST(ev, IS_BLK);
        ev->priv = (el_data_t)NULL;
    }
    el_unref(ev);
    if (move) {
        dlist_move(&_G.evs_gc, &ev->ev_list);
    } else {
        dlist_add(&_G.evs_gc, &ev->ev_list);
    }
    ev->type  = EV_UNUSED;
    ev->flags = 0;
    *evp = NULL;
    return ev->priv;
}

static void ev_list_process(dlist_t *l)
{
    ev_cache_list(l);
    for (int i = 0; i < _G.cache.len; i++) {
        ev_t *ev = _G.cache.tab[i];

        if (unlikely(ev->type == EV_UNUSED))
            continue;
        if (EV_FLAG_HAS(ev, IS_BLK)) {
            ev->cb.cb_blk(ev);
        } else {
            (*ev->cb.cb)(ev, ev->priv);
        }
    }
}

/*----- blockers, before and idle events -----*/

ev_t *el_blocker_register(void)
{
    return el_create(EV_BLOCKER, NULL, (el_data_t)NULL, true);
}

ev_t *el_before_register_d(el_cb_f *cb, el_data_t priv)
{
    return ev_add(&_G.before, el_create(EV_BEFORE, cb, priv, true));
}

ev_t *el_before_register_blk(el_cb_b blk, block_t wipe)
{
    return el_blk_register(el_before_register(NULL, NULL), blk, wipe);
}

void el_before_set_hook(el_t ev, el_cb_f *cb)
{
    CHECK_EV_TYPE(ev, EV_BEFORE);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    ev->cb.cb = cb;
}

void el_blocker_unregister(ev_t **evp)
{
    if (*evp) {
        CHECK_EV_TYPE(*evp, EV_BLOCKER);
        el_destroy(evp, false);
    }
}

el_data_t el_before_unregister(ev_t **evp)
{
    if (*evp) {
        CHECK_EV_TYPE(*evp, EV_BEFORE);
        return el_destroy(evp, true);
    }
    return (el_data_t)NULL;
}

ev_t *el_idle_register_d(el_cb_f *cb, el_data_t priv)
{
    return ev_add(&_G.idle, el_create(EV_IDLE, cb, priv, false));
}

ev_t *el_idle_register_blk(el_cb_b blk, block_t wipe)
{
    return el_blk_register(el_idle_register(NULL, NULL), blk, wipe);
}

void el_idle_set_hook(el_t ev, el_cb_f *cb)
{
    CHECK_EV_TYPE(ev, EV_IDLE);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    ev->cb.cb = cb;
}

el_data_t el_idle_unregister(ev_t **evp)
{
    if (*evp) {
        CHECK_EV_TYPE(*evp, EV_IDLE);
        return el_destroy(evp, true);
    }
    return (el_data_t)NULL;
}

void el_idle_unpark(ev_t *ev)
{
    CHECK_EV_TYPE(ev, EV_IDLE);
    dlist_move(&_G.idle, &ev->ev_list);
}

static void el_idle_process(uint64_t now)
{
    static uint64_t last_run = UINT64_MAX;

    if (now - last_run > 10 * 60 * 1000)
        dlist_splice_tail(&_G.idle, &_G.idle_parked);
    if (!_G.has_run) {
        ev_cache_list(&_G.idle);
        dlist_splice(&_G.idle_parked, &_G.idle);
        last_run = now;

        for (int i = 0; i < _G.cache.len; i++) {
            ev_t *ev = _G.cache.tab[i];

            if (unlikely(ev->type == EV_UNUSED))
                continue;
            if (EV_FLAG_HAS(ev, IS_BLK)) {
                ev->cb.cb_blk(ev);
            } else {
                (*ev->cb.cb)(ev, ev->priv);
            }
        }
    }
}

/*----- signal events -----*/

static void el_sighandler(int signum)
{
    _G.gotsigs |= (1 << signum);
}

static void el_signal_process(void)
{
    uint32_t gotsigs = _G.gotsigs;
    struct timeval now;

    if (!gotsigs)
        return;

    _G.gotsigs &= ~gotsigs;
    lp_gettv(&now);

    ev_cache_list(&_G.sigs);
    for (int i = 0; i < _G.cache.len; i++) {
        ev_t *ev = _G.cache.tab[i];
        int signo = ev->signo;

        if (unlikely(ev->type == EV_UNUSED))
            continue;
        if (gotsigs & (1 << signo)) {
            if (EV_FLAG_HAS(ev, IS_BLK)) {
                ev->cb.signal_blk(ev, signo);
            } else {
                (*ev->cb.signal)(ev, signo, ev->priv);
            }
            _G.has_run = true;
        }
    }
}

static bool el_signal_has_pending_events(void)
{
    return _G.gotsigs;
}

void el_signal_set_hook(el_t ev, el_signal_f *cb)
{
    CHECK_EV_TYPE(ev, EV_SIGNAL);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    ev->cb.signal = cb;
}

ev_t *el_signal_register_d(int signo, el_signal_f *cb, el_data_t priv)
{
    struct sigaction sa;
    ev_t *ev;

    p_clear(&sa, 1);
    sa.sa_handler = el_sighandler;
    sigfillset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sigaction(signo, &sa, NULL);

    ev = el_create(EV_SIGNAL, cb, priv, false);
    ev->signo = signo;
    return ev_add(&_G.sigs, ev);
}

ev_t *el_signal_register_blk(int signo, el_signal_b blk, block_t wipe)
{
    return el_blk_register(el_signal_register(signo, NULL, NULL), blk, wipe);
}

el_data_t el_signal_unregister(ev_t **evp)
{
    if (*evp) {
        CHECK_EV_TYPE(*evp, EV_SIGNAL);
        return el_destroy(evp, true);
    }
    return (el_data_t)NULL;
}

/*----- child events -----*/

static void el_sigchld_hook(ev_t *ev, int signo, el_data_t priv)
{
    pid_t pid;
    int status;

    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        int32_t pos = qm_del_key(ev_assoc, &_G.childs, pid);

        if (likely(pos >= 0)) {
            ev_t *e = _G.childs.values[pos];

            if (EV_FLAG_HAS(e, IS_BLK)) {
                e->cb.child_blk(e, pid, status);
            } else {
                (*e->cb.child)(e, pid, status, e->priv);
            }
            el_destroy(&e, false);
        }
    }
}

void el_child_set_hook(el_t ev, el_child_f *cb)
{
    CHECK_EV_TYPE(ev, EV_CHILD);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    ev->cb.child = cb;
}

ev_t *el_child_register_d(pid_t pid, el_child_f *cb, el_data_t priv)
{
    static bool hooked;

    ev_t *ev = el_create(EV_CHILD, cb, priv, true);

    if (unlikely(!hooked)) {
        hooked = true;
        el_signal_register(SIGCHLD, el_sigchld_hook, NULL);
    }

    if (qm_add(ev_assoc, &_G.childs, pid, ev) < 0) {
        ASSERT("pid is already watched", false);
    }
    ev->pid = pid;
    return ev;
}

ev_t *el_child_register_blk(pid_t pid, el_child_b blk, block_t wipe)
{
    return el_blk_register(el_child_register(pid, NULL, NULL), blk, wipe);
}

el_data_t el_child_unregister(ev_t **evp)
{
    if (*evp) {
        CHECK_EV_TYPE(*evp, EV_CHILD);
        if (qm_del_key(ev_assoc, &_G.childs, (*evp)->pid) < 0)
            ASSERT("event not found", false);
        return el_destroy(evp, false);
    }
    return (el_data_t)NULL;
}

pid_t el_child_getpid(el_t ev)
{
    CHECK_EV_TYPE(ev, EV_CHILD);
    return ev->pid;
}

/*----- timer events -----*/
/*
 * timers are extremely efficient, and use a binary-min-heap as a base
 * structure.
 *
 * Binary min-heaps are balanced binary trees stored in an array.
 * The invariant is that the "label" (for us the millisecond the timer has to
 * start at) of each parent node, is smaller than any of its children ones.
 *
 * Hence the next to be run timer is the root of the heap.
 *
 * Adding/Updating/... a timer is pseudo linear O(log(n)) in the number of
 * timers.
 */

static void el_timer_process(uint64_t until)
{
    struct timeval tv;

    lp_gettv(&tv);
    while (!qhp_is_empty(timer, &_G.timers)) {
        ev_t *ev = qhp_first(timer, &_G.timers);

        ASSERT("should be a timer", ev->type == EV_TIMER);
        if (ev->timer.expiry > until)
            return;

        EV_FLAG_RST(ev, TIMER_UPDATED);
        if (EV_FLAG_HAS(ev, IS_BLK)) {
            ev->cb.cb_blk(ev);
        } else {
            (*ev->cb.cb)(ev, ev->priv);
        }
        _G.has_run = true;

        /* ev has been unregistered in (*cb) */
        if (ev->type == EV_UNUSED)
            continue;

        if (ev->timer.repeat > 0) {
            ev->timer.expiry += ev->timer.repeat;
            if (!EV_FLAG_HAS(ev, TIMER_NOMISS) && ev->timer.expiry < until) {
                uint64_t delta  = until - ev->timer.expiry;

                ev->timer.expiry += ROUND_UP(delta, (uint64_t)ev->timer.repeat);
            }
            __qhp_down(timer, &_G.timers, 0);
        } else
        if (!EV_FLAG_HAS(ev, TIMER_UPDATED)) {
            el_timer_unregister(&ev);
        }
    }
}

static uint64_t get_clock(bool lowres)
{
    struct timespec ts;
    int res;

    if (qhp_len(timer, &_G.timers) > 1 && lowres && likely(_G.lp_clk))
        return _G.lp_clk;

#if   defined(CLOCK_MONOTONIC) /* POSIX   */
    res = clock_gettime(CLOCK_MONOTONIC, &ts);
#elif defined(CLOCK_HIGHRES)   /* Solaris */
    res = clock_gettime(CLOCK_HIGHRES, &ts);
#else
#   error you need to find out how to get a monotonic clock for your system
#endif
    assert (res == 0);
    return _G.lp_clk = 1000ull * ts.tv_sec + ts.tv_nsec / 1000000;
}

static bool el_timer_has_pending_events(void)
{
    ev_t *ev;
    uint64_t now = 0;

    if (!qhp_is_empty(timer, &_G.timers) || _G.worker_running) {
        now = get_clock(false);
    }

    if (_G.worker_running) {
        if (_G.worker_end <= now) {
            return true;
        }
    }

    if (qhp_is_empty(timer, &_G.timers)) {
        return false;
    }

    ev = qhp_first(timer, &_G.timers);
    return ev->timer.expiry <= now;
}

ev_t *el_timer_register_d(int next, int repeat, int flags, el_cb_f *cb, el_data_t priv)
{
    ev_t *ev = el_create(EV_TIMER, cb, priv, true);

    if (flags & EL_TIMER_NOMISS)
        EV_FLAG_SET(ev, TIMER_NOMISS);
    if (flags & EL_TIMER_LOWRES)
        EV_FLAG_SET(ev, TIMER_LOWRES);
    if (repeat > 0) {
        ev->timer.repeat = repeat;
    } else {
        ev->timer.repeat = -next;
    }
    ev->timer.expiry = (uint64_t)next + get_clock(false);
    qhp_insert(timer, &_G.timers, ev);
    return ev;
}

ev_t *el_timer_register_blk(int next, int repeat, int flags, el_cb_b blk, block_t wipe)
{
    return el_blk_register(el_timer_register(next, repeat, flags, NULL, NULL),
                           blk, wipe);
}

void el_timer_set_hook(el_t ev, el_cb_f *cb)
{
    CHECK_EV_TYPE(ev, EV_TIMER);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    ev->cb.cb = cb;
}

static ALWAYS_INLINE void el_timer_restart_fast(ev_t *ev, uint64_t restart)
{
    ev->timer.expiry = (uint64_t)restart + get_clock(false);
    EV_FLAG_SET(ev, TIMER_UPDATED);
    qhp_fixup(timer, &_G.timers, ev->timer.heappos);
}

void el_timer_restart(ev_t *ev, int restart)
{
    CHECK_EV_TYPE(ev, EV_TIMER);
    ASSERT("timer isn't a oneshot timer", ev->timer.repeat <= 0);
    if (restart <= 0) {
        restart = -ev->timer.repeat;
    } else {
        ev->timer.repeat = -restart;
    }
    el_timer_restart_fast(ev, restart);
}

el_data_t el_timer_unregister(ev_t **evp)
{
    if (unlikely(!*evp))
        return (el_data_t)NULL;

    qhp_remove(timer, &_G.timers, (*evp)->timer.heappos);

    return el_destroy(evp, false);
}

bool el_timer_is_repeated(el_t ev)
{
    CHECK_EV_TYPE(ev, EV_TIMER);

    return ev->timer.repeat > 0;
}

/*----- fd events -----*/

static ALWAYS_INLINE ev_t *el_fd_act_timer_unregister(ev_t *timer)
{
    int pos = qm_del_key(ev, &_G.fd_act, (uint64_t)(uintptr_t)timer);
    ev_t *ev;

    assert (pos >= 0);
    ev = _G.fd_act.values[pos];
    EV_FLAG_RST(ev, FD_WATCHED);
    ev->priv = timer->priv;
    el_timer_unregister(&timer);
    return ev;
}

static ALWAYS_INLINE void el_fd_fire(ev_t *ev, short evs)
{
    const int fd = ev->fd;

    if (EV_IS_TRACED(ev)) {
        e_trace(0, "e-fdv(%p): got event %s%s (%04x)", ev,
                evs & POLLIN ? "IN" : "", evs & POLLOUT ? "OUT" : "", evs);
    }
    if (EV_FLAG_HAS(ev, FD_WATCHED)) {
        ev_t *timer = ev->priv.ptr;

        if (evs & ev->events_act)
            el_timer_restart_fast(timer, -timer->timer.repeat);
        if (EV_FLAG_HAS(ev, IS_BLK)) {
            ev->cb.fd_blk(ev, fd, evs);
        } else {
            (*ev->cb.fd)(ev, fd, evs, timer->priv);
        }
    } else {
        if (EV_FLAG_HAS(ev, IS_BLK)) {
            ev->cb.fd_blk(ev, fd, evs);
        } else {
            (*ev->cb.fd)(ev, fd, evs, ev->priv);
        }
    }
    _G.has_run = true;
}

static void el_act_timer(el_t ev, el_data_t priv)
{
    el_fd_fire(el_fd_act_timer_unregister(ev), EL_EVENTS_NOACT);
}

static ALWAYS_INLINE ev_t *el_fd_act_timer_register(ev_t *ev, int timeout)
{
    ev_t *timer = el_timer_register_d(timeout, 0, 0, &el_act_timer, ev->priv);

    ev->priv.ptr = el_unref(timer);
    EV_FLAG_SET(ev, FD_WATCHED);
    qm_replace(ev, &_G.fd_act, (uint64_t)(uintptr_t)timer, ev);
    return timer;
}

#ifdef __linux__
#  include "el-epoll.c"
#else
#  error one has to port el to your OS
#endif

ev_t *el_fd_register_blk(int fd, short events, el_fd_b blk, block_t wipe)
{
    return el_blk_register(el_fd_register(fd, events, NULL, NULL), blk, wipe);
}

void el_fd_set_hook(el_t ev, el_fd_f *cb)
{
    CHECK_EV_TYPE(ev, EV_FD);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    ev->cb.fd = cb;
}

short el_fd_get_mask(ev_t *ev)
{
    CHECK_EV_TYPE(ev, EV_FD);
    return ev->events_wanted;
}

int el_fd_get_fd(ev_t *ev)
{
    if (likely(ev)) {
        CHECK_EV_TYPE(ev, EV_FD);
        return ev->fd;
    }
    return -1;
}

int el_fd_watch_activity(el_t ev, short mask, int timeout)
{
    el_t timer;
    int res;

    CHECK_EV_TYPE(ev, EV_FD);

    ev->events_act = mask;
    if (!EV_FLAG_HAS(ev, FD_WATCHED)) {
        if (timeout <= 0)
            return 0;
        el_fd_act_timer_register(ev, timeout);
        return 0;
    }
    timer = ev->priv.ptr;
    res   = -timer->timer.repeat;

    if (timeout == 0) {
        el_fd_act_timer_unregister(timer);
    } else {
        el_timer_restart(timer, timeout);
    }
    return res;
}

int el_fd_loop(ev_t *ev, int timeout)
{
    struct pollfd pfd = { .fd = ev->fd, .events = ev->events_wanted };
    int res;

    CHECK_EV_TYPE(ev, EV_FD);

    res = poll(&pfd, 1, timeout);
    if (!qhp_is_empty(timer, &_G.timers))
        el_timer_process(get_clock(false));
    if (res == 1 && likely(ev->type == EV_FD))
        el_fd_fire(ev, pfd.revents);
    return res;
}

/*----- proxies events  -----*/

ev_t *el_proxy_register_d(el_proxy_f *cb, el_data_t priv)
{
    return ev_add(&_G.proxy, el_create(EV_PROXY, cb, priv, true));
}

ev_t *el_proxy_register_blk(el_proxy_b blk, block_t wipe)
{
    return el_blk_register(el_proxy_register(NULL, NULL), blk, wipe);
}

void el_proxy_set_hook(el_t ev, el_proxy_f *cb)
{
    CHECK_EV_TYPE(ev, EV_PROXY);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    ev->cb.prox = cb;
}

el_data_t el_proxy_unregister(ev_t **evp)
{
    if (*evp) {
        CHECK_EV_TYPE(*evp, EV_PROXY);
        return el_destroy(evp, true);
    }
    return (el_data_t)NULL;
}

static void el_proxy_change_ready(ev_t *ev, bool was_ready)
{
    dlist_move(was_ready ? &_G.proxy : &_G.proxy_ready, &ev->ev_list);
}

static short el_proxy_set_event_full(ev_t *ev, short evt)
{
    short old = ev->events_avail;

    if (old != evt) {
        bool was_ready = (old & ev->events_wanted) != 0;
        bool is_ready  = (evt & ev->events_wanted) != 0;

        ev->events_avail = evt;
        if (was_ready != is_ready)
            el_proxy_change_ready(ev, was_ready);
    }
    return old;
}

short el_proxy_set_event(ev_t *ev, short mask)
{
    return el_proxy_set_event_full(ev, ev->events_avail | mask);
}

short el_proxy_clr_event(ev_t *ev, short mask)
{
    return el_proxy_set_event_full(ev, ev->events_avail & ~mask);
}

short el_proxy_set_mask(ev_t *ev, short mask)
{
    short old = ev->events_wanted;

    if (old != mask) {
        bool was_ready = (old & ev->events_avail) != 0;
        bool is_ready  = (mask & ev->events_avail) != 0;

        ev->events_wanted = mask;
        if (was_ready != is_ready)
            el_proxy_change_ready(ev, was_ready);
    }
    return old;
}

static void el_loop_proxies(void)
{
    ev_cache_list(&_G.proxy_ready);
    for (int i = 0; i < _G.cache.len; i++) {
        ev_t *ev    = _G.cache.tab[i];
        int   avail = ev->events_avail;

        if (unlikely(ev->type == EV_UNUSED))
            continue;
        if (likely(avail & ev->events_wanted)) {
            if (EV_FLAG_HAS(ev, IS_BLK)) {
                ev->cb.proxy_blk(ev, avail);
            } else {
                (*ev->cb.prox)(ev, avail, ev->priv);
            }
            _G.has_run = true;
        }
    }
}


/*----- fs watch  ------*/
#ifdef HAVE_SYS_INOTIFY_H
#include <sys/inotify.h>

static void inotify_shutdown(void)
{
    assert (qm_len(ev, &_G.fs_watches) == 0);

    if (_G.inotify_fd == -1) {
        assert (_G.fs_watch == NULL);
        return;
    }

    el_fd_unregister(&_G.fs_watch, true);
    _G.inotify_fd = -1;
    qm_wipe(ev, &_G.fs_watches);
    qm_init(ev, &_G.fs_watches, false);
}

static el_data_t el_fs_watch_disable(ev_t **evp, bool unregister)
{
    if (EV_FLAG_HAS(*evp, FSW_ACTIVE)) {
        ev_t *ev = *evp;

        if (unregister) {
            inotify_rm_watch(_G.inotify_fd, ev->fs_watch.wd);
        } else {
            e_notice("watched object `%s` disapeared", ev->fs_watch.path);
        }

        EV_FLAG_RST(ev, FSW_ACTIVE);
        *evp = NULL;
        if (!EV_FLAG_HAS(ev, IS_BLK)) {
            return ev->priv;
        }
    } else {
        /* watcher removed due to file deletion  */
        p_delete(&(*evp)->fs_watch.path);
        return el_destroy(evp, false);
    }
    return (el_data_t)NULL;
}

static int inotify_cb(el_t el, int fd, short flags, el_data_t data)
{
    byte buf[sizeof(struct inotify_event) + NAME_MAX + 1];

    assert (el == _G.fs_watch);
    assert (fd == _G.inotify_fd);

    if (!(flags & POLLIN)) {
        return 0;
    }

    for (;;) {
        byte *next = buf;
        int   ret  = read(fd, buf, sizeof(buf));

        if (ret < 0 && errno == EAGAIN) {
            return 0;
        }
        RETHROW(ret);

        while (ret > 0) {
            struct inotify_event *e = (struct inotify_event *)next;
            int len = ROUND_UP(sizeof(struct inotify_event) + e->len, sizeof(void *));
            int pos;
            el_t wel;
            lstr_t name = LSTR_NULL;

            next += len;
            ret  -= len;
            assert (ret >= 0);

            /* Process event */
            pos = qm_find(ev, &_G.fs_watches, e->wd);
            if (pos < 0) {
                if (e->mask & IN_Q_OVERFLOW) {
                    e_fatal("overflow of the inotify queue. Two many events "
                            "occured in a short amount of time. You should "
                            "consider increasing the value of "
                            "/proc/sys/fs/inotify/max_queued_events");
                } else
                if (!(e->mask & IN_IGNORED)) {
                    e_panic("received inotify event for an unknown watch "
                            "descriptor %d", e->wd);
                }
                continue;
            }

            wel = _G.fs_watches.values[pos];
            assert (wel->fs_watch.wd == e->wd);
            if (e->mask & IN_IGNORED) {
                /* watcher deleted */
                qm_del_key(ev, &_G.fs_watches, wel->fs_watch.wd);
                el_fs_watch_disable(&wel, false);
            } else
            if (EV_FLAG_HAS(wel, FSW_ACTIVE)) {
                if (e->len) {
                    /* XXX We cannot use e->len - 1 as the string length
                     *     because e->name can be padded by several null bytes
                     */
                    name = LSTR_STR_V(e->name);
                }

                if (EV_FLAG_HAS(wel, IS_BLK)) {
                    wel->cb.fs_watch_blk(wel, e->mask, e->cookie, name);
                } else {
                    (*wel->cb.fs_watch)(wel, e->mask, e->cookie, name,
                                        wel->priv);
                }
            }
        }
        if (qm_len(ev, &_G.fs_watches) == 0) {
            inotify_shutdown();
            return 0;
        }
    }
}

static void inotify_initialize(void)
{
    if (unlikely(_G.inotify_fd == -1)) {
        assert (_G.fs_watch == NULL);

        _G.inotify_fd = inotify_init();
        if (_G.inotify_fd < 0)
            e_panic(E_UNIXERR("inotify_init"));
        fd_set_features(_G.inotify_fd, O_NONBLOCK | O_CLOEXEC);

        _G.fs_watch = el_fd_register(_G.inotify_fd, POLLIN, inotify_cb, NULL);
        _G.fs_watch = el_unref(_G.fs_watch);
    }
}

el_t el_fs_watch_register_d(const char *path, uint32_t flags,
                            el_fs_watch_f *cb, el_data_t priv)
{
    int pos;
    ev_t *ev;
    int  wd;

    inotify_initialize();
    wd = RETHROW_NP(inotify_add_watch(_G.inotify_fd, path, flags));
    pos = __qm_put(ev, &_G.fs_watches, wd, NULL, 0);
    if (pos & QHASH_COLLISION) {
        e_panic("you tried to add several watches on %s", path);
    }

    ev = el_create(EV_FS_WATCH, cb, priv, true);
    ev->fs_watch.path = p_strdup(path);
    ev->fs_watch.wd   = wd;
    EV_FLAG_SET(ev, FSW_ACTIVE);
    _G.fs_watches.keys[pos] = wd;
    _G.fs_watches.values[pos] = ev;
    return ev;
}

el_t el_fs_watch_register_blk(const char *path, uint32_t flags,
                              el_fs_watch_b blk, block_t wipe)
{
    el_t el = RETHROW_P(el_fs_watch_register(path, flags, NULL, NULL));

    return el_blk_register(el, blk, wipe);
}

el_data_t el_fs_watch_unregister(ev_t **evp)
{
    if (*evp) {
        CHECK_EV_TYPE(*evp, EV_FS_WATCH);
        return el_fs_watch_disable(evp, true);
    }
    return (el_data_t)NULL;
}

int el_fs_watch_change(el_t el, uint32_t flags)
{
    int wd;

    CHECK_EV_TYPE(el, EV_FS_WATCH);
    wd = RETHROW(inotify_add_watch(_G.inotify_fd, el->fs_watch.path, flags));
    assert (wd == el->fs_watch.wd);
    return 0;
}


#endif

/*----- generic functions  -----*/

el_worker_f *el_set_worker(el_worker_f *worker)
{
    SWAP(el_worker_f *, _G.worker, worker);
    return worker;
}

#ifndef NDEBUG
bool el_set_trace(el_t ev, bool trace)
{
    bool res = EV_FLAG_HAS(ev, TRACE);

    if (res == trace)
        return res;

    if (trace) {
        e_trace(0, "el(%p): trace", ev);
        EV_FLAG_SET(ev, TRACE);
    } else {
        e_trace(0, "el(%p): untrace", ev);
        EV_FLAG_RST(ev, TRACE);
    }
    return res;
}
#endif

el_t el_ref(ev_t *ev)
{
    CHECK_EV(ev);
    if (!EV_FLAG_HAS(ev, REFS)) {
        _G.active++;
        EV_FLAG_SET(ev, REFS);
    }
    return ev;
}

el_t el_unref(ev_t *ev)
{
    CHECK_EV(ev);
    if (EV_FLAG_HAS(ev, REFS)) {
        _G.active--;
        EV_FLAG_RST(ev, REFS);
    }
    return ev;
}

el_data_t el_set_priv(ev_t *ev, el_data_t priv)
{
    CHECK_EV(ev);
    assert (!EV_FLAG_HAS(ev, IS_BLK));
    if (ev->type == EV_FD && EV_FLAG_HAS(ev, FD_WATCHED))
        return el_set_priv(ev->priv.ptr, priv);
    SWAP(el_data_t, ev->priv, priv);
    return priv;
}

#include "el-showflags.c"

void el_loop_timeout(int timeout)
{
    uint64_t clk = get_clock(false);

    _G.loop_depth++;
    el_timer_process(clk);
    if (!qhp_is_empty(timer, &_G.timers)) {
        uint64_t nxt = qhp_first(timer, &_G.timers)->timer.expiry;
        if (nxt < (uint64_t)timeout + clk)
            timeout = nxt - clk;
    }
    do_license_checks();
    if (unlikely(_G.unloop)) {
        _G.loop_depth--;
        return;
    }
    ev_list_process(&_G.before);
    el_idle_process(clk);
    if (!dlist_is_empty(&_G.proxy_ready) || !dlist_is_empty(&_G.idle))
        timeout = 0;
    if (_G.worker && timeout && !el_has_pending_events()) {
        uint64_t start, end;
        int diff;

        start = get_clock(false);
        _G.worker_running = true;
        _G.worker_end     = start + timeout;
        (*_G.worker)(timeout);
        _G.worker_running = false;;
        end = get_clock(false);

        diff = end - start;
        if (diff > timeout + 100) {
            e_warning("worker is too long: %dms while expected %dms",
                      diff, timeout);
        } else
        if (diff > MAX(timeout * 2, timeout + 10)) {
            e_trace(0, "worker is too long: %dms while expecting %dms",
                    diff, timeout);
        }
        timeout = MAX(0, timeout - diff);
    }
    el_loop_fds(timeout);
    el_loop_proxies();
    el_signal_process();
    if (_G.loop_depth <= 1) {
        /* To be reentrant we can't reuse unregistered el_t until we came back
         * to the main loop */
        assert (_G.loop_depth == 1);
        dlist_splice(&_G.evs_free, &_G.evs_gc);
    }
    _G.loop_depth--;
}

void el_bl_use(void)
{
    pthread_mutexattr_t attr;

    if (use_big_lock_g)
        e_panic("el bl use has been called twice !");

    use_big_lock_g = true;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);
    pthread_mutex_init(&big_lock_g, &attr);
    pthread_mutexattr_destroy(&attr);
    el_bl_lock();
}

void el_bl_lock(void)
{
    if (use_big_lock_g)
        pthread_mutex_lock(&big_lock_g);
}

void el_bl_unlock(void)
{
    if (use_big_lock_g)
        pthread_mutex_unlock(&big_lock_g);
}

void el_cond_wait(pthread_cond_t *cond)
{
    pthread_cond_wait(cond, &big_lock_g);
}

void el_cond_signal(pthread_cond_t *cond)
{
    pthread_cond_signal(cond);
}

void el_loop(void)
{
    while (likely(_G.active) && likely(!_G.unloop)) {
        el_loop_timeout(59000); /* arbitrary: 59 seconds */
    }
    _G.unloop = false;
}

void el_unloop(void)
{
    _G.unloop = true;
}

bool el_has_pending_events(void)
{
    return el_signal_has_pending_events()
        || el_timer_has_pending_events()
        || el_fds_has_pending_events();
}

static const char *ev_type_to_str(ev_type_t type)
{
    switch (type) {
      case EV_UNUSED:   return "unused";
      case EV_BLOCKER:  return "blocker";
      case EV_BEFORE:   return "before loop";
      case EV_SIGNAL:   return "signal";
      case EV_CHILD:    return "child";
      case EV_FD:       return "file desc.";
      case EV_TIMER:    return "timer";
      case EV_PROXY:    return "proxy";
      case EV_IDLE:     return "idle";
      case EV_FS_WATCH: return "fs watch";
    }
    return "unknown";
}

static void el_show_blockers(el_t evh, int signo, el_data_t priv)
{
    SB_1k(sb);

    e_notice("el blocking summary");
    e_notice("===================");

    for (int i = 0; i < _G.evs_len; i++) {
        int bucket_len = 1 << (i + EV_ALLOC_FACTOR);

        for (int j = 0; j < bucket_len; j++) {
            ev_t *ev = &_G.evs[i][j];

            if (ev->type == EV_UNUSED || !EV_FLAG_HAS(ev, REFS))
                continue;

            sb_setf(&sb, "ev %p │ cb %p │ data %p │ type %d %s", ev,
                    (void *)ev->cb.cb, ev->priv.ptr, ev->type,
                    ev_type_to_str(ev->type));

            switch (ev->type) {
              case EV_SIGNAL:
                sb_addf(&sb, ":%d", ev->signo);
                break;
              case EV_CHILD:
                sb_addf(&sb, ":%d", ev->pid);
                break;
              case EV_FD:
                sb_addf(&sb, ":%d (%04x)", ev->fd, ev->events_wanted);
                break;
              case EV_TIMER:
                if (ev->timer.repeat < 0) {
                    sb_addf(&sb, " one shot @%ju", ev->timer.expiry / 1000);
                } else {
                    sb_addf(&sb, " repeat:%dms next @%ju", ev->timer.repeat,
                                ev->timer.expiry / 1000);
                }
                break;
              case EV_PROXY:
                sb_addf(&sb, ":(w:%04x a:%04x)", ev->events_wanted, ev->events_avail);
                break;
              default:
                break;
            }
            e_notice("%*pM", SB_FMT_ARG(&sb));
        }
    }
}

static __attribute__((constructor)) void
hook_sigpwr(void)
{
    el_signal_register(SIGPWR, el_show_blockers, NULL);
}

__attribute__((constructor))
static void el_initialize(void)
{
    struct timeval tm;
    struct rlimit lim;

    gettimeofday(&tm, NULL);
    srand(tm.tv_sec + tm.tv_usec + getpid());
    ha_srand();

    if (getrlimit(RLIMIT_NOFILE, &lim) < 0)
        e_panic(E_UNIXERR("getrlimit"));
    if (lim.rlim_cur < lim.rlim_max) {
        lim.rlim_cur = lim.rlim_max;
        if (setrlimit(RLIMIT_NOFILE, &lim) < 0)
            e_error(E_UNIXERR("setrlimit"));
    }

    if (!is_fd_open(STDIN_FILENO)) {
        devnull_dup(STDIN_FILENO);
    }
    if (!is_fd_open(STDOUT_FILENO)) {
        devnull_dup(STDOUT_FILENO);
    }
    if (!is_fd_open(STDERR_FILENO)) {
        dup2(STDOUT_FILENO, STDERR_FILENO);
    }
}

__attribute__((destructor))
static void el_shutdown(void)
{
    /* Wipe all containers in order to remove traces in valgrind, however
     * ensure they remain valid in case some other destructor perform el
     * registrations/unregistrations.
     */

    if (_G.timers.len == 0) {
        qhp_wipe(timer, &_G.timers);
        qhp_init(timer, &_G.timers);
    }
    if (qm_len(ev_assoc, &_G.childs) == 0) {
        qm_wipe(ev_assoc, &_G.childs);
        qm_init(ev_assoc, &_G.childs, false);
    }
    if (qm_len(ev, &_G.fd_act) == 0) {
        qm_wipe(ev, &_G.fd_act);
        qm_init(ev, &_G.fd_act, false);
    }
    if (qm_len(ev, &_G.fs_watches) == 0) {
        qm_wipe(ev, &_G.fs_watches);
        qm_init(ev, &_G.fs_watches, false);
    }

    qv_wipe(ev, &_G.cache);
    qv_init(ev, &_G.cache);
}

/**\}*/
/* Tests {{{ */

#include "z.h"
#include "net.h"

struct z_el_data {
    int  calls;
    bool end;
};

static int readall(el_t el, int fd, short ev, el_data_t priv)
{
    struct z_el_data *d = priv.ptr;
    byte buf[BUFSIZ];

    while (read(fd, buf, sizeof(buf)) > 0) {
        continue;
    }
    d->calls++;
    return 0;
}

static int writeall(el_t el, int fd, short ev, el_data_t priv)
{
    t_scope;
    struct z_el_data *d = priv.ptr;
    byte *data;
    socklen_t data_sz = sizeof(size_t);
    size_t bufsiz = 0;

    assert (ev & POLLOUT);

    if (d->end) {
        return 0;
    }

    assert (getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &bufsiz, &data_sz) == 0);
    data = t_new(byte, bufsiz);

    while (write(fd, data, bufsiz) > 0) {
        continue;
    }
    d->calls++;
    return 0;
}

static void fs_notify(el_t el, uint32_t event, uint32_t cookie,
                      lstr_t name, el_data_t data)
{
    (*(int *)data.ptr)++;
}

Z_GROUP_EXPORT(el)
{
    Z_TEST(fd_priority, "el: priority") {
        t_scope;
        el_t *els   = t_new(el_t, 2 *3);
        struct z_el_data *calls = t_new(struct z_el_data, 3);

        for (int i = 0; i < 3; i++) {
            int fds[2];

            socketpairx(AF_UNIX, SOCK_STREAM, 0, O_NONBLOCK, fds);

            els[2 * i] = el_fd_register(fds[0], POLLIN, &readall, &calls[i]);
            els[2 * i + 1] = el_fd_register(fds[1], POLLOUT, &writeall, &calls[i]);
        }

        el_loop_timeout(100);
        Z_ASSERT_EQ(1, calls[0].calls);
        Z_ASSERT_EQ(1, calls[1].calls);
        Z_ASSERT_EQ(1, calls[2].calls);
        el_loop_timeout(100);
        Z_ASSERT_EQ(2, calls[0].calls);
        Z_ASSERT_EQ(2, calls[1].calls);
        Z_ASSERT_EQ(2, calls[2].calls);

        el_fd_set_priority(els[2 * 2], HIGH);
        el_fd_set_priority(els[2 * 2 + 1], HIGH);
        for (int j = 0; j < 5; j++) {
            el_loop_timeout(100);
            Z_ASSERT_EQ(2, calls[0].calls);
            Z_ASSERT_EQ(2, calls[1].calls);
            Z_ASSERT_EQ(2 + (2 * j) + 1, calls[2].calls);

            el_loop_timeout(100);
            Z_ASSERT_EQ(2, calls[0].calls);
            Z_ASSERT_EQ(2, calls[1].calls);
            Z_ASSERT_EQ(2 + (2 * j) + 2, calls[2].calls);
        }

        calls[2].end = true;

        /* writeall will be callsed on 2, since POLLOUT is ok and it has HIGH
         * priority
         */
        Z_ASSERT_EQ(2, calls[0].calls);
        Z_ASSERT_EQ(2, calls[1].calls);
        Z_ASSERT_EQ(12, calls[2].calls);
        el_fd_set_mask(els[2 * 2 + 1], 0);


        el_fd_set_priority(els[1 * 2], LOW);
        el_fd_set_priority(els[1 * 2 + 1], LOW);

        el_loop_timeout(100);
        el_loop_timeout(100);
        Z_ASSERT_EQ(4, calls[0].calls);
        Z_ASSERT_EQ(2, calls[1].calls);
        Z_ASSERT_EQ(12, calls[2].calls);

        calls[0].end = true;
        el_fd_set_mask(els[0 * 2 + 1], 0);

        el_loop_timeout(100);
        el_loop_timeout(100);
        Z_ASSERT_EQ(4, calls[0].calls);
        Z_ASSERT_EQ(4, calls[1].calls);
        Z_ASSERT_EQ(12, calls[2].calls);

        for (int i = 0; i < 6; i++) {
            el_fd_unregister(&els[i], true);
        }
    } Z_TEST_END;

    Z_TEST(fs_watch, "el: inotify binding") {
        t_scope;
        el_t watch;
        int fd;
        int called = 0;

        watch = el_fs_watch_register(z_grpdir_g.s, IN_CREATE, fs_notify, &called);

        fd = open(t_fmt(NULL, "%s/blah", z_grpdir_g.s),
                  O_WRONLY | O_CREAT, 0660);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 1);
        close(fd);

        fd = open(t_fmt(NULL, "%s/blah", z_grpdir_g.s),
                  O_WRONLY | O_CREAT, 0660);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 1);
        close(fd);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 1);

        el_fs_watch_change(watch, IN_OPEN | IN_CLOSE);


        fd = open(t_fmt(NULL, "%s/blah2", z_grpdir_g.s),
                  O_WRONLY | O_CREAT, 0660);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 2);
        close(fd);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 3);

        fd = open(t_fmt(NULL, "%s/blah2", z_grpdir_g.s),
                  O_WRONLY | O_CREAT, 0660);
        close(fd);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 5);

        el_fs_watch_unregister(&watch);
    } Z_TEST_END;

    Z_TEST(fs_watch_delete, "el: inotify file unregister handling") {
        t_scope;
        el_t watch;
        el_t dummy_watch;
        int fd;
        int called = 0;
        int dummy_called = 0;
        char *filename  = t_fmt(NULL, "%*pM/blah", LSTR_FMT_ARG(z_grpdir_g));
        char *dummy = t_fmt(NULL, "%*pM/dummy", LSTR_FMT_ARG(z_grpdir_g));

        /* Create 2 file */
        fd = open(filename, O_CREAT, 0660);
        close(fd);
        fd = open(dummy, O_CREAT, 0660);
        close(fd);

        /* Add watch descriptors */
        watch = el_fs_watch_register(filename, IN_ALL_EVENTS, fs_notify,
                                     &called);
        dummy_watch = el_fs_watch_register(dummy, IN_ALL_EVENTS, fs_notify,
                                           &dummy_called);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 0);

        /* Send 3 events */
        fd = open(filename, O_WRONLY, 0660);
        Z_ASSERT_N(write(fd, "coucou", strlen("coucou")));
        close(fd);

        /* Unregister watch */
        el_fs_watch_unregister(&watch);

        /* We get a panic here if the watcher removal isn't delayed */
        el_loop_timeout(100);

        Z_ASSERT_EQ(called, 0);

        unlink(filename);
        el_loop_timeout(100);
        Z_ASSERT_EQ(called, 0);

        el_fs_watch_unregister(&dummy_watch);
        el_loop_timeout(100);
        Z_ASSERT_EQ(dummy_called, 0);
    } Z_TEST_END;
} Z_GROUP_END;

/* }}} */
