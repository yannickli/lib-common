/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2017 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "iopc.h"

#define RO_WARN \
    "/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/\n"

static const char *t_pp_under(const iopc_path_t *path)
{
    sb_t buf;

    t_sb_init(&buf, 128);
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s__", bit);
    }
    sb_shrink(&buf, 2);

    return buf.data;
}

static lstr_t t_enum_get_prefix(iopc_enum_t *en)
{
    lstr_t ns = LSTR_NULL;

    if (t_iopc_attr_check_prefix(&en->attrs, &ns) < 0) {
        ns = t_camelcase_to_c(LSTR(en->name));
    }
    lstr_ascii_toupper(&ns);
    return ns;
}

static void iopc_dump_extensions(sb_t *buf, const iopc_pkg_t *pkg,
                                 const char *pkg_name)
{
    t_scope;

    tab_for_each_entry(st, &pkg->structs) {
        lstr_t name = t_camelcase_to_c(LSTR(st->name));

        sb_addf(buf,
                "extension %s__%*pM__array_t : Iop%sArray { }\n\n",
                pkg_name, LSTR_FMT_ARG(name),
                iopc_is_class(st->type) ? "Class" : "ComplexType");
    }

    tab_for_each_entry(en, &pkg->enums) {
        lstr_t name = t_camelcase_to_c(LSTR(en->name));
        lstr_t c_prefix = t_enum_get_prefix(en);

        sb_addf(buf,
                "extension %s__%*pM__t : IopEnum {\n"
                "    public static let descriptor = %s__%*pM__ep\n"
                "    public static let min : Int32 = %*pM_min\n"
                "    public static let max : Int32 = %*pM_max\n"
                "    public static let count : Int32 = %*pM_count\n"
                "}\n"
                "extension %s__%*pM__array_t : IopSimpleArray { }\n"
                "extension %s__%*pM__opt_t : IopOptional { }\n\n",
                pkg_name, LSTR_FMT_ARG(name), pkg_name, LSTR_FMT_ARG(name),
                LSTR_FMT_ARG(c_prefix), LSTR_FMT_ARG(c_prefix),
                LSTR_FMT_ARG(c_prefix),
                pkg_name, LSTR_FMT_ARG(name), pkg_name, LSTR_FMT_ARG(name));
    }
}

int iopc_do_swift(iopc_pkg_t *pkg, const char *outdir, sb_t *depbuf)
{
    t_scope;
    const char *pkg_name = t_pp_under(pkg->name);
    char path[PATH_MAX];
    SB(buf, 32 << 10);

    iopc_set_path(outdir, pkg, ".iop.swift", sizeof(path), path, true);


    sb_adds(&buf, RO_WARN);

    /* Generate imports */

    /* Generate C types extensions */
    iopc_dump_extensions(&buf, pkg, pkg_name);

    /* Generate Swift package */
    if (pkg->name->bits.len > 1) {
        sb_addf(&buf, "public extension ");
        tab_for_each_pos(pos, &pkg->name->bits) {
            if (pos != pkg->name->bits.len - 1) {
                if (pos != 0) {
                    sb_addc(&buf, '.');
                }
                sb_adds(&buf, pkg->name->bits.tab[pos]);
            }
        }
        sb_adds(&buf, "{\n");
    }
    sb_addf(&buf, "public enum %s : IopPackage {\n",
            *qv_last(&pkg->name->bits));

    /* Generate types */
    sb_addf(&buf,
            "    public static let classes : [IopClass.Type] = []\n"
            "}\n");
    if (pkg->name->bits.len > 1) {
        sb_adds(&buf, "}\n");
    }

    return iopc_write_file(&buf, path);
}
