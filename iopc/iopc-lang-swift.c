/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "iopc.h"

struct iopc_do_swift_globs iopc_do_swift_g;
#define _G  iopc_do_swift_g

#define RO_WARN \
    "/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/\n"

static const char *t_pp_under(const iopc_path_t *path)
{
    sb_t buf;

    t_sb_init(&buf, 128);
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s__", bit);
    }
    sb_shrink(&buf, 2);

    return buf.data;
}

static lstr_t t_enum_get_prefix(iopc_enum_t *en)
{
    lstr_t ns = LSTR_NULL;

    if (t_iopc_attr_check_prefix(&en->attrs, &ns) < 0) {
        ns = t_camelcase_to_c(LSTR(en->name));
    }
    lstr_ascii_toupper(&ns);
    return ns;
}

static void iopc_dump_string_literal(sb_t *buf, const char *str)
{
    int len = strlen(str);
    int pos = 0;
    int c;

    while ((c = utf8_ngetc_at(str, len, &pos)) >= 0) {
        if (c < 128) {
            switch (c) {
              case '\n':
                sb_adds(buf, "\\n");
                break;
              case '\\':
              case '"':
                sb_addc(buf, '\\');
              /* fallthrough */
              default:
                sb_addc(buf, c);
            }
        } else {
            sb_addf(buf, "\\u{%x}", c);
        }
    }
}

static void dump_package_alias_(sb_t *buf, iopc_path_t *path, int len)
{
    assert (len > 0 && len <= path->bits.len);
    for (int i = 0; i < len; i++) {
        sb_addf(buf, "%s_", path->bits.tab[i]);
    }
    sb_adds(buf, "package");
}

static void dump_package_alias(sb_t *buf, iopc_path_t *path)
{
    dump_package_alias_(buf, path, path->bits.len);
}

static void
iopc_dump_package_member(sb_t *buf, iopc_path_t *path, const char *type)
{
    assert (path->bits.len);
    for (int i = 0; i < path->bits.len; i++) {
        dump_package_alias_(buf, path, i + 1);
        sb_addc(buf, '.');
    }
    sb_addf(buf, "%s", type);
}

static void dump_package_interface(sb_t *buf, iopc_path_t *path)
{
    iopc_dump_package_member(buf, path, "interfaces");
}

static void t_iopc_collect_dumped_struct_fields(const iopc_pkg_t *src_pkg,
                                                const iopc_pkg_t *pkg,
                                                const iopc_struct_t *st,
                                                qh_t(lstr) *dumped)
{
    if (iopc_is_snmp_st(st->type)) {
        return;
    }

    tab_for_each_entry(attr, &st->attrs) {
        if (attr->desc->id == IOPC_ATTR_SWIFT_DUMP_ARRAY) {
            lstr_t name = t_camelcase_to_c(LSTR(st->name));

            name = t_lstr_fmt("%s__%*pM__array_t", t_pp_under(pkg->name),
                              LSTR_FMT_ARG(name));
            qh_add(lstr, dumped, &name);
            break;
        }
    }

    tab_for_each_entry(field, &st->fields) {
        const iopc_pkg_t *p = pkg;
        lstr_t name;

        if (field->repeat != IOP_R_REPEATED) {
            continue;
        }

        switch (field->kind) {
          case IOP_T_STRUCT:
          case IOP_T_UNION:
          case IOP_T_ENUM:
            name = t_camelcase_to_c(LSTR(field->type_name));
            break;

          default:
            continue;
        }

        if (field->type_pkg) {
            p = field->type_pkg;
        }
        if (p != src_pkg) {
            name = t_lstr_fmt("%s__%*pM__array_t", t_pp_under(p->name),
                              LSTR_FMT_ARG(name));
            qh_add(lstr, dumped, &name);
        }
    }
}

static void t_iopc_collect_dumped_array_types(const iopc_pkg_t *src_pkg,
                                              const iopc_pkg_t *pkg,
                                              qh_t(lstr) *dumped)
{
    tab_for_each_entry(en, &pkg->enums) {
        tab_for_each_entry(attr, &en->attrs) {
            if (attr->desc->id == IOPC_ATTR_SWIFT_DUMP_ARRAY) {
                lstr_t name = t_camelcase_to_c(LSTR(en->name));

                name = t_lstr_fmt("%s__%*pM__array_t", t_pp_under(pkg->name),
                                  LSTR_FMT_ARG(name));
                qh_add(lstr, dumped, &name);
                break;
            }
        }
    }

    tab_for_each_entry(st, &pkg->structs) {
        t_iopc_collect_dumped_struct_fields(src_pkg, pkg, st, dumped);
    }

    tab_for_each_entry(iface, &pkg->ifaces) {
        tab_for_each_entry(rpc, &iface->funs) {
            if (rpc->arg && rpc->arg_is_anonymous) {
                t_iopc_collect_dumped_struct_fields(src_pkg, pkg, rpc->arg,
                                                    dumped);
            }
            if (rpc->res && rpc->res_is_anonymous) {
                t_iopc_collect_dumped_struct_fields(src_pkg, pkg, rpc->res,
                                                    dumped);
            }
            if (rpc->exn && rpc->exn_is_anonymous) {
                t_iopc_collect_dumped_struct_fields(src_pkg, pkg, rpc->exn,
                                                    dumped);
            }
        }
    }
}

static void t_iopc_dump_struct_deps(sb_t *buf, const iopc_pkg_t *pkg,
                                    const iopc_struct_t *st,
                                    qh_t(lstr) *dumped)
{
    if (iopc_is_snmp_st(st->type)) {
        return;
    }

    tab_for_each_entry(field, &st->fields) {
        lstr_t name;

        if (field->repeat != IOP_R_REPEATED) {
            continue;
        }

        switch (field->kind) {
          case IOP_T_STRUCT:
          case IOP_T_UNION:
            name = t_camelcase_to_c(LSTR(field->struct_def->name));
            break;

          case IOP_T_ENUM:
            name = t_camelcase_to_c(LSTR(field->enum_def->name));
            break;

          default:
            continue;
        }

        name = t_lstr_fmt("%s__%*pM__array_t",
                          t_pp_under(field->type_pkg->name),
                          LSTR_FMT_ARG(name));
        if (qh_add(lstr, dumped, &name) >= 0) {
            sb_addf(buf, "extension %*pM : libcommon.IopArray { }\n",
                    LSTR_FMT_ARG(name));
        }
    }
}

static void iopc_dump_extensions(sb_t *buf, const iopc_pkg_t *pkg,
                                 const char *pkg_name)
{
    t_scope;
    qh_t(lstr) dumped;

    t_qh_init(lstr, &dumped, 128);

    tab_for_each_entry(st, &pkg->structs) {
        if (iopc_is_snmp_st(st->type)) {
            continue;
        }

        tab_for_each_entry(attr, &st->attrs) {
            if (attr->desc->id == IOPC_ATTR_SWIFT_DUMP_ARRAY) {
                lstr_t name = t_camelcase_to_c(LSTR(st->name));

                sb_addf(buf, "extension %s__%*pM__array_t: libcommon.IopArray { }\n",
                        t_pp_under(pkg->name), LSTR_FMT_ARG(name));
                qh_add(lstr, &dumped, &name);
                break;
            }
        }
    }

    tab_for_each_entry(en, &pkg->enums) {
        tab_for_each_entry(attr, &en->attrs) {
            if (attr->desc->id == IOPC_ATTR_SWIFT_DUMP_ARRAY) {
                lstr_t name = t_camelcase_to_c(LSTR(en->name));

                sb_addf(buf, "extension %s__%*pM__array_t : libcommon.IopArray { }\n",
                        t_pp_under(pkg->name), LSTR_FMT_ARG(name));
                qh_add(lstr, &dumped, &name);
                break;
            }
        }
    }

    qh_for_each_pos(iopc_pkg, pos, &pkg->deps) {
        t_iopc_collect_dumped_array_types(pkg, pkg->deps.keys[pos], &dumped);
    }

    tab_for_each_entry(st, &pkg->structs) {
        t_iopc_dump_struct_deps(buf, pkg, st, &dumped);
    }

    tab_for_each_entry(iface, &pkg->ifaces) {
        tab_for_each_entry(rpc, &iface->funs) {
            if (rpc->arg && rpc->arg_is_anonymous) {
                t_iopc_dump_struct_deps(buf, pkg, rpc->arg, &dumped);
            }
            if (rpc->res && rpc->res_is_anonymous) {
                t_iopc_dump_struct_deps(buf, pkg, rpc->res, &dumped);
            }
            if (rpc->exn && rpc->exn_is_anonymous) {
                t_iopc_dump_struct_deps(buf, pkg, rpc->exn, &dumped);
            }
        }
    }

    tab_for_each_entry(en, &pkg->enums) {
        lstr_t name = t_camelcase_to_c(LSTR(en->name));
        lstr_t c_prefix = t_enum_get_prefix(en);

        sb_addf(buf,
                "extension %s__%*pM__t : libcommon.IopEnum {\n"
                "    public static let descriptor = %s__%*pM__ep\n"
                "    public static let min : Swift.Int32 = Swift.Int32(%*pM_min)\n"
                "    public static let max : Swift.Int32 = Swift.Int32(%*pM_max)\n"
                "    public static let count : Swift.Int32 = Swift.Int32(%*pM_count)\n"
                "}\n",
                pkg_name, LSTR_FMT_ARG(name), pkg_name, LSTR_FMT_ARG(name),
                LSTR_FMT_ARG(c_prefix), LSTR_FMT_ARG(c_prefix),
                LSTR_FMT_ARG(c_prefix));
    }
}

static void iopc_dump_enums(sb_t *buf, const iopc_pkg_t *pkg,
                            const char *pkg_name)
{
    t_scope;

    tab_for_each_entry(en, &pkg->enums) {
        lstr_t name = t_camelcase_to_c(LSTR(en->name));

        sb_addf(buf, "    public typealias %s = %s__%*pM__t\n\n",
                en->name, pkg_name, LSTR_FMT_ARG(name));
    }
}

static void iopc_dump_field_basetype(sb_t *buf, const iopc_field_t *field)
{
    switch (field->kind) {
      case IOP_T_I8: sb_adds(buf, "Swift.Int8"); break;
      case IOP_T_U8: sb_adds(buf, "Swift.UInt8"); break;
      case IOP_T_I16: sb_adds(buf, "Swift.Int16"); break;
      case IOP_T_U16: sb_adds(buf, "Swift.UInt16"); break;
      case IOP_T_I32: sb_adds(buf, "Swift.Int32"); break;
      case IOP_T_U32: sb_adds(buf, "Swift.UInt32"); break;
      case IOP_T_I64: sb_adds(buf, "Swift.Int64"); break;
      case IOP_T_U64: sb_adds(buf, "Swift.UInt64"); break;
      case IOP_T_BOOL: sb_adds(buf, "Swift.Bool"); break;
      case IOP_T_DOUBLE: sb_adds(buf, "Swift.Double"); break;
      case IOP_T_VOID: sb_adds(buf, "libcommon.IopVoid"); break;

      case IOP_T_STRING: case IOP_T_XML:
        sb_adds(buf, "Swift.String");
        break;

      case IOP_T_DATA:
        sb_adds(buf, "[Swift.Int8]");
        break;

      case IOP_T_STRUCT: case IOP_T_UNION: case IOP_T_ENUM:
        iopc_dump_package_member(buf, field->type_path, field->type_name);
        break;
    }
}

static void iopc_dump_field_type(sb_t *buf, const iopc_field_t *field)
{
    if (field->repeat == IOP_R_REPEATED) {
        sb_addc(buf, '[');
    }

    iopc_dump_field_basetype(buf, field);

    if (field->repeat == IOP_R_REPEATED) {
        sb_addc(buf, ']');
    } else
    if (field->repeat == IOP_R_OPTIONAL) {
        sb_addc(buf, '?');
    }
}

static bool iopc_field_has_default_value(const iopc_field_t *field);
static bool iopc_struct_has_void_initializer(const iopc_struct_t *st,
                                             bool allow_abstract)
{
    if (!allow_abstract && (iopc_is_class(st->type) && st->is_abstract)) {
        return false;
    }

    tab_for_each_entry(field, &st->fields) {
        if (!iopc_field_has_default_value(field)) {
            return false;
        }
    }

    if (st->extends.len) {
        return iopc_struct_has_void_initializer(st->extends.tab[0]->st, true);
    }
    return true;
}

static bool iopc_field_has_default_value(const iopc_field_t *field)
{
    if (field->repeat != IOP_R_REQUIRED) {
        return true;
    }

    switch (field->kind) {
      case IOP_T_STRUCT:
        return iopc_struct_has_void_initializer(field->struct_def, false);

      case IOP_T_VOID:
        return true;

      default:
        return false;
    }
}

static void iopc_dump_field_defval(sb_t *buf, const iopc_field_t *field)
{
    SB_1k(tmp);

    switch (field->repeat) {
      case IOP_R_REQUIRED:
        if (iopc_field_has_default_value(field)) {
            sb_adds(buf, " = ");
            iopc_dump_field_basetype(buf, field);
            sb_adds(buf, "()");
        }
        break;

      case IOP_R_OPTIONAL:
        sb_adds(buf, " = nil");
        break;

      case IOP_R_REPEATED:
        sb_adds(buf, " = []");
        break;

      case IOP_R_DEFVAL:
        switch (field->kind) {
          case IOP_T_ENUM: {
            bool has_named_value = false;
            bool is_strict = false;

            tab_for_each_entry(attr, &field->enum_def->attrs) {
                if (attr->desc->id == IOPC_ATTR_STRICT) {
                    is_strict = true;
                    break;
                }
            }
            sb_adds(buf, " = ");
            if (is_strict) {
                tab_for_each_entry(v, &field->enum_def->values) {
                    if ((uint64_t)v->value == field->defval.u64) {
                        lstr_t value_name = t_lstr_dups(v->name, -1);

                        lstr_ascii_tolower(&value_name);
                        c_to_camelcase(value_name, false, &tmp);
                        sb_addf(buf, ".%s", tmp.data);
                        has_named_value = true;
                        break;
                    }
                }
            }
            if (!has_named_value) {
                iopc_dump_field_basetype(buf, field);
                sb_addf(buf, "(rawValue: %jd)", field->defval.u64);
                if (is_strict) {
                    sb_addc(buf, '!');
                }
            }
          } break;
          case IOP_T_I8 ... IOP_T_U64:
            if (field->defval_is_signed) {
                sb_addf(buf, " = %jd", field->defval.u64);
            } else {
                sb_addf(buf, " = %ju", field->defval.u64);
            }
            break;
          case IOP_T_BOOL:
            sb_addf(buf, " = %s", field->defval.u64 ? "true" : "false");
            break;
          case IOP_T_DOUBLE:
            sb_addf(buf, " = "DOUBLE_FMT, field->defval.d);
            break;
          case IOP_T_STRING:
          case IOP_T_XML:
            /* Perform an octal escaping */
            sb_adds(buf, " = \"");
            iopc_dump_string_literal(buf, field->defval.ptr);
            sb_addc(buf, '"');
            break;

          case IOP_T_DATA: {
            const char *data = field->defval.ptr;

            sb_adds(buf, " = [ ");
            while (*data) {
                sb_addf(buf, "%d", *data);
                data++;
                if (*data) {
                    sb_adds(buf, ", ");
                }
            }
            sb_adds(buf, " ]");
          } break;

          case IOP_T_UNION:
          case IOP_T_STRUCT:
          case IOP_T_VOID:
            assert (false);
            break;
        }
        break;
    }
}

static void iopc_dump_struct_value_importer(sb_t *buf, const char *indent,
                                            const iopc_field_t *field,
                                            const char *source,
                                            const char *action)
{
    switch (field->kind) {
      case IOP_T_I8...IOP_T_DOUBLE:
        sb_addf(buf, "%s        %s %s", indent, action, source);
        break;

      case IOP_T_STRING: case IOP_T_XML:
        sb_addf(buf, "%s        %s Swift.String(%s) ?? \"\"",
                indent, action, source);
        break;

      case IOP_T_DATA:
        sb_addf(buf, "%s        %s Swift.Array(%s)", indent, action, source);
        break;

      case IOP_T_UNION: case IOP_T_STRUCT:
        if (field->kind == IOP_T_STRUCT
        &&  iopc_is_class(field->struct_def->type))
        {
            sb_addf(buf, "%s        %s try ", indent, action);
            iopc_dump_field_basetype(buf, field);
            sb_addf(buf, ".make(Swift.UnsafeRawPointer(%s))", source);
        } else
        if (field->is_ref) {
            sb_addf(buf, "%s        %s try ", indent, action);
            iopc_dump_field_basetype(buf, field);
            sb_addf(buf, "(Swift.UnsafeRawPointer(%s))", source);
        } else
        if (field->repeat == IOP_R_OPTIONAL) {
            sb_addf(buf, "\n%s        %s try ", indent, action);
            iopc_dump_field_basetype(buf, field);
            sb_addf(buf, "(%s)", source);
        } else {
            sb_addf(buf,
                    "\n"
                    "%s        var %s_var = %s\n"
                    "%s        %s try ",
                    indent, field->name, source,
                    indent, action);
            iopc_dump_field_basetype(buf, field);
            sb_addf(buf, "(&%s_var)\n%s        ",
                    field->name, indent);
        }

      case IOP_T_VOID:
        break;
    }
}

static void iopc_dump_struct_field_importer(sb_t *buf, const char *indent,
                                            const iopc_field_t *field)
{
    t_scope;
    lstr_t c_field_name = t_camelcase_to_c(LSTR(field->name));

    switch (field->repeat) {
      case IOP_R_REQUIRED:
      case IOP_R_DEFVAL:
        iopc_dump_struct_value_importer(buf, indent, field,
                                        t_fmt("data.pointee.%*pM",
                                              LSTR_FMT_ARG(c_field_name)),
                                        t_fmt("self.%s =", field->name));
        sb_addc(buf, '\n');
        break;

      case IOP_R_OPTIONAL:
        switch (field->kind) {
          case IOP_T_I8...IOP_T_DOUBLE:
            sb_addf(buf, "%s        if data.pointee.%*pM.has_field {\n"
                         "%s            self.%s = data.pointee.%*pM.v\n"
                         "%s        }\n",
                    indent, LSTR_FMT_ARG(c_field_name),
                    indent, field->name, LSTR_FMT_ARG(c_field_name),
                    indent);
            break;

          case IOP_T_STRING: case IOP_T_XML:
            sb_addf(buf, "%s         self.%s = Swift.String(data.pointee.%*pM)\n",
                    indent, field->name, LSTR_FMT_ARG(c_field_name));
            break;

          case IOP_T_DATA:
            sb_addf(buf,
                    "%s        if data.pointee.%*pM.data != nil {\n"
                    "%s            ",
                    indent, LSTR_FMT_ARG(c_field_name), indent);
            iopc_dump_struct_value_importer(buf, t_fmt("%s    ", indent), field,
                                        t_fmt("data.pointee.%*pM",
                                              LSTR_FMT_ARG(c_field_name)),
                                        t_fmt("self.%s =", field->name));
            sb_addf(buf, "\n%s        }\n", indent);
            break;

          case IOP_T_UNION: case IOP_T_STRUCT:
            iopc_dump_struct_value_importer(buf, indent, field,
                                            t_fmt("data.pointee.%*pM",
                                                  LSTR_FMT_ARG(c_field_name)),
                                            t_fmt("self.%s =", field->name));
            sb_addc(buf, '\n');
            break;

          case IOP_T_VOID:
            sb_addf(buf,
                    "%s        if data.pointee.%*pM {\n"
                    "%s            self.%s = libcommon.IopVoid()\n"
                    "%s        }\n", indent, LSTR_FMT_ARG(c_field_name),
                    indent, field->name, indent);
            break;
        }
        break;

      case IOP_R_REPEATED:
        switch (field->kind) {
          case IOP_T_I8...IOP_T_DOUBLE:
            sb_addf(buf, "%s        self.%s = Swift.Array(data.pointee.%*pM.buffer)\n", indent,
                    field->name, LSTR_FMT_ARG(c_field_name));
            break;

          default:
            sb_addf(buf, "%s        self.%s = %sdata.pointee.%*pM.buffer.map {",
                    indent, field->name,
                    field->kind == IOP_T_UNION || field->kind == IOP_T_STRUCT ? "try ": "",
                    LSTR_FMT_ARG(c_field_name));
            iopc_dump_struct_value_importer(buf, t_fmt("%s    ", indent),
                                            field, "$0", "return");
            sb_adds(buf, "}\n");
            break;
        }
    }
}

static void iopc_dump_struct_field_exporter(sb_t *buf, const char *indent,
                                            const iopc_field_t *field)
{
    t_scope;
    lstr_t c_field_name = t_camelcase_to_c(LSTR(field->name));
    bool type_is_class = false;

    if (field->kind == IOP_T_STRUCT
    && field->struct_def->type == STRUCT_TYPE_CLASS)
    {
        type_is_class = true;
    }

    switch (field->repeat) {
      case IOP_R_REQUIRED:
        if (field->kind == IOP_T_VOID) {
            break;
        }
        /* FALLTHROUGH */

      case IOP_R_DEFVAL:
        switch (field->kind) {
          case IOP_T_I8...IOP_T_DOUBLE:
            sb_addf(buf, "%s        data.pointee.%*pM = self.%s\n",
                    indent, LSTR_FMT_ARG(c_field_name), field->name);
            break;

          case IOP_T_DATA:
            sb_addf(buf, "%s        data.pointee.%*pM = libcommon.LString(self.%s.duplicated(on: allocator), "
                    "count: Int32(self.%s.count), flags: 0)\n", indent,
                    LSTR_FMT_ARG(c_field_name), field->name, field->name);
            break;

          case IOP_T_STRING: case IOP_T_XML:
            sb_addf(buf, "%s         data.pointee.%*pM = self.%s.duplicated(on: allocator)\n",
                    indent, LSTR_FMT_ARG(c_field_name), field->name);
            break;

          case IOP_T_UNION: case IOP_T_STRUCT: {
            const char *field_pkg_name;
            lstr_t field_name;

            field_pkg_name = t_pp_under(field->type_pkg->name);
            field_name = t_camelcase_to_c(LSTR(field->type_name));
            sb_addf(buf, "%s        data.pointee.%*pM = self.%s.duplicated(on: allocator)"
                    ".bindMemory(to: %s__%*pM__t.self, capacity: 1)",
                    indent, LSTR_FMT_ARG(c_field_name), field->name,
                    field_pkg_name, LSTR_FMT_ARG(field_name));
            if (!field->is_ref && !type_is_class) {
                sb_adds(buf, ".pointee");
            }
            sb_addc(buf, '\n');
          } break;

          case IOP_T_VOID:
            assert (false);
            break;
        }
        break;

      case IOP_R_OPTIONAL:
        switch (field->kind) {
          case IOP_T_I8...IOP_T_DOUBLE:
            sb_addf(buf, "%s        if let %s_val = self.%s {\n"
                         "%s            data.pointee.%*pM.has_field = true\n"
                         "%s            data.pointee.%*pM.v = %s_val\n"
                         "%s        } else {\n"
                         "%s            data.pointee.%*pM.has_field = false\n"
                         "%s        }\n",
                    indent, field->name, field->name,
                    indent, LSTR_FMT_ARG(c_field_name),
                    indent, LSTR_FMT_ARG(c_field_name), field->name,
                    indent, indent, LSTR_FMT_ARG(c_field_name), indent);
            break;

          case IOP_T_DATA:
            sb_addf(buf,
                    "%s        if let %s_val = self.%s {\n"
                    "%s            data.pointee.%*pM = libcommon.LString(%s_val.duplicated(on: allocator), count: Swift.Int32(%s_val.count), flags: 0)\n"
                    "%s        }\n",
                    indent, field->name, field->name, indent,
                    LSTR_FMT_ARG(c_field_name), field->name, field->name,
                    indent);
            break;

          case IOP_T_STRING: case IOP_T_XML:
            sb_addf(buf,
                    "%s        if let %s_val = self.%s {\n"
                    "%s            data.pointee.%*pM = %s_val.duplicated(on: allocator)\n"
                    "%s        }\n",
                    indent, field->name, field->name, indent,
                    LSTR_FMT_ARG(c_field_name), field->name, indent);
            break;

          case IOP_T_UNION: case IOP_T_STRUCT: {
            const char *field_pkg_name;
            lstr_t field_name;

            field_pkg_name = t_pp_under(field->type_pkg->name);
            field_name = t_camelcase_to_c(LSTR(field->type_name));
            sb_addf(buf,
                    "%s        if let %s_val = self.%s {\n"
                    "%s            data.pointee.%*pM = %s_val.duplicated(on: allocator)"
                    ".bindMemory(to: %s__%*pM__t.self, capacity: 1)\n"
                    "%s        }\n",
                    indent, field->name, field->name, indent,
                    LSTR_FMT_ARG(c_field_name), field->name, field_pkg_name,
                    LSTR_FMT_ARG(field_name), indent);
          } break;

          case IOP_T_VOID:
            sb_addf(buf,
                    "%s        data.pointee.%*pM = self.%s != nil\n",
                    indent, LSTR_FMT_ARG(c_field_name), field->name);
            break;
        }
        break;

      case IOP_R_REPEATED:
        switch (field->kind) {
          case IOP_T_I8...IOP_T_DOUBLE:
            sb_addf(buf, "%s        data.pointee.%*pM.tab = self.%s.duplicated(on: allocator)\n"
                         "%s        data.pointee.%*pM.len = Swift.Int32(self.%s.count)\n",
                indent, LSTR_FMT_ARG(c_field_name), field->name,
                indent, LSTR_FMT_ARG(c_field_name), field->name);
            break;

          case IOP_T_DATA: case IOP_T_STRING: case IOP_T_XML:
            sb_addf(buf, "%s        data.pointee.%*pM = .init(self.%s, on: allocator)\n",
                         indent, LSTR_FMT_ARG(c_field_name), field->name);
            break;

          case IOP_T_UNION: case IOP_T_STRUCT:
            if (iopc_is_class(field->struct_def->type)) {
                sb_addf(buf, "%s        libcommon.duplicate(classArray: self.%s, "
                             "to: &data.pointee.%*pM, on: allocator)\n",
                             indent, field->name, LSTR_FMT_ARG(c_field_name));
            } else {
                sb_addf(buf, "%s        libcommon.duplicate(complexTypeArray: self.%s, "
                             "to: &data.pointee.%*pM, on: allocator)\n",
                             indent, field->name, LSTR_FMT_ARG(c_field_name));
            }
            break;

          case IOP_T_VOID:
            assert (false);
            break;
        }
        break;
    }
}

static bool iopc_struct_includes(const iopc_struct_t *in_st,
                                 const iopc_struct_t *st,
                                 qh_t(cptr) *visited)
{
    if (qh_add(cptr, visited, in_st) < 0) {
        return false;
    }
    tab_for_each_entry(field, &in_st->fields) {
        if ((field->kind == IOP_T_STRUCT || field->kind == IOP_T_UNION)
        &&  !iopc_is_class(field->struct_def->type)
        &&  field->repeat != IOP_R_REPEATED)
        {
            if (field->struct_def == st) {
                return true;
            }
            if (iopc_struct_includes(field->struct_def, st, visited)) {
                return true;
            }
        }
    }
    return false;
}

static bool iopc_struct_is_recursive(const iopc_struct_t *st)
{
    qh_t(cptr) visited;
    bool res;

    qh_init(cptr, &visited);
    res = iopc_struct_includes(st, st, &visited);
    qh_wipe(cptr, &visited);
    return res;
}

static bool iopc_class_is_final(const iopc_pkg_t *pkg,
                                const iopc_struct_t *st)
{
    if (!st->is_local) {
        return false;
    }

    tab_for_each_entry(other, &pkg->structs) {
        if (other == st) {
            continue;
        }

        tab_for_each_entry(ext, &other->extends) {
            if (ext->st == st) {
                return false;
            }
        }
    }
    return true;
}

static void iopc_dump_struct(sb_t *buf, const char *indent,
                             const iopc_pkg_t *pkg, iopc_struct_t *st,
                             const char *pkg_name, const char *st_name)
{
    t_scope;
    lstr_t c_name;
    bool is_root_class = true;
    qv_t(iopc_struct) parents;
    const iopc_struct_t *parent;
    bool first = true;

    iopc_struct_sort_fields(st, BY_POS);

    if (!st_name) {
        st_name = st->name;
    }

    c_name = t_camelcase_to_c(LSTR(st->name));
    c_name = t_lstr_fmt("%s__%*pM", pkg_name, LSTR_FMT_ARG(c_name));

    if (iopc_is_class(st->type)) {
        sb_addf(buf, "%s%s %sclass %s : ",
                indent, st->is_local ? "public" : "open",
                iopc_class_is_final(pkg, st) ? "final " : "", st_name);
        if (st->extends.len) {
            const iopc_pkg_t *parent_pkg = st->extends.tab[0]->pkg;

            parent = st->extends.tab[0]->st;
            is_root_class = false;
            iopc_dump_package_member(buf, parent_pkg->name, parent->name);
            sb_adds(buf, " {\n");
        } else {
            sb_adds(buf, "libcommon.IopClass {\n");
        }
    } else {
        sb_addf(buf, "%spublic final class %s : libcommon.IopStruct {\n",
                indent, st_name);
    }

    /* Generate descriptor */
    sb_addf(buf,
            "%s    open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {\n"
            "%s        return %*pM__sp\n"
            "%s    }\n\n",
            indent, indent, LSTR_FMT_ARG(c_name), indent);
    if (iopc_is_class(st->type)) {
        sb_addf(buf,
                "%s    open override class var isAbstract : Swift.Bool {\n"
                "%s        return %s\n"
                "%s    }\n\n",
                indent, indent, st->is_abstract ? "true" : "false", indent);
    }

    /* Generate field list */
    tab_for_each_entry(field, &st->fields) {
        if (!iopc_struct_is_field_ignored(field)) {
            sb_addf(buf, "%s    public var `%s` : ", indent, field->name);
            iopc_dump_field_type(buf, field);
            sb_addc(buf, '\n');
        }
    }
    sb_addc(buf, '\n');

    /* Generate field constructor */
    qv_init(&parents);
    qv_append(&parents, (iopc_struct_t *)st);
    parent = st;
    while (parent->extends.len) {
        parent = parent->extends.tab[0]->st;
        qv_append(&parents, (iopc_struct_t *)parent);
    }
    sb_addf(buf, "%s    public %sinit(", indent,
            st->fields.len == 0 ? "override " : "");
    tab_for_each_pos_rev(pos, &parents) {
        iopc_struct_sort_fields(parents.tab[pos], BY_POS);
        tab_for_each_entry(field, &parents.tab[pos]->fields) {
            if (iopc_struct_is_field_ignored(field)) {
                continue;
            }
            if (!first) {
                sb_addf(buf, ",\n"
                        "%s                ",
                        indent);
            }
            first = false;
            sb_addf(buf, "`%s`: ", field->name);
            iopc_dump_field_type(buf, field);
            iopc_dump_field_defval(buf, field);
        }
    }
    sb_adds(buf, ") {\n");
    tab_for_each_entry(field, &st->fields) {
        if (!iopc_struct_is_field_ignored(field)) {
            sb_addf(buf, "%s        self.%s = `%s`\n", indent, field->name,
                    field->name);
        }
    }
    sb_addf(buf, "%s        super.init(", indent);
    first = true;
    tab_for_each_pos_rev(pos, &parents) {
        if (pos == 0) {
            break;
        }
        tab_for_each_entry(field, &parents.tab[pos]->fields) {
            if (!iopc_struct_is_field_ignored(field)) {
                if (!first) {
                    sb_addf(buf, ",\n"
                            "%s               ",
                            indent);
                }
                first = false;
                sb_addf(buf, "%s: `%s`", field->name, field->name);
            }
        }
    }
    sb_adds(buf, ")\n");
    sb_addf(buf, "%s    }\n\n", indent);

    /* Generate C interface */
    sb_addf(buf, "%s    public required init(_ c: Swift.UnsafeRawPointer) throws {\n",
            indent);
    if (st->fields.len) {
        sb_addf(buf,
                "%s        let data = c.bindMemory(to: %*pM__t.self, capacity: 1)\n",
                indent, LSTR_FMT_ARG(c_name));
        tab_for_each_entry(field, &st->fields) {
            if (!iopc_struct_is_field_ignored(field)) {
                iopc_dump_struct_field_importer(buf, indent, field);
            }
        }
    }
    sb_addf(buf, "%s        try super.init(c)\n", indent);
    sb_addf(buf,
            "%s    }\n\n"
            "%s    open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {\n",
            indent, indent);
    if (st->fields.len) {
        sb_addf(buf,
                "%s        let data = c.bindMemory(to: %*pM__t.self, capacity: 1)\n",
                indent, LSTR_FMT_ARG(c_name));
        tab_for_each_entry(field, &st->fields) {
            if (!iopc_struct_is_field_ignored(field)) {
                iopc_dump_struct_field_exporter(buf, indent, field);
            }
        }
    }
    if (!is_root_class) {
        sb_addf(buf, "%s        super.fill(c, on: allocator)\n", indent);
    }
    sb_addf(buf,
            "%s    }\n"
            "%s}\n\n",
            indent, indent);

    qv_wipe(&parents);
}

static void iopc_dump_union_field_importer(sb_t *buf, const iopc_field_t *field)
{
    bool type_is_class = false;

    if (field->kind == IOP_T_STRUCT
    && field->struct_def->type == STRUCT_TYPE_CLASS)
    {
        type_is_class = true;
    }

    sb_addf(buf, "              case %d:\n", field->tag);
    switch (field->kind) {
      case IOP_T_I8...IOP_T_DOUBLE:
        sb_addf(buf, "                self = .%s(data.bindMemory(to: ",
                field->name);
        iopc_dump_field_basetype(buf, field);
        sb_adds(buf, ".self, capacity: 1).pointee)\n");
        break;

      case IOP_T_DATA:
        sb_addf(buf, "                self = .%s(Swift.Array(data.bindMemory(to: libcommon.LString.self, capacity: 1).pointee))\n",
                field->name);
        break;

      case IOP_T_STRING: case IOP_T_XML:
        sb_addf(buf, "                self = .%s(Swift.String("
                "data.bindMemory(to: LString.self, capacity: 1).pointee) ?? \"\")\n",
                field->name);
        break;

      case IOP_T_UNION: case IOP_T_STRUCT:
        sb_addf(buf, "                self = .%s(try ", field->name);
        iopc_dump_field_basetype(buf, field);
        if (type_is_class) {
            /* Force conversion into real type. */
            sb_adds(buf, ".make");
        }

        sb_adds(buf, "(data");
        if (type_is_class || field->is_ref) {
            sb_adds(buf, ".bindMemory(to: Swift.UnsafeRawPointer.self, capacity: 1).pointee");
        }
        sb_adds(buf, "))\n");
        break;

      case IOP_T_VOID:
        sb_addf(buf, "                self = .%s\n", field->name);
        break;
    }
}

static void iopc_dump_union_field_exporter(sb_t *buf, const iopc_field_t *field)
{
    bool type_is_class = false;

    if (field->kind == IOP_T_STRUCT
    && field->struct_def->type == STRUCT_TYPE_CLASS)
    {
        type_is_class = true;
    }

    sb_addf(buf, "              case .%s", field->name);
    if (field->kind != IOP_T_VOID) {
        sb_addf(buf, "(let %s_val)", field->name);
    }
    sb_addf(buf,
            ":\n"
            "                tag[0] = %d\n",
            field->tag);

    switch (field->kind) {
      case IOP_T_I8...IOP_T_DOUBLE:
        sb_adds(buf, "                data.bindMemory(to: ");
        iopc_dump_field_basetype(buf, field);
        sb_addf(buf, ".self, capacity: 1).pointee = `%s_val`\n", field->name);
        break;

      case IOP_T_DATA:
        sb_addf(buf,
                "                data.bindMemory(to: LString.self, capacity: 1).pointee"
                " = LString(%s_val.duplicated(on: allocator), count: Swift.Int32(%s_val.count), flags: 0)\n",
                field->name, field->name);
        break;

      case IOP_T_STRING: case IOP_T_XML:
        sb_addf(buf,
                "                data.bindMemory(to: libcommon.LString.self, capacity: 1).pointee"
                " = %s_val.duplicated(on: allocator)\n", field->name);
        break;

      case IOP_T_UNION: case IOP_T_STRUCT:
        if (type_is_class || field->is_ref) {
            sb_addf(buf,
                   "                data.bindMemory(to: Swift.UnsafeMutableRawPointer.self, "
                   "capacity: 1).pointee = %s_val.duplicated(on: allocator)\n", field->name);
        } else {
            sb_addf(buf, "                %s_val.fill(data, on: allocator)\n", field->name);
        }
        break;

      case IOP_T_VOID:
        break;
    }
}

static void
iopc_dump_union(sb_t *buf, iopc_struct_t *st, const char *pkg_name)
{
    t_scope;
    lstr_t c_name = t_camelcase_to_c(LSTR(st->name));

    c_name = t_lstr_fmt("%s__%*pM", pkg_name, LSTR_FMT_ARG(c_name));

    sb_addf(buf, "    public %senum %s : libcommon.IopUnion {\n",
            iopc_struct_is_recursive(st) ? "indirect " : "",
            st->name);

    /* Generate descriptor */
    sb_addf(buf, "        public static let descriptor =  %*pM__sp\n\n",
            LSTR_FMT_ARG(c_name));

    /* Generate case list */
    iopc_struct_sort_fields(st, BY_POS);
    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "        case `%s`", field->name);
        if (field->kind != IOP_T_VOID) {
            sb_addc(buf, '(');
            iopc_dump_field_type(buf, field);
            sb_addc(buf, ')');
        }
        sb_addc(buf, '\n');
    }
    sb_addc(buf, '\n');

    /* Generate C interface */
    sb_adds(buf,
            "        public init(_ c: Swift.UnsafeRawPointer) throws {\n"
            "            let (tag, data) = type(of: self)._explode(c)\n"
            "            switch tag {\n");
    tab_for_each_entry(field, &st->fields) {
        iopc_dump_union_field_importer(buf, field);
    }

    sb_adds(buf,
            "              default:\n"
            "                throw libcommon.IopImportError.invalidUnionTag(type(of: self).descriptor, tag)\n"
            "            }\n"
            "        }\n\n"
            "        public func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {\n"
            "            let (tag, data) = type(of: self)._explode(c)\n"
            "            switch self {\n");
    tab_for_each_entry(field, &st->fields) {
        iopc_dump_union_field_exporter(buf, field);
    }
    sb_adds(buf,
            "            }\n"
            "        }\n");

    sb_adds(buf, "    }\n\n");
}

static void iopc_dump_structs(sb_t *buf, iopc_pkg_t *pkg,
                              const char *pkg_name)
{
    tab_for_each_entry(st, &pkg->structs) {
        switch (st->type) {
          case STRUCT_TYPE_STRUCT:
          case STRUCT_TYPE_CLASS:
            iopc_dump_struct(buf, "    ", pkg, st, pkg_name, NULL);
            break;

          case STRUCT_TYPE_UNION:
            iopc_dump_union(buf, st, pkg_name);
            break;

          default:
            break;
        }
    }
}

static void iopc_dump_rpc_desc(sb_t *buf, const iopc_pkg_t *pkg,
                               const iopc_fun_t *rpc, int pos,
                               const char *pkg_name)
{
    sb_addf(buf, "            public enum %c%s : libcommon.IopRPC {\n",
            toupper(*rpc->name), rpc->name + 1);
    if (rpc->arg) {
        if (rpc->arg_is_anonymous) {
            iopc_dump_struct(buf, "                ", pkg, rpc->arg, pkg_name,
                             "Argument");
        } else {
            sb_adds(buf, "                public typealias Argument = ");
            iopc_dump_field_basetype(buf, rpc->farg);
            sb_addc(buf, '\n');
        }
    }
    if (rpc->res) {
        if (rpc->res_is_anonymous) {
            iopc_dump_struct(buf, "                ", pkg, rpc->res, pkg_name,
                             "Response");
        } else {
            sb_adds(buf, "                public typealias Response = ");
            iopc_dump_field_basetype(buf, rpc->fres);
            sb_addc(buf, '\n');
        }
    }
    if (rpc->exn) {
        if (rpc->exn_is_anonymous) {
            iopc_dump_struct(buf, "                ", pkg, rpc->exn, pkg_name,
                             "Exception");
        } else {
            sb_adds(buf, "                public typealias Exception = ");
            iopc_dump_field_basetype(buf, rpc->fexn);
            sb_addc(buf, '\n');
        }
    }
    if (rpc->fun_is_async) {
        sb_addf(buf, "                public typealias ReturnType = Swift.Void\n\n");
    }

    sb_addf(buf,
            "                public static let descriptor = %s__if.funs.advanced(by: %d)\n"
            "                public static let tag = %d\n"
            "            }\n"
            "            public var `%s` : (Int, %c%s.Type) {\n"
            "                return ((self._tag << 16) + %c%s.tag, %c%s.self)\n"
            "            }\n\n",
            pkg_name, pos, rpc->tag, rpc->name, toupper(*rpc->name),
            rpc->name + 1, toupper(*rpc->name), rpc->name + 1,
            toupper(*rpc->name), rpc->name + 1);
}

static void iopc_dump_rpc_call(sb_t *buf, const iopc_pkg_t *pkg,
                               iopc_fun_t *rpc, int pos,
                               const char *pkg_name)
{
    t_scope;
    const char *rpc_desc = t_fmt("%c%s", toupper(*rpc->name), rpc->name + 1);

    /* Generate functions */
    if (rpc->arg) {
        iopc_struct_t *st;

        st = rpc->arg_is_anonymous ? rpc->arg : rpc->farg->struct_def;
        sb_addf(buf,
                "                public func %s(_ args: %s.Argument) -> %s.ReturnType {\n"
                "                    return self._query(rpc: %s.self, args: args)\n"
                "                }\n",
                rpc->name, rpc_desc, rpc_desc, rpc_desc);
        if (st->type == STRUCT_TYPE_UNION) {
            iopc_struct_sort_fields(st, BY_POS);
            tab_for_each_entry(field, &st->fields) {
                sb_addf(buf, "            public func `%s`(`%s`: ",
                        rpc->name, field->name);
                iopc_dump_field_type(buf, field);

                sb_addf(buf, ") -> %s.ReturnType {\n"
                        "                    return self.%s(.%s",
                        rpc_desc, rpc->name, field->name);
                if (field->kind != IOP_T_VOID) {
                    sb_addf(buf, "(%s)", field->name);
                }
                sb_addf(buf, ")\n"
                        "                }\n");

            }
            sb_addc(buf, '\n');
        } else
        if (!iopc_is_class(rpc->arg->type)
        ||  iopc_class_is_final(pkg, rpc->arg))
        {
            const iopc_struct_t *parent;
            qv_t(iopc_struct) parents;
            bool first = true;

            parent = st;
            qv_init(&parents);
            qv_append(&parents, (iopc_struct_t *)parent);
            while (parent->extends.len) {
                parent = parent->extends.tab[0]->st;
                qv_append(&parents, (iopc_struct_t *)parent);
            }

            sb_addf(buf, "                public func `%s`(", rpc->name);
            tab_for_each_pos_rev(p, &parents) {
                iopc_struct_sort_fields(parents.tab[p], BY_POS);
                tab_for_each_entry(field, &parents.tab[p]->fields) {
                    if (!first) {
                        sb_adds(buf, ",\n");
                        sb_addnc(buf, 25 + strlen(rpc->name), ' ');
                    }
                    first = false;
                    sb_addf(buf, "`%s`: ", field->name);
                    iopc_dump_field_type(buf, field);
                    iopc_dump_field_defval(buf, field);
                }
            }
            sb_addf(buf, ") -> %s.ReturnType {\n"
                    "                    return self.%s(%s.Argument(",
                    rpc_desc, rpc->name, rpc_desc);
            first = true;
            tab_for_each_pos_rev(p, &parents) {
                tab_for_each_entry(field, &parents.tab[p]->fields) {
                    if (!iopc_struct_is_field_ignored(field)) {
                        if (!first) {
                            sb_adds(buf, ",\n");
                            sb_addnc(buf, 39 + 2 * strlen(rpc->name), ' ');
                        }
                        first = false;
                        sb_addf(buf, "%s: `%s`", field->name, field->name);
                    }
                }
            }
            sb_adds(buf, "))\n"
                    "                }\n\n");
            qv_wipe(&parents);
        }
    } else {
        sb_addf(buf,
                "                public func `%s`() -> %s.ReturnType {\n"
                "                    return self._query(rpc: %s.self, args: libcommon.IopVoid())\n"
                "                }\n\n",
                rpc->name, rpc_desc, rpc_desc);
    }
}

static void iopc_dump_iface(sb_t *buf, const iopc_pkg_t *pkg,
                            iopc_iface_t *iface, const char *pkg_name)
{
    t_scope;
    lstr_t iname = t_camelcase_to_c(LSTR(iface->name));
    const char *ibase = t_fmt("%s__%*pM", pkg_name, LSTR_FMT_ARG(iname));

    sb_addf(buf, "        public struct %s : libcommon.IopInterface {\n",
            iface->name);

    tab_for_each_pos(pos, &iface->funs) {
        iopc_dump_rpc_desc(buf, pkg, iface->funs.tab[pos], pos, ibase);
    }
    sb_adds(buf, "            public struct Impl : libcommon.IopInterfaceImpl {\n");
    tab_for_each_pos(pos, &iface->funs) {
        iopc_dump_rpc_call(buf, pkg, iface->funs.tab[pos], pos, ibase);
    }
    sb_adds(buf,
            "\n"
            "                public let _tag : Swift.Int\n"
            "                public let _channel : libcommon.IopChannel\n"
            "                public init(channel: libcommon.IopChannel, tag: Swift.Int) {\n"
            "                    self._channel = channel\n"
            "                    self._tag = tag\n"
            "                }\n"
            "            }\n\n"
            "            public let _tag : Swift.Int\n"
            "            public init(tag: Swift.Int) {\n"
            "                self._tag = tag\n"
            "            }\n"
            "        }\n\n");
}

static void iopc_dump_ifaces(sb_t *buf, iopc_pkg_t *pkg,
                             const char *pkg_name)
{
    sb_adds(buf, "    public enum interfaces {\n");
    tab_for_each_entry(iface, &pkg->ifaces) {
        switch (iface->type) {
          case IFACE_TYPE_IFACE:
            iopc_dump_iface(buf, pkg, iface, pkg_name);
            break;

          default:
            break;
        }
    }
    sb_adds(buf, "    }\n");
}

static void iopc_dump_module(sb_t *buf, iopc_struct_t *mod,
                             const char *pkg_name)
{
    sb_addf(buf, "public protocol %s__modules__%s : ", pkg_name, mod->name);

    if (mod->extends.len) {
        bool first = true;

        tab_for_each_entry(parent, &mod->extends) {
            if (!first) {
                sb_adds(buf, ", ");
            }
            first = false;
            sb_adds(buf, t_pp_under(parent->pkg->name));
            sb_addf(buf, "__modules__%s", parent->st->name);
        }
        sb_adds(buf, " {\n");
    } else {
        sb_adds(buf, "libcommon.IopModule {\n");
    }

    iopc_struct_sort_fields(mod, BY_POS);
    tab_for_each_entry(field, &mod->fields) {
        sb_addf(buf, "    var `%s` : ", field->name);
        dump_package_interface(buf, field->type_path);
        sb_addf(buf, ".%s.Impl { get }\n", field->type_name);

        sb_addf(buf, "    static var `%s` : ", field->name);
        dump_package_interface(buf, field->type_path);
        sb_addf(buf, ".%s { get }\n", field->type_name);
    }
    sb_adds(buf, "}\n");

    sb_addf(buf, "public extension %s__modules__%s {\n", pkg_name, mod->name);
    tab_for_each_entry(field, &mod->fields) {
        sb_addf(buf, "    public var `%s` : ", field->name);
        dump_package_interface(buf, field->type_path);
        sb_addf(buf, ".%s.Impl {\n"
                "        return ",
                field->type_name);
        dump_package_interface(buf, field->type_path);
        sb_addf(buf, ".%s.Impl(channel: self.channel, tag: %d)\n"
                "    }\n", field->type_name, field->tag);

        sb_addf(buf, "    public static var `%s` : ", field->name);
        dump_package_interface(buf, field->type_path);
        sb_addf(buf, ".%s {\n"
                "        return ",
                field->type_name);
        dump_package_interface(buf, field->type_path);
        sb_addf(buf, ".%s(tag: %d)\n"
                "    }\n", field->type_name, field->tag);
    }
    sb_adds(buf, "}\n\n");
}

static void iopc_dump_modules(sb_t *buf, iopc_pkg_t *pkg,
                              const char *pkg_name)
{
    tab_for_each_entry(mod, &pkg->modules) {
        iopc_dump_module(buf, mod, pkg_name);
    }
}

static void iopc_dump_modules_impl(sb_t *buf, const iopc_pkg_t *pkg,
                                      const char *pkg_name)
{
    sb_adds(buf, "    public enum modules {\n");
    tab_for_each_entry(mod, &pkg->modules) {
        sb_addf(buf,
                "        public struct %s : %s__modules__%s {\n"
                "            public let channel : libcommon.IopChannel\n"
                "            public init(channel: libcommon.IopChannel) {\n"
                "                self.channel = channel\n"
                "            }\n"
                "        }\n",
                mod->name, pkg_name, mod->name);
    }
    sb_adds(buf, "    }\n");
}

int iopc_do_swift(iopc_pkg_t *pkg, const char *outdir, sb_t *depbuf)
{
    t_scope;
    const char *pkg_name = t_pp_under(pkg->name);
    const char *curr_pkg_name = *qv_last(&pkg->name->bits);
    char path[PATH_MAX];
    SB(buf, 32 << 10);

    /* default languages */

    iopc_set_path(outdir, pkg, ".iop.swift", sizeof(path), path, true);


    sb_adds(&buf, RO_WARN);

    /* Generate imports */
    if (_G.imported_modules) {
        qv_t(lstr) mods;
        ctype_desc_t sep;

        qv_inita(&mods, 16);
        ctype_desc_build(&sep, ",");
        ps_split(ps_initstr(_G.imported_modules), &sep, 0, &mods);
        tab_for_each_entry(mod, &mods) {
            sb_addf(&buf, "import %*pM\n", LSTR_FMT_ARG(mod));
        }
        sb_addc(&buf, '\n');
        qv_wipe(&mods);
    }

    /* Generate C types extensions */
    iopc_dump_extensions(&buf, pkg, pkg_name);
    iopc_dump_modules(&buf, pkg, pkg_name);

    /* Generate Swift package */
    if (pkg->name->bits.len > 1) {
        sb_addf(&buf, "public extension ");
        tab_for_each_pos(pos, &pkg->name->bits) {
            if (pos != pkg->name->bits.len - 1) {
                if (pos != 0) {
                    sb_addc(&buf, '.');
                }
                sb_adds(&buf, pkg->name->bits.tab[pos]);
            }
        }
        sb_adds(&buf, "{\n");
    }
    sb_addf(&buf, "public enum %s : libcommon.IopPackage {\n", curr_pkg_name);

    /* Generate types */
    iopc_dump_enums(&buf, pkg, pkg_name);
    iopc_dump_structs(&buf, pkg, pkg_name);
    iopc_dump_ifaces(&buf, pkg, pkg_name);
    iopc_dump_modules_impl(&buf, pkg, pkg_name);

    /* Define registries */
    {
        bool first = true;

        sb_adds(&buf, "    public static let classes : [libcommon.IopClass.Type] = [ ");
        tab_for_each_entry(st, &pkg->structs) {
            if (iopc_is_class(st->type)) {
                if (!first) {
                    sb_adds(&buf, ", ");
                }
                first = false;
                sb_addf(&buf, "%s.self", st->name);
            }
        }
        sb_adds(&buf, " ]\n");
    }

    sb_adds(&buf, "}\n");

    /* Add alias */
    sb_adds(&buf, "\npublic typealias ");
    dump_package_alias(&buf, pkg->name);
    sb_addf(&buf, " = %s\n",  curr_pkg_name);

    if (pkg->name->bits.len > 1) {
        sb_adds(&buf, "}\n");
    }

    return iopc_write_file(&buf, path);
}
