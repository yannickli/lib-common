/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2017 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "iopc.h"

static qv_t(str) pp_g;

#define RO_WARN \
    "/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/\n"

static const char *pp_under(iopc_path_t *path)
{
    sb_t buf;
    char *res;

    sb_inita(&buf, 1024);
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s__", bit);
    }
    sb_shrink(&buf, 2);
    qv_append(&pp_g, res = sb_detach(&buf, NULL));
    return res;
}

static const char *pp_path(iopc_path_t *path)
{
    sb_t buf;
    char *res;

    sb_inita(&buf, 1024);
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s/", bit);
    }
    sb_shrink(&buf, 1);
    qv_append(&pp_g, res = sb_detach(&buf, NULL));
    return res;
}

static const char *pp_dot(iopc_path_t *path)
{
    sb_t buf;
    char *res;

    sb_inita(&buf, 1024);
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s.", bit);
    }
    sb_shrink(&buf, 1);
    qv_append(&pp_g, res = sb_detach(&buf, NULL));
    return res;
}

static void iopc_dump_import(sb_t *buf, const iopc_pkg_t *dep,
                             qh_t(cstr) *imported)
{
    const char *import_name = pp_under(dep->name);

    if (qh_put(cstr, imported, import_name, 0) & QHASH_COLLISION) {
        return;
    }

    sb_addf(buf, "import * as %s from \"iop/%s.iop\";\n",
            pp_under(dep->name), pp_path(dep->name));
}

static void iopc_dump_imports(sb_t *buf, iopc_pkg_t *pkg)
{
    qh_t(cstr) imported;
    qv_t(iopc_pkg) t_deps;
    qv_t(iopc_pkg) t_weak_deps;
    qv_t(iopc_pkg) i_deps;

    qh_init(cstr, &imported);
    qv_inita(&t_deps, 1024);
    qv_inita(&t_weak_deps, 1024);
    qv_inita(&i_deps, 1024);

    iopc_get_depends(pkg, &t_deps, &t_weak_deps, &i_deps, false, false);

    tab_for_each_entry(dep, &t_deps) {
        iopc_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &t_weak_deps) {
        iopc_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &i_deps) {
        iopc_dump_import(buf, dep, &imported);
    }

    qv_wipe(&t_deps);
    qv_wipe(&t_weak_deps);
    qv_wipe(&i_deps);
    qh_wipe(cstr, &imported);
}

static void iopc_dump_package_member(sb_t *buf, const iopc_pkg_t *pkg,
                                     const iopc_pkg_t *member_pkg,
                                     iopc_path_t *member_path,
                                     const char *member_name)
{
    if (pkg != member_pkg) {
        assert (member_path->bits.len);
        sb_adds(buf, pp_under(member_path));
        sb_addc(buf, '.');
    }
    sb_adds(buf, member_name);
}

static void iopc_dump_enum(sb_t *buf, const char *indent,
                           const iopc_pkg_t *pkg, const iopc_enum_t *en)
{
    bool is_strict = false;
    bool first = false;

    tab_for_each_entry(attr, &en->attrs) {
        if (attr->desc->id == IOPC_ATTR_STRICT) {
            is_strict = true;
            break;
        }
    }

    sb_addf(buf, "\n%sexport type %s_Int = ", indent, en->name);
    first = true;
    tab_for_each_entry(field, &en->values) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_addf(buf, "%d", field->value);
        first = false;
    }
    sb_adds(buf, ";\n");

    sb_addf(buf, "%sexport type %s_Str = ", indent, en->name);
    first = true;
    tab_for_each_entry(field, &en->values) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_addf(buf, "'%s'", field->name);
        first = false;
    }
    sb_adds(buf, ";\n");

    if (is_strict) {
        sb_addf(buf, "%sexport type %s = %s_Str;\n",
                indent, en->name, en->name);
    } else {
        sb_addf(buf, "%sexport type %s = %s_Str;\n",
                indent, en->name, en->name);
    }
}

static void iopc_dump_enums(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(en, &pkg->enums) {
        iopc_dump_enum(buf, "", pkg, en);
    }
}

static void iopc_dump_field_basetype(sb_t *buf, const iopc_pkg_t *pkg,
                                     const iopc_field_t *field)
{
    switch (field->kind) {
      case IOP_T_I8: sb_adds(buf, "number"); break;
      case IOP_T_U8: sb_adds(buf, "number"); break;
      case IOP_T_I16: sb_adds(buf, "number"); break;
      case IOP_T_U16: sb_adds(buf, "number"); break;
      case IOP_T_I32: sb_adds(buf, "number"); break;
      case IOP_T_U32: sb_adds(buf, "number"); break;
      case IOP_T_I64: sb_adds(buf, "number | string"); break;
      case IOP_T_U64: sb_adds(buf, "number | string"); break;
      case IOP_T_BOOL: sb_adds(buf, "boolean"); break;
      case IOP_T_DOUBLE: sb_adds(buf, "number"); break;
      case IOP_T_VOID: sb_adds(buf, "null"); break;

      case IOP_T_STRING: case IOP_T_XML:
      case IOP_T_DATA:
        sb_adds(buf, "string");
        break;

      case IOP_T_STRUCT:
        iopc_dump_package_member(buf, pkg, field->type_pkg, field->type_path,
                                 field->type_name);
        if (iopc_is_class(field->struct_def->type)) {
            sb_adds(buf, "_If");
        }
        break;

      case IOP_T_UNION: case IOP_T_ENUM:
        iopc_dump_package_member(buf, pkg, field->type_pkg, field->type_path,
                                 field->type_name);
        break;
    }
}

static void iopc_dump_field_type(sb_t *buf, const iopc_pkg_t *pkg,
                                 const iopc_field_t *field,
                                 bool defval_as_opt)
{
    switch (field->repeat) {
      case IOP_R_REPEATED:
        sb_adds(buf, ": Array<");
        break;

      default:
        sb_adds(buf, ": ");
        break;
    }

    iopc_dump_field_basetype(buf, pkg, field);

    switch (field->repeat) {
      case IOP_R_REPEATED:
        sb_addc(buf, '>');
        break;

      case IOP_R_DEFVAL:
        if (!defval_as_opt) {
            break;
        }
        /* FALLTHROUGH */

      case IOP_R_OPTIONAL:
        sb_adds(buf, " | undefined");
        break;

      default:
        break;
    }
}

static void iopc_dump_struct(sb_t *buf, const char *indent,
                             const iopc_pkg_t *pkg, iopc_struct_t *st,
                             const char *st_name)
{
    if (!st_name) {
        st_name = st->name;
    }

    iopc_struct_sort_fields(st, BY_POS);

    if (iopc_is_class(st->type)) {
        sb_addf(buf, "%sexport interface %s_If", indent, st_name);

        if (st->extends.len) {
            const iopc_pkg_t *parent_pkg = st->extends.tab[0]->pkg;
            const iopc_struct_t *parent = st->extends.tab[0]->st;

            sb_adds(buf, " extends ");
            iopc_dump_package_member(buf, pkg, parent_pkg, parent_pkg->name,
                                     parent->name);
        }
    } else {
        sb_addf(buf, "%sexport interface %s", indent, st_name);
    }

    sb_adds(buf, " {\n");

    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "%s    %s", indent, field->name);
        iopc_dump_field_type(buf, pkg, field, false);
        sb_adds(buf, ";\n");
    }

    sb_addf(buf, "%s}\n", indent);

    if (iopc_is_class(st->type)) {
        sb_addf(buf, "%sexport type %s = { _class: '%s.%s' } & %s_If;\n",
                indent, st_name, pp_dot(pkg->name), st_name, st_name);
    }
}

static void iopc_dump_union(sb_t *buf, const char *indent,
                            const iopc_pkg_t *pkg, iopc_struct_t *st,
                            const char *st_name)
{
    bool first;

    if (!st_name) {
        st_name = st->name;
    }

    iopc_struct_sort_fields(st, BY_POS);

    sb_addc(buf, '\n');

    first = true;
    sb_addf(buf, "%sexport type %s = ", indent, st_name);
    tab_for_each_entry(field, &st->fields) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_addf(buf, "{ %s", field->name);
        iopc_dump_field_type(buf, pkg, field, false);
        sb_adds(buf, " }");
        first = false;
    }
    sb_adds(buf, ";\n");

    first = true;
    sb_addf(buf, "%sexport type %s_Pairs = ", indent, st_name);
    tab_for_each_entry(field, &st->fields) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_addf(buf, "{ tag: '%s', value", field->name);
        iopc_dump_field_type(buf, pkg, field, false);
        sb_adds(buf, " }");
        first = false;
    }
    sb_adds(buf, ";\n");

    sb_addf(buf, "%sexport type %s_Keys = ", indent, st_name);
    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "'%s' | ", field->name);
    }
    sb_shrink(buf, 3);
    sb_adds(buf, ";\n");

}

static void iopc_dump_structs(sb_t *buf, iopc_pkg_t *pkg)
{
    tab_for_each_entry(st, &pkg->structs) {
        switch (st->type) {
          case STRUCT_TYPE_STRUCT:
          case STRUCT_TYPE_CLASS:
            iopc_dump_struct(buf, "", pkg, st, NULL);
            sb_addc(buf, '\n');
            break;

          case STRUCT_TYPE_UNION:
            iopc_dump_union(buf, "", pkg, st, NULL);
            sb_addc(buf, '\n');
            break;

          default:
            break;
        }
    }
}

static void iopc_dump_rpc(sb_t *buf, const iopc_pkg_t *pkg,
                          const iopc_fun_t *rpc)
{
    t_scope;

    if (rpc->arg) {
        if (rpc->arg_is_anonymous) {
            iopc_dump_struct(buf, "        ", pkg, rpc->arg,
                             t_fmt("%sArgs", rpc->name));
        } else {
            sb_addf(buf, "        export type %sArgs = ", rpc->name);
            iopc_dump_field_basetype(buf, pkg, rpc->farg);
            sb_adds(buf, ";\n");
        }
    } else {
        sb_addf(buf, "        export type %sArgs = void;\n", rpc->name);
    }

    if (rpc->res) {
        if (rpc->res_is_anonymous) {
            iopc_dump_struct(buf, "        ", pkg, rpc->res,
                             t_fmt("%sRes", rpc->name));
        } else {
            sb_addf(buf, "        export type %sRes = ", rpc->name);
            iopc_dump_field_basetype(buf, pkg, rpc->fres);
            sb_adds(buf, ";\n");
        }
    } else {
        sb_addf(buf, "        export type %sRes = void;\n", rpc->name);
    }

    if (rpc->exn) {
        if (rpc->exn_is_anonymous) {
            iopc_dump_struct(buf, "        ", pkg, rpc->exn,
                             t_fmt("%sExn", rpc->name));
        } else {
            sb_addf(buf, "        export type %sExn = ", rpc->name);
            iopc_dump_field_basetype(buf, pkg, rpc->fexn);
            sb_adds(buf, ";\n");
        }
    } else {
        sb_addf(buf, "        export type %sExn = void;\n", rpc->name);
    }

    sb_addf(buf, "        export type %s = (", rpc->name);
    if (rpc->arg) {
        if (rpc->arg_is_anonymous) {
            bool first = true;

            tab_for_each_entry(field, &rpc->arg->fields) {
                if (!first) {
                    sb_adds(buf, ", ");
                }
                sb_adds(buf, field->name);
                iopc_dump_field_type(buf, pkg, field, true);
                first = false;
            }
        } else {
            sb_adds(buf, "arg: ");
            iopc_dump_field_basetype(buf, pkg, rpc->farg);
        }
    }
    sb_adds(buf, ") => ");

    if (rpc->fun_is_async) {
        sb_adds(buf, "void");
    } else
    if (rpc->res) {
        sb_addf(buf, "Promise<%sRes>", rpc->name);
    } else {
        sb_adds(buf, "Promise<void>");
    }

    sb_adds(buf, ";\n\n");
}

static void iopc_dump_iface(sb_t *buf, const iopc_pkg_t *pkg,
                            iopc_iface_t *iface)
{
    sb_addf(buf, "    export namespace %s {\n", iface->name);

    tab_for_each_entry(rpc, &iface->funs) {
        iopc_dump_rpc(buf, pkg, rpc);
    }

    sb_addf(buf, "    }\n");
}

static void iopc_dump_ifaces(sb_t *buf, iopc_pkg_t *pkg)
{
    sb_adds(buf, "\nexport namespace interfaces {\n");

    tab_for_each_entry(iface, &pkg->ifaces) {
        switch (iface->type) {
          case IFACE_TYPE_IFACE:
            iopc_dump_iface(buf, pkg, iface);
            break;

          default:
            break;
        }
    }

    sb_adds(buf, "}\n");
}

int iopc_do_typescript(iopc_pkg_t *pkg, const char *outdir, sb_t *depbuf)
{
    SB_8k(buf);
    char path[PATH_MAX];

    iopc_set_path(outdir, pkg, ".iop.ts", sizeof(path), path, true);

    sb_adds(&buf, RO_WARN);
    sb_adds(&buf, "/* tslint:disable */\n");
    iopc_dump_imports(&buf, pkg);

    iopc_dump_enums(&buf, pkg);
    iopc_dump_structs(&buf, pkg);
    iopc_dump_ifaces(&buf, pkg);

    qv_deep_wipe(&pp_g, p_delete);
    return iopc_write_file(&buf, path);
}
