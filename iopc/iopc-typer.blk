/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2015 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "iopc.h"

static struct {
    qv_t(iopc_pkg) resolve_list;
} iopc_typer_g;
#define _G iopc_typer_g

static iopc_struct_t *pkg_find_module(iopc_pkg_t *pkg, const char *name)
{
    qv_for_each_entry(iopc_struct, mod, &pkg->modules) {
        if (strequal(mod->name, name)) {
            return mod;
        }
    }
    return NULL;
}

static bool
pkg_provides_iface(iopc_pkg_t *pkg, const char *type, bool visible)
{
    qv_for_each_entry(iopc_iface, iface, &pkg->ifaces) {
        if ((iface->is_visible || !visible) && strequal(iface->name, type))
            return true;
    }
    return false;
}

static iopc_struct_t *
pkg_provides_struct(iopc_pkg_t *pkg, const char *type, bool visible)
{
    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        if ((st->is_visible || !visible) && strequal(st->name, type))
            return st;
    }
    return NULL;
}

static bool
pkg_provides_fields_for_param(iopc_pkg_t *pkg, iopc_field_t *field,
                              const char *snmp_obj, const char *name)
{
    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        bool has_snmp_params_attr = false;

        if (!strequal(st->name, snmp_obj)) {
            continue;
        }
        /* Check attribute snmp params */
        qv_for_each_entry(iopc_attr, attr, &st->attrs) {
            if (attr->desc->id == IOPC_ATTR_SNMP_PARAMS) {
                has_snmp_params_attr = true;
                break;
            }
        }
        if (!has_snmp_params_attr) {
            fatal_loc("snmpObj `%s` does not have the attribute @snmpParams",
                      st->loc, st->name);
        }
        qv_for_each_entry(iopc_field, f, &st->fields) {
            iopc_extends_t *xt;

            if (!strequal(f->name, name)) {
                continue;
            }

            xt = iopc_extends_new();

            /* Define parent */
            xt->loc = st->loc;
            xt->pkg = pkg;
            xt->path = iopc_path_dup(pkg->name);
            xt->name = p_strdup(st->name);
            xt->st = st;

            field->field_origin = f;
            qv_append(iopc_extends, &field->parents, xt);

            return true;
        }
    }
    return false;
}

static iopc_enum_t *
pkg_provides_enum(iopc_pkg_t *pkg, const char *type, bool visible)
{
    qv_for_each_entry(iopc_enum, en, &pkg->enums) {
        if ((en->is_visible || !visible) && strequal(en->name, type))
            return en;
    }
    return NULL;
}

static iopc_field_t *
pkg_provides_typedef(iopc_pkg_t *pkg, const char *type, bool visible)
{
    qv_for_each_entry(iopc_field, tdef, &pkg->typedefs) {
        if ((tdef->is_visible || !visible) && strequal(tdef->name, type))
            return tdef;
    }
    return NULL;
}

static int
iopc_ifaces_find_n_check(iopc_pkg_t *pkg, iopc_field_t *iface)
{
    bool found = false;
    iopc_pkg_t *t_pkg = iface->type_pkg;
    int res = 0;

    if (t_pkg) {
        if (pkg_provides_iface(t_pkg, iface->type_name, false))
            return 0;
        fatal_loc("unable to find interface `%s` in pkg `%s`",
                  iface->loc, iface->type_name, pretty_path_dot(t_pkg->name));
    }

    if (pkg_provides_iface(pkg, iface->type_name, false)) {
        found = true;
        iface->type_pkg = t_pkg = pkg;
    }

    qv_for_each_pos_safe(iopc_import, i, &pkg->imports) {
        iopc_pkg_t *ipkg = pkg->imports.tab[i]->pkg;

        if (!pkg_provides_iface(ipkg, iface->type_name, true))
            continue;
        if (!found) {
            pkg->imports.tab[i]->used = found = true;
            iface->type_pkg = t_pkg = ipkg;
            continue;
        }

        warn_loc("interface `%s` is provided by both `%s` and `%s`",
                 iface->loc, iface->type_name,
                 pretty_path_dot(t_pkg->name),
                 pretty_path_dot(ipkg->name));
    }
    if (!found) {
        fatal_loc("unable to find any pkg providing interface `%s`",
                  iface->loc, iface->type_name);
    }
    iopc_path_delete(&iface->type_path);
    iface->type_path = iopc_path_dup(t_pkg->name);
    return res;
}

static int
iopc_modules_find_n_check(iopc_pkg_t *pkg, iopc_extends_t *xt)
{
    iopc_pkg_t *t_pkg = xt->pkg;
    int res = 0;

    if (t_pkg) {
        xt->st = pkg_find_module(t_pkg, xt->name);
        if (xt->st) {
            return 0;
        }
        fatal_loc("unable to find module `%s` in pkg `%s`",
                  xt->loc, xt->name, pretty_path_dot(t_pkg->name));
    }

    xt->st = pkg_find_module(pkg, xt->name);
    if (xt->st) {
        xt->pkg = t_pkg = pkg;
    }

    qv_for_each_pos_safe(iopc_import, i, &pkg->imports) {
        iopc_pkg_t *ipkg = pkg->imports.tab[i]->pkg;
        iopc_struct_t *st;

        st = pkg_find_module(ipkg, xt->name);
        if (!st) {
            continue;
        }
        if (!xt->st) {
            xt->st  = st;
            xt->pkg = t_pkg = ipkg;
            pkg->imports.tab[i]->used = true;
            continue;
        }

        warn_loc("module `%s` is provided by both `%s` and `%s`",
                 xt->loc, xt->name,
                 pretty_path_dot(t_pkg->name),
                 pretty_path_dot(ipkg->name));
    }
    if (!xt->st) {
        fatal_loc("unable to find any pkg providing module `%s`",
                  xt->loc, xt->name);
    }
    iopc_path_delete(&xt->path);
    xt->path = iopc_path_dup(t_pkg->name);
    return res;
}

static void
iopc_apply_typedef(const iopc_field_t *tdef, iopc_field_t *f, bool f_is_tdef)
{
    assert (tdef->kind != IOP_T_STRUCT || tdef->struct_def != NULL);

    f->kind       = tdef->kind;
    if ((f->repeat != IOP_R_REQUIRED && f->repeat != IOP_R_DEFVAL)
    &&  tdef->repeat != IOP_R_REQUIRED &&  f->repeat != tdef->repeat)
    {
        fatal_loc("cannot declare repeated optional fields", f->loc);
    } else
    if (tdef->repeat != IOP_R_REQUIRED) {
        f->repeat = tdef->repeat;
    }
    p_delete(&f->type_name);
    iopc_path_delete(&f->type_path);
    f->type_pkg = NULL;
    if (tdef->kind == IOP_T_STRUCT || tdef->kind == IOP_T_UNION
    ||  tdef->kind == IOP_T_ENUM)
    {
        f->type_pkg   = tdef->type_pkg;
        f->type_name  = p_strdup(tdef->type_name);
        f->type_path  = iopc_path_dup(tdef->type_path);
        f->struct_def = tdef->struct_def;
    }

    iopc_check_field_attributes(f, f_is_tdef);
    qv_for_each_entry(iopc_attr, e, &tdef->attrs) {
        iopc_attr_t *attr = iopc_attr_dup(e);

        iopc_field_add_attr(f, &attr, f_is_tdef);
    }
}

static void iopc_types_find_n_check(iopc_pkg_t *pkg, iopc_field_t *f,
                                    bool f_is_tdef);

static int iopc_find_type_in_pkg(iopc_pkg_t *pkg, iopc_field_t *f,
                                 const char *name, bool visible,
                                 bool f_is_tdef)
{
    iopc_struct_t *st;
    iopc_enum_t   *en;
    iopc_field_t  *tdef;

    if ((st = pkg_provides_struct(pkg, name, visible))) {
        if (!f->type_pkg) {
            f->type_pkg = pkg;
        }
        if (!f->found_pkg) {
            f->found_pkg = pkg;
        }
        f->struct_def = st;
        f->kind = (st->type == STRUCT_TYPE_UNION) ? IOP_T_UNION : IOP_T_STRUCT;
        return 0;
    }
    if ((en = pkg_provides_enum(pkg, name, visible))) {
        if (!f->type_pkg) {
            f->type_pkg = pkg;
        }
        if (!f->found_pkg) {
            f->found_pkg = pkg;
        }
        f->enum_def = en;
        f->kind = IOP_T_ENUM;
        return 0;
    }
    if ((tdef = pkg_provides_typedef(pkg, name, visible))) {
        t_scope;
        t_push_loc(f->loc, "in typedef for type `%s` in pkg `%s`",
                   name, pretty_path_dot(pkg->name));
        iopc_types_find_n_check(pkg, tdef, true);
        pop_loc();

        iopc_apply_typedef(tdef, f, f_is_tdef);
        if (!f->found_pkg) {
            f->found_pkg = pkg;
        }
        return 0;
    }

    return -1;
}

static void
iopc_types_find_n_check(iopc_pkg_t *pkg, iopc_field_t *f, bool f_is_tdef)
{
    t_scope;
    const char *original_name;

    if (f->kind != IOP_T_STRUCT || f->struct_def != NULL) {
        return;
    }

    if (f->resolving) {
        fatal_loc("recursive typedef for type `%s` in pkg `%s`",
                  f->loc, f->type_name,
                  pretty_path_dot(f->type_pkg ? f->type_pkg->name : pkg->name));
    }

    f->resolving = true;
    if (f->type_pkg) {
        if (iopc_find_type_in_pkg(f->type_pkg, f, f->type_name, false,
                                  f_is_tdef) < 0)
        {
            fatal_loc("unable to find type `%s` in pkg `%s`",
                      f->loc, f->type_name, pretty_path_dot(f->type_pkg->name));
        }
        goto check_defval;
    }

    original_name = t_strdup(f->type_name);
    iopc_find_type_in_pkg(pkg, f, original_name, false, f_is_tdef);

    qv_for_each_pos_safe(iopc_import, i, &pkg->imports) {
        iopc_pkg_t *ipkg = pkg->imports.tab[i]->pkg;
        bool resolved = !(f->kind == IOP_T_STRUCT && !f->struct_def);

        if (iopc_find_type_in_pkg(ipkg, f, original_name, true,
                                  f_is_tdef) < 0)
        {
            continue;
        } else
        if (resolved) {
            if (iopc_g.v3) {
                fatal_loc("type `%s` is provided by both `%s` and `%s`",
                          f->loc, original_name,
                          pretty_path_dot(f->found_pkg->name),
                          pretty_path_dot(ipkg->name));
            }
            warn_loc("type `%s` is provided by both `%s` and `%s`",
                     f->loc, original_name,
                     pretty_path_dot(f->found_pkg->name),
                     pretty_path_dot(ipkg->name));
        } else {
            pkg->imports.tab[i]->used = true;
            f->type_pkg = ipkg;
        }
    }
    if (f->kind == IOP_T_STRUCT && !f->struct_def) {
        fatal_loc("unable to find any pkg providing type `%s`",
                  f->loc, original_name);
    }
    iopc_path_delete(&f->type_path);
    if (f->type_pkg) {
        f->type_path = iopc_path_dup(f->type_pkg->name);
    }

  check_defval:
    f->resolving = false;
    if (!f->struct_def) {
        return;
    }

    if (f->kind != IOP_T_ENUM && f->repeat == IOP_R_DEFVAL) {
        fatal_loc("default values aren't allowed for unions or structures",
                  f->loc);
    }
    iopc_check_field_attributes(f, f_is_tdef);
}

static void iopc_t_resolve(iopc_pkg_t *pkg);
static void iopc_i_resolve(iopc_pkg_t *pkg);

static void iopc_field_resolve(iopc_pkg_t *pkg, iopc_field_t *field,
                               iopc_struct_t *st)
{
    t_scope;

    if (field->kind != IOP_T_STRUCT)
        return;
    iopc_types_find_n_check(pkg, field, st == NULL);
    if (pkg == field->type_pkg || !field->struct_def)
        return;
    if (field->repeat == IOP_R_REPEATED
    ||  field->repeat == IOP_R_OPTIONAL)
    {
        iopc_pkg_t *fpkg = field->type_pkg;

        if (!iopc_g.v2)
            return;
        /* In a normal situation we avoid to resolve this field because we
         * can have an authorized recursion. But we must know if the field
         * contains a constraints and we can't recurse in this context, so
         * we schedule the type resolution for later. */
        if (!fpkg->t_resolved) {
            qv_append(iopc_pkg, &_G.resolve_list, fpkg);
        }
        return;
    }
    if (st) {
        t_push_loc(field->loc, "in package %s, type %s, field %s needs package %s",
                   pretty_path_dot(pkg->name), st->name, field->name,
                   pretty_path_dot(field->type_path));
    } else {
        t_push_loc(field->loc, "in package %s, typedef %s needs package %s",
                   pretty_path_dot(pkg->name), field->name,
                   pretty_path_dot(field->type_path));
    }
    iopc_t_resolve(field->type_pkg);
    pop_loc();
}

static void
resolve_pkg_parent_and_params(iopc_extends_t *xt, iopc_pkg_t *pkg,
                              iopc_struct_type_t type,
                              const char *name, const char *type_obj,
                              const char *action)
{
    t_scope;
    iopc_struct_t *st = NULL;

    if (!xt->pkg) {
        xt->pkg = pkg;
        iopc_path_delete(&xt->path);
        xt->path = iopc_path_dup(pkg->name);
    } else
    if (xt->pkg != pkg) {
        t_push_loc(xt->loc, "in package %s, %s  %s, needs package %s "
                   "for %s", pretty_path_dot(pkg->name), type_obj, name,
                   pretty_path_dot(xt->pkg->name), action);
        iopc_t_resolve(xt->pkg);
        pop_loc();
    }
    if (xt->is_snmp_root) {
        return;
    }
    if (!(st = pkg_provides_struct(xt->pkg, xt->name, true))) {
        fatal_loc("pkg `%s` does not provide %s `%s` when resolving %s of "
                  "%s `%s`", xt->loc, pretty_path_dot(xt->pkg->name),
                  iopc_struct_type_to_str(type), xt->name, action,
                  type_obj, name);
    }
    if (st->type != type) {
        fatal_loc("parent object `%s` is not a %s", xt->loc,
                  st->name, iopc_struct_type_to_str(type));
    }
    if (type == STRUCT_TYPE_CLASS && st->is_local && xt->pkg != pkg) {
        fatal_loc("as the parent class `%s` of class `%s` is `local`, "
                  "both classes need to be in the same package",
                  xt->loc, st->name, name);
    }
    xt->st = st;
}

static void resolve_snmp_iface_field(iopc_iface_t *iface, iopc_field_t *field)
{
    bool resolved = false;
    bool found = false;
    /* Keep information about the field */
    iopc_loc_t loc = field->loc;
    int pos = field->pos;

    if (!field->snmp_is_from_param) {
        fatal_loc("any field should be a snmpObj previously defined",
                  field->loc);
    }

    qv_for_each_entry(iopc_attr, attr, &iface->attrs) {
        if (attr->desc->id != IOPC_ATTR_SNMP_PARAMS_FROM) {
            continue;
        }
        qv_for_each_entry(iopc_extends, from, &attr->snmp_params_from) {
            found = pkg_provides_fields_for_param(from->pkg, field,
                                                  from->name, field->name);
            if (found && resolved) {
                fatal_loc("several snmpObjs given by the attribute "
                          "snmpParamsFrom have a field with the same name "
                          "`%s`", field->loc, field->name);
            }
            if (found) {
                resolved = true;
            }
        }
        if (!resolved) {
            fatal_loc("when resolving snmpIface `%s`, field `%s` is not "
                      "found in any of the snmpObjs given by the attribute "
                      "snmpParamsFrom", field->loc, iface->name, field->name);
        } else {
            /* Give back information on the field */
            field->loc = loc;
            field->pos = pos;
        }
    }
}

static void
resolve_pkg_parent(iopc_extends_t *xt, iopc_pkg_t *pkg,
                   iopc_struct_type_t type, const char *name)
{
    const char *str = iopc_struct_type_to_str(type);

    resolve_pkg_parent_and_params(xt, pkg, type, name, str, "inheritance");
}

static void iopc_struct_resolve(iopc_pkg_t *pkg, iopc_struct_t *st)
{
    /* Resolve inheritance */
    if (st->extends.len) {
        t_scope;
        iopc_extends_t *xt = st->extends.tab[0];

        assert (st->extends.len == 1);
        resolve_pkg_parent(xt, pkg, st->type, st->name);
    }

    /* Resolve fields */
    qv_for_each_entry(iopc_field, f, &st->fields) {
        iopc_field_resolve(pkg, f, st);

        if (st->type == STRUCT_TYPE_UNION) {
            if (f->repeat == IOP_R_OPTIONAL) {
                fatal_loc("optional members are forbidden in union types", f->loc);
            }
            if (f->repeat == IOP_R_REPEATED) {
                fatal_loc("repeated members are forbidden in union types", f->loc);
            }
        }

    }

    /* Resolve static fields */
    qv_for_each_entry(iopc_field, f, &st->static_fields) {
        iopc_field_resolve(pkg, f, st);
    }
}

static void iopc_snmp_iface_resolve(iopc_pkg_t *pkg, iopc_iface_t *iface)
{
    /* Resolve inheritance */
    iopc_extends_t *xt;
    bool resolved = false;

    if (iface->extends.len != 1) {
            fatal_loc("a snmpIface should always have one and only parent",
                      iface->loc);
    }
    xt = iface->extends.tab[0];
    resolve_pkg_parent_and_params(xt, pkg, STRUCT_TYPE_SNMP_OBJ, iface->name,
                                  "snmpIface", "inheritance");

    /* Check params from */
    qv_for_each_entry(iopc_attr, attr, &iface->attrs) {
        if (attr->desc->id != IOPC_ATTR_SNMP_PARAMS_FROM) {
            continue;
        }
        qv_for_each_pos(iopc_extends, pos, &attr->snmp_params_from) {
            iopc_extends_t *xt_param = attr->snmp_params_from.tab[pos];

            resolve_pkg_parent_and_params(xt_param, pkg, STRUCT_TYPE_SNMP_OBJ,
                                          iface->name, "snmpIface",
                                          "snmp params");
            resolved = true;
        }
    }
    if (!resolved) {
        fatal_loc("snmpIface should have an attribute snmpParamsFrom",
                  iface->loc);
    }

    /* Resolve rpcs in funs */
    qv_for_each_entry(iopc_fun, fun, &iface->funs) {
        fun->arg->contains_snmp_info = true;
        qv_for_each_entry(iopc_field, field, &fun->arg->fields) {
            resolve_snmp_iface_field(iface, field);
        }
    }
}

static void iopc_module_check_extends(iopc_struct_t *mod, iopc_extends_t *xt)
{
    qv_for_each_entry(iopc_field, f2, &xt->st->fields) {
        qv_for_each_entry(iopc_field, f, &mod->fields) {
            if (strequal(f->name, f2->name)) {
                fatal_loc("module %s cannot extend %s.%s, "
                          "both define an interface %s",
                          xt->loc, mod->name,
                          pretty_path_dot(xt->pkg->name), xt->name, f->name);
            }
            if (f->tag == f2->tag) {
                fatal_loc("module %s cannot extend %s.%s, "
                          "both define a tag %d",
                          xt->loc, mod->name,
                          pretty_path_dot(xt->pkg->name), xt->name, f->tag);
            }
        }
        qv_append(iopc_field, &mod->fields, iopc_field_dup(f2));
    }
}

/* check intra-package dependencies */
static void iopc_struct_check_circular_dep(iopc_pkg_t *pkg,
                                           iopc_struct_t *st)
{
    if (st->resolved)
        return;
    if (st->resolving)
        fatal_loc("circular dependency", *qv_last(iopc_loc, &iopc_g.loc_stack));

    st->resolving = true;
    qv_for_each_entry(iopc_field, field, &st->fields) {
        if (pkg != field->type_pkg
        ||  (field->kind != IOP_T_STRUCT && field->kind != IOP_T_UNION)
        ||  field->repeat == IOP_R_OPTIONAL
        ||  field->repeat == IOP_R_REPEATED
        ||  (field->is_ref && st->type == STRUCT_TYPE_UNION && st->fields.len > 1)
        ||  (field->is_ref && field->kind != IOP_T_STRUCT))
        {
            continue;
        } else {
            t_scope;
            t_push_loc(field->loc, "in struct %s, field %s has type %s",
                       st->name, field->name, field->type_name);
            iopc_struct_check_circular_dep(pkg, field->struct_def);
            pop_loc();
        }
    }
    st->resolved = true;
}

qm_kptr_t(field_struct, char, iopc_struct_t *,
          qhash_str_hash, qhash_str_equal);

static void
iopc_struct_check_inheritance(iopc_struct_t *st, iopc_struct_t *parent_st,
                              qm_t(field_struct) *fields,
                              qm_t(id_class) *ids)
{
    t_scope;
    iopc_struct_t *xt;
    const char *type;

    assert (iopc_is_class(st->type) || iopc_is_snmp_obj(st->type));
    assert (parent_st->type == st->type);

    type = iopc_struct_type_to_str(st->type);

    if (parent_st->resolving_inheritance)
        fatal_loc("circular dependency", *qv_last(iopc_loc, &iopc_g.loc_stack));

    /* Check field names unicity */
    qv_for_each_entry(iopc_field, field, &parent_st->fields) {
        uint32_t pos = qm_put(field_struct, fields, field->name, parent_st, 0);

        if (pos & QHASH_COLLISION) {
            parent_st = fields->values[pos ^ QHASH_COLLISION];
            clear_loc();
            fatal_loc("field name `%s` is also used in child `%s`",
                      field->loc, field->name, parent_st->name);
        }
    }

    /* Check and resolve static fields */
    if (parent_st == st) {
        goto check_ids;
    }
    qv_for_each_entry(iopc_field, master_field, &parent_st->static_fields) {
        qv_for_each_entry(iopc_field, field, &st->static_fields) {
            if (strequal(master_field->name, field->name)) {
                if (!field->defval_type) {
                    clear_loc();
                    fatal_loc("field `%s` already defined by parent `%s`",
                              field->loc, field->name, parent_st->name);
                }
                if (master_field->kind != field->kind) {
                    clear_loc();
                    fatal_loc("incompatible type for static field `%s`: "
                              "should be `%s`", field->loc, field->name,
                              iop_type_get_string_desc(master_field->kind));
                }
                break;
            }
        }
    }

    /* Check class or snmpObj ids unicity */
  check_ids:
    if (!parent_st->resolved_inheritance) {
        qm_add(id_class, ids, parent_st->class_id, parent_st);
    }
    if (!parent_st->extends.len && st->type == STRUCT_TYPE_CLASS) {
        /* This is a master class, store ids in its children_by_id
         * table */
        qm_for_each_pos(id_class, slot, ids) {
            iopc_struct_t *st2 = ids->values[slot];
            uint32_t pos;

            pos = __qm_put(id_class, &parent_st->children_by_id,
                           st2->class_id, st2, 0);
            if (pos & QHASH_COLLISION) {
                parent_st =
                    parent_st->children_by_id.values[pos ^ QHASH_COLLISION];
                clear_loc();
                fatal_loc("id %d is also used by class `%s`",
                          st2->loc, st2->class_id, parent_st->name);
            }
        }
        parent_st->resolved_inheritance  = true;
        return;
    }
    assert (parent_st->extends.len == 1);
    assert (!qm_len(id_class, &parent_st->children_by_id));

    if (parent_st->extends.tab[0]->is_snmp_root) {
        return;
    }
    parent_st->resolving_inheritance = true;

    xt = parent_st->extends.tab[0]->st;

    /* Check for circular dependencies */
    t_push_loc(parent_st->loc, "%s %s inherits from %s %s",
               type, parent_st->name, type, xt->name);
    iopc_struct_check_inheritance(st, xt, fields, ids);
    pop_loc();

    parent_st->resolving_inheritance = false;
    parent_st->resolved_inheritance  = true;
}

static void iopc_struct_check_abstract_static_fields(const iopc_struct_t *st)
{
    const iopc_struct_t *it_st = st->extends.tab[0]->st;
    qh_t(str) fields_seen;

    /* This function is checking that all the static fields without value
     * defined by potential direct abstract parents of "st" are defined in
     * "st" (and with a value).
     */

    /* if SNMP root then the structure extends.tab[0]->st is not defined */
    if (st->extends.tab[0]->is_snmp_root) {
        return;
    }
    if (st->is_abstract || !it_st->is_abstract) {
        return;
    }

    qh_init_cached(str, &fields_seen);
    qv_for_each_entry(iopc_field, field, &st->static_fields) {
        assert (field->defval_type);
        qh_add(str, &fields_seen, field->name);
    }

    do {
        qv_for_each_entry(iopc_field, field, &it_st->static_fields) {
            if (field->defval_type) {
                qh_add(str, &fields_seen, field->name);
            } else
            if (qh_find(str, &fields_seen, field->name) < 0) {
                clear_loc();
                fatal_loc("class `%s` must define a static field named "
                          "`%s`", st->loc, st->name, field->name);
            }
        }
    } while (it_st->extends.len && (it_st = it_st->extends.tab[0]->st)
         &&  it_st->is_abstract);

    qh_wipe(str, &fields_seen);
}

static void iopc_t_resolve(iopc_pkg_t *pkg)
{
    if (pkg->t_resolved)
        return;
    if (pkg->t_resolving)
        fatal_loc("circular dependency", *qv_last(iopc_loc, &iopc_g.loc_stack));

    pkg->t_resolving = true;
    qv_for_each_entry(iopc_field, tdef, &pkg->typedefs) {
        iopc_field_resolve(pkg, tdef, NULL);
    }
    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        iopc_struct_resolve(pkg, st);
    }
    qv_for_each_entry(iopc_iface, iface, &pkg->ifaces) {
        if (iface->type == IFACE_TYPE_SNMP_IFACE) {
            iopc_snmp_iface_resolve(pkg, iface);
        }
    }

    pkg->t_resolving = false;
    pkg->t_resolved = true;

    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        iopc_struct_check_circular_dep(pkg, st);
    }

    /* Check inheritance */
    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        qm_t(field_struct) fields;
        qm_t(id_class) ids;

        if (!st->extends.len) {
            continue;
        }

        /* This hash table will be recursively filled with the field names
         * of st and all his parents */
        qm_init(field_struct, &fields);

        /* This hash table will be recursively filled with the ids of the
         * classes st and its parents, up to the first resolved class.
         * Its content will be transfered into the children_by_id hash
         * table of the master class. */
        qm_init(id_class, &ids);

        iopc_struct_check_inheritance(st, st, &fields, &ids);
        qm_wipe(field_struct, &fields);
        qm_wipe(id_class, &ids);

        iopc_struct_check_abstract_static_fields(st);
    }
}

static void iopc_i_resolve(iopc_pkg_t *pkg)
{
    if (pkg->i_resolved)
        return;
    if (pkg->i_resolving)
        fatal_loc("circular dependency", *qv_last(iopc_loc, &iopc_g.loc_stack));

    pkg->i_resolving = true;
    qv_for_each_entry(iopc_iface, iface, &pkg->ifaces) {
        qv_for_each_entry(iopc_fun, fun, &iface->funs) {
            if (fun->arg) {
                if (fun->arg_is_anonymous) {
                    iopc_struct_resolve(pkg, fun->arg);
                    fun->arg->iface = iface;
                } else {
                    iopc_types_find_n_check(pkg, fun->farg, false);
                }
            }
            if (fun->res) {
                if (fun->res_is_anonymous) {
                    iopc_struct_resolve(pkg, fun->res);
                    fun->res->iface = iface;
                } else {
                    iopc_types_find_n_check(pkg, fun->fres, false);
                }
            }
            if (fun->exn) {
                if (fun->exn_is_anonymous) {
                    iopc_struct_resolve(pkg, fun->exn);
                    fun->exn->iface = iface;
                } else {
                    iopc_types_find_n_check(pkg, fun->fexn, false);
                }
            }
        }
    }
    qv_for_each_entry(iopc_struct, mod, &pkg->modules) {
        qv_for_each_entry(iopc_field, iface, &mod->fields) {
            iopc_ifaces_find_n_check(pkg, iface);
            if (pkg == iface->type_pkg) {
                continue;
            } else {
                t_scope;
                t_push_loc(iface->loc,
                           "in package %s, module %s, iface %s needs package %s",
                           pretty_path_dot(pkg->name), mod->name, iface->name,
                           pretty_path_dot(iface->type_path));
                iopc_resolve(iface->type_pkg);
                pop_loc();
            }
        }
        qv_for_each_entry(iopc_extends, xt, &mod->extends) {
            iopc_modules_find_n_check(pkg, xt);
            if (xt->pkg != pkg) {
                t_scope;
                t_push_loc(xt->loc,
                           "in package %s, module %s, needs package %s",
                           pretty_path_dot(pkg->name), xt->name,
                           pretty_path_dot(xt->path));
                if (xt->pkg->i_resolving || xt->pkg->t_resolving) {
                    fatal_loc("circular dependency", xt->loc);
                }
                iopc_resolve(xt->pkg);
                pop_loc();
            }
            iopc_module_check_extends(mod, xt);
        }
    }
    qv_for_each_entry(iopc_import, ipkg, &pkg->imports) {
        if (!ipkg->used) {
            warn_loc("import not used", ipkg->loc);
        }
    }

    pkg->i_resolving = false;
    pkg->i_resolved  = true;
}

void iopc_resolve(iopc_pkg_t *pkg)
{
    iopc_t_resolve(pkg);
    iopc_i_resolve(pkg);
}

static int enum_get_value(iopc_enum_t *en, const char *name)
{
    qv_for_each_entry(iopc_enum_field, elem, &en->values) {
        if (strequal(elem->name, name)) {
            return elem->value;
        }
    }
    return -1;
}

static void check_defval_enum_allow(iopc_field_t *f, iopc_attr_t *attr)
{
    int64_t i64 = f->defval.u64;

    qv_for_each_ptr(iopc_arg, arg, &attr->args) {
        if (enum_get_value(f->enum_def, arg->v.s.s) == i64) {
            if (attr->desc->id == IOPC_ATTR_ALLOW) {
                return;
            }
            fatal_loc("invalid default value on enum field: %jd", f->loc, i64);
        }
    }

    if (attr->desc->id == IOPC_ATTR_ALLOW) {
        fatal_loc("invalid default value on enum field: %jd", f->loc,
                  i64);
    }
}

static void check_defval_int(iopc_field_t *f)
{
    bool is_signed = iopc_field_is_signed(f);
    uint64_t u64 = f->defval.u64;
    int64_t  i64 = f->defval.u64;

    if (f->defval_type != IOPC_DEFVAL_INTEGER) {
        fatal_loc("invalid default value on integer field (wrong type)",
                  f->loc);
    }
    if (!is_signed && f->defval_is_signed) {
        fatal_loc("invalid default value on unsigned integer field: %jd",
                  f->loc, i64);
    }
    switch (f->kind) {
      case IOP_T_BOOL:
        if (u64 > 1) {
            fatal_loc("invalid default value on bool field: %jd", f->loc,
                      i64);
        }
        break;
      case IOP_T_U8:
        if (u64 > UINT8_MAX) {
            fatal_loc("invalid default value on ubyte field: %ju", f->loc,
                      u64);
        }
        break;
      case IOP_T_I8:
        if (i64 < INT8_MIN || i64 > INT8_MAX) {
            fatal_loc("invalid default value on byte field: %jd", f->loc,
                      i64);
        }
        break;
      case IOP_T_U16:
        if (u64 > UINT16_MAX) {
            fatal_loc("invalid default value on ushort field: %ju", f->loc,
                      u64);
        }
        break;
      case IOP_T_I16:
        if (i64 < INT16_MIN || i64 > INT16_MAX) {
            fatal_loc("invalid default value on short field: %jd", f->loc,
                      i64);
        }
        break;
      case IOP_T_U32:
        if (u64 > UINT32_MAX) {
            fatal_loc("invalid default value on uint field: %ju", f->loc,
                      u64);
        }
        break;
      case IOP_T_ENUM:
      case IOP_T_I32:
        if (i64 < INT32_MIN || i64 > INT32_MAX) {
            fatal_loc("invalid default value on int field: %jd", f->loc, i64);
        }
        break;
      default:
        break;
    }
    if (f->kind == IOP_T_ENUM) {
        bool strict = false;

        qv_for_each_entry(iopc_attr, attr, &f->attrs) {
            if (attr->desc->id == IOPC_ATTR_ALLOW
            ||  attr->desc->id == IOPC_ATTR_DISALLOW)
            {
                check_defval_enum_allow(f, attr);
            }
        }

        qv_for_each_entry(iopc_attr, attr, &f->enum_def->attrs) {
            if (attr->desc->id == IOPC_ATTR_STRICT) {
                strict = true;
                break;
            }
        }
        if (!strict) {
            return;
        }
        qv_for_each_entry(iopc_enum_field, value, &f->enum_def->values) {
            if (value->value == i64) {
                return;
            }
        }
        fatal_loc("invalid default value on strict enum field: %jd", f->loc,
                  i64);
        return;
    }
    qv_for_each_entry(iopc_attr, attr, &f->attrs) {
        int64_t val;

        switch (attr->desc->id) {
          case IOPC_ATTR_MAX:
            val = IOPC_ATTR_GET_ARG_V(int64_t, &attr->args.tab[0]);
            if (is_signed && i64 > val) {
                fatal_loc("invalid default value, "
                          "violation of @max constraint: %jd > %jd", f->loc,
                          i64, val);
            } else
            if (!is_signed && u64 > (uint64_t)val) {
                fatal_loc("invalid default value, "
                          "violation of @max constraint: %ju > %ju", f->loc,
                          u64, val);
            }
            break;
          case IOPC_ATTR_MIN:
            val = IOPC_ATTR_GET_ARG_V(int64_t, &attr->args.tab[0]);
            if (is_signed && i64 < val) {
                fatal_loc("invalid default value, "
                          "violation of @min constraint: %jd < %jd", f->loc,
                          i64, val);
            } else
            if (!is_signed && u64 < (uint64_t)val) {
                fatal_loc("invalid default value, "
                          "violation of @min constraint: %ju < %ju", f->loc,
                          u64, val);
            }
            break;
          case IOPC_ATTR_NON_ZERO:
            if (!i64) {
                fatal_loc("invalid default value, "
                          "violation of @nonZero constraint", f->loc);
            }
            break;
          default:
            break;
        }
    }
}

static void check_defval_double(iopc_field_t *f)
{
    if (f->defval_type == IOPC_DEFVAL_STRING) {
        fatal_loc("string default value on double field",
                  f->loc);
    } else
    if (f->defval_type == IOPC_DEFVAL_INTEGER) {
        f->defval.d = f->defval.u64;
    }

    qv_for_each_entry(iopc_attr, attr, &f->attrs) {
        double val;

        switch (attr->desc->id) {
          case IOPC_ATTR_MAX:
            val = IOPC_ATTR_GET_ARG_V(double, &attr->args.tab[0]);
            if (f->defval.d > val) {
                fatal_loc("invalid default value, "
                          "violation of @max constraint: %f > %f", f->loc,
                          f->defval.d, val);
            }
            break;
          case IOPC_ATTR_MIN:
            val = IOPC_ATTR_GET_ARG_V(double, &attr->args.tab[0]);
            if (f->defval.d < val) {
                fatal_loc("invalid default value, "
                          "violation of @min constraint: %f < %f", f->loc,
                          f->defval.d, val);
            }
            break;
          case IOPC_ATTR_NON_ZERO:
            if (!f->defval.d) {
                fatal_loc("invalid default value, "
                          "violation of @nonZero constraint", f->loc);
            }
            break;
          default:
            break;
        }
    }
}

static void check_defval_string(iopc_field_t *f)
{
    int len;
    if (f->defval_type != IOPC_DEFVAL_STRING) {
        fatal_loc("invalid default value on string field",
                  f->loc);
    }
    len = strlen(f->defval.ptr);

    qv_for_each_entry(iopc_attr, attr, &f->attrs) {
        int64_t val;

        switch (attr->desc->id) {
          case IOPC_ATTR_MAX_LENGTH:
            val = IOPC_ATTR_GET_ARG_V(int64_t, &attr->args.tab[0]);
            if (len > val) {
                fatal_loc("invalid default value, "
                          "violation of @maxLength constraint: %d > %jd",
                          f->loc, len, val);
            }
            break;
          case IOPC_ATTR_MIN_LENGTH:
            val = IOPC_ATTR_GET_ARG_V(int64_t, &attr->args.tab[0]);
            if (len < val) {
                fatal_loc("invalid default value, "
                          "violation of @minLength constraint: %d < %jd",
                          f->loc, len, val);
            }
            break;
          case IOPC_ATTR_NON_EMPTY:
            if (!len) {
                fatal_loc("invalid default value, "
                          "violation of @nonEmpty constraint", f->loc);
            }
            break;
          default:
            break;
        }
    }
}

void iopc_resolve_second_pass(iopc_pkg_t *pkg)
{
    /* second pass: resolving of weak deps */

    /* XXX: do not use qv_for_each_ptr/entry here, entries get appended to
     * the vector while it is consumed.
     */
    qv_for_each_pos(iopc_pkg, pos, &_G.resolve_list) {
        iopc_pkg_t *rpkg = _G.resolve_list.tab[pos];

        if (!rpkg->t_resolved) {
            iopc_resolve(rpkg);
        }
    }
    qv_wipe(iopc_pkg, &_G.resolve_list);

    /* Count static fields having a default value */
    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        if (st->type == STRUCT_TYPE_CLASS && st->is_abstract) {
            st->nb_real_static_fields = 0;
            qv_for_each_entry(iopc_field, f, &st->static_fields) {
                if (f->defval_type) {
                    st->nb_real_static_fields++;
                }
            }
        } else {
            st->nb_real_static_fields = st->static_fields.len;
        }
        qv_for_each_entry(iopc_field, f, &st->fields) {
            if (f->is_ref) {
                if (f->repeat != IOP_R_REQUIRED) {
                    fatal_loc("only mandatory fields can be references",
                              f->loc);
                }
                if ((f->kind != IOP_T_STRUCT && f->kind != IOP_T_UNION)
                ||  f->struct_def->type == STRUCT_TYPE_CLASS)
                {
                    fatal_loc("references can only be applied to structures "
                              "or unions", f->loc);
                }
            }
            if (f->repeat == IOP_R_DEFVAL) {
                switch (f->kind) {
                  case IOP_T_ENUM:
                  case IOP_T_I8 ... IOP_T_U64:
                  case IOP_T_BOOL:
                    check_defval_int(f);
                    break;
                  case IOP_T_DOUBLE:
                    check_defval_double(f);
                    break;

                  case IOP_T_STRING:
                  case IOP_T_DATA:
                  case IOP_T_XML:
                    check_defval_string(f);
                    break;

                  default:
                    e_panic("should not happen");
                    break;
                }
            }
        }
    }
}

qm_kvec_t(uid, lstr_t, iopc_struct_t *, qhash_lstr_hash, qhash_lstr_equal);

static void iopc_dump_attrs_sig(sb_t *sb, qv_t(iopc_attr) *attrs)
{
    assert (attrs->len < 255);
    sb_addc(sb, attrs->len); /*< start of attributes */
    qv_for_each_entry(iopc_attr, attr, attrs) {
        sb_addc(sb, attr->desc->id);
        qv_for_each_ptr(iopc_arg, arg, &attr->args) {
            put_unaligned_le64(sb_growlen(sb, 8), (intptr_t)arg->desc);
            switch (arg->type) {
              case ITOK_STRING:
              case ITOK_IDENT:
                sb_add(sb, arg->v.s.s, arg->v.s.len);
                sb_addc(sb, '\0');
                break;

              case ITOK_DOUBLE:
                put_unaligned_double_le(sb_growlen(sb, 8), arg->v.d);
                break;

              case ITOK_INTEGER:
              default:
                put_unaligned_le64(sb_growlen(sb, 8), arg->v.i64);
                break;
            }
        }
    }
}

static void iopc_dump_comments_sig(sb_t *sb, const qv_t(iopc_dox) *comments)
{
    sb_addc(sb, comments->len);
    qv_for_each_ptr(iopc_dox, dox, comments) {
        sb_addc(sb, '@');
        sb_add_lstr(sb, iopc_dox_type_to_lstr(dox->type));
        sb_addc(sb, '\t');
        sb_add_lstr(sb, dox->desc);
    }
}

static void iopc_dump_fields_sig(sb_t *sb, qv_t(iopc_field) *fields)
{
    qv_for_each_entry(iopc_field, f, fields) {
        put_unaligned_le16(sb_growlen(sb, 2), f->tag);
        put_unaligned_le16(sb_growlen(sb, 2), f->kind);
        put_unaligned_le16(sb_growlen(sb, 2), f->repeat);

        /* dump fields attributes and comments */
        iopc_dump_attrs_sig(sb, &f->attrs);
        iopc_dump_comments_sig(sb, &f->comments);

        /* Handles defval */
        if (f->repeat == IOP_R_DEFVAL) {
            switch (f->kind) {
              case IOP_T_ENUM:
              case IOP_T_I8 ... IOP_T_U64:
              case IOP_T_BOOL:
                put_unaligned_le64(sb_growlen(sb, 8), f->defval.u64);
                break;
              case IOP_T_DOUBLE:
                put_unaligned_double_le(sb_growlen(sb, 8), f->defval.d);
                break;

              case IOP_T_STRING:
              case IOP_T_DATA:
              case IOP_T_XML:
                sb_adds(sb, f->defval.ptr);
                sb_addc(sb, '\0');
                break;

              default:
                e_panic("should not happen");
                break;
            }
        }

        sb_adds(sb, f->name);
        sb_addc(sb, '\0');
        if (f->type_path) {
            sb_adds(sb, pretty_path_dot(f->type_path));
            sb_addc(sb, '.');
            sb_adds(sb, f->type_name);
            sb_addc(sb, '\0');
        }
    }
}

static lstr_t iopc_struct_sig(iopc_struct_t *st)
{
    if (!st->sig.s) {
        t_scope;

        qv_t(iopc_field) tab;
        sb_t sb;

        sb_init(&sb);
        sb_addc(&sb, st->type);

        /* dump struct attributes */
        iopc_dump_attrs_sig(&sb, &st->attrs);

        /* Dump fields */
        t_qv_init(iopc_field, &tab, st->fields.len);
        qv_splice(iopc_field, &tab, 0, 0, st->fields.tab, st->fields.len);
        qv_sort(iopc_field)(&tab,
            ^int (iopc_field_t * const *f1, iopc_field_t * const *f2)
        {
            return (*f1)->tag - (*f2)->tag;
        });
        iopc_dump_fields_sig(&sb, &tab);

        /* Dump static fields, even abstract ones, because of comments */
        t_qv_init(iopc_field, &tab, st->static_fields.len);
        qv_for_each_entry(iopc_field, field, &st->static_fields) {
            qv_append(iopc_field, &tab, field);
        }
        qv_sort(iopc_field)(&tab,
            ^int (iopc_field_t * const *f1, iopc_field_t * const *f2)
        {
            return strcmp((*f1)->name, (*f2)->name);
        });
        iopc_dump_fields_sig(&sb, &tab);

        if (st->type == STRUCT_TYPE_CLASS && st->extends.len) {
            /* Dump parent class signature */
            sb_add_lstr(&sb, iopc_struct_sig(st->extends.tab[0]->st));
        }

        st->sig.s = sb_detach(&sb, &st->sig.len);
        st->sig.mem_pool = MEM_LIBC;
    }

    return st->sig;
}

static void iopc_type_fold_one(qm_t(uid) *h, iopc_struct_t *st)
{
    lstr_t s = iopc_struct_sig(st);
    int pos = __qm_put(uid, h, &s, st, 0);
    iopc_struct_t *st2;

    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;

        st2 = h->values[pos];
        if (st == st2 || st->same_as)
            return;

        st->same_as = st2;
    }
}

void iopc_types_fold(iopc_pkg_t *pkg)
{
    qm_t(uid) h = QM_INIT_CACHED(uid, h);

    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        iopc_type_fold_one(&h, st);
    }
    qv_for_each_entry(iopc_iface, iface, &pkg->ifaces) {
        qv_for_each_entry(iopc_fun, fun, &iface->funs) {
            if (fun->arg && fun->arg_is_anonymous) {
                iopc_type_fold_one(&h, fun->arg);
            }
            if (fun->res && fun->res_is_anonymous) {
                iopc_type_fold_one(&h, fun->res);
            }
            if (fun->exn && fun->exn_is_anonymous) {
                iopc_type_fold_one(&h, fun->exn);
            }
        }
    }
    qm_wipe(uid, &h);
}

static void
iopc_add_depends(iopc_pkg_t *ref, iopc_pkg_t *pkg, qv_t(iopc_pkg) *deps)
{
    if (pkg && pkg != ref)
        qv_append(iopc_pkg, deps, pkg);
}

static void
get_structs_depends(iopc_pkg_t *pkg, qv_t(iopc_pkg) *deps, iopc_struct_t *st)
{
    qv_for_each_entry(iopc_field, field, &st->fields) {
        iopc_add_depends(pkg, field->type_pkg, deps);
    }
}

static bool
field_is_pointer(iopc_field_t *field)
{
    if (field->repeat != IOP_R_REPEATED
    &&  field->repeat != IOP_R_OPTIONAL)
    {
        return false;
    }
    if (field->kind != IOP_T_UNION
    &&  field->kind != IOP_T_STRUCT)
    {
        return false;
    }
    return true;
}

static void
get_structs_t_depends(iopc_pkg_t *pkg, qv_t(iopc_pkg) *t_deps,
                      qv_t(iopc_pkg) *t_weak_deps, iopc_struct_t *st)
{
    qv_for_each_entry(iopc_field, field, &st->fields) {
        if (field_is_pointer(field)) {
            iopc_add_depends(pkg, field->type_pkg, t_weak_deps);
        } else {
            iopc_add_depends(pkg, field->type_pkg, t_deps);
        }
    }
    if (st->extends.len) {
        assert (st->extends.len == 1);
        iopc_add_depends(pkg, st->extends.tab[0]->pkg, t_deps);
    }
}

static void
get_ifaces_t_depends(iopc_pkg_t *pkg, qv_t(iopc_pkg) *t_deps,
                     iopc_iface_t *iface)
{
    if (iface->extends.len) {
        assert (iface->extends.len == 1);
        if (iface->extends.tab[0]->is_snmp_root) {
            return;
        }

        iopc_add_depends(pkg, iface->extends.tab[0]->pkg, t_deps);
    }
}

void iopc_depends_uniquify(qv_t(iopc_pkg) *deps)
{
    int w = 0, r = 0;

    qv_sort(iopc_pkg)(deps, ^int (iopc_pkg_t * const *p1, iopc_pkg_t * const *p2) {
        return CMP((intptr_t)*p1, (intptr_t)*p2);
    });
    while (r < deps->len) {
        iopc_pkg_t *m = deps->tab[r++];

        deps->tab[w++] = m;
        while (r < deps->len && deps->tab[r] == m)
            r++;
    }
    deps->len = w;

    /* XXX sort packages by name to sort in the same way on each computer */
    qv_sort(iopc_pkg)(deps, ^int (iopc_pkg_t * const *p1, iopc_pkg_t * const *p2) {
        return strcmp(pretty_path_dot((*p1)->name), pretty_path_dot((*p2)->name));
    });
}

void iopc_get_depends(iopc_pkg_t *pkg,
                      qv_t(iopc_pkg) *t_deps,
                      qv_t(iopc_pkg) *t_weak_deps,
                      qv_t(iopc_pkg) *i_deps)
{
    qv_for_each_entry(iopc_struct, st, &pkg->structs) {
        get_structs_t_depends(pkg, t_deps, t_weak_deps, st);
    }

    qv_for_each_entry(iopc_iface, iface, &pkg->ifaces) {
        /* Check inheritance dependencies of snmpIface */
        get_ifaces_t_depends(pkg, t_deps, iface);

        qv_for_each_entry(iopc_fun, fun, &iface->funs) {
            if (fun->arg) {
                if (fun->arg_is_anonymous) {
                    get_structs_depends(pkg, i_deps, fun->arg);
                } else {
                    iopc_add_depends(pkg, fun->farg->type_pkg, i_deps);
                }
                if (iface->type == IFACE_TYPE_SNMP_IFACE) {
                    /* If snmpIface add dependencies necessary for the fun
                     * fields */
                    qv_for_each_entry(iopc_field, field, &fun->arg->fields) {
                        iopc_add_depends(pkg, field->parents.tab[0]->pkg,
                                         t_deps);
                    }
                }
            }
            if (fun->res) {
                if (fun->res_is_anonymous) {
                    get_structs_depends(pkg, i_deps, fun->res);
                } else {
                    iopc_add_depends(pkg, fun->fres->type_pkg, i_deps);
                }
            }
            if (fun->exn) {
                if (fun->exn_is_anonymous) {
                    get_structs_depends(pkg, i_deps, fun->exn);
                } else {
                    iopc_add_depends(pkg, fun->fexn->type_pkg, i_deps);
                }
            }
        }
    }
    qv_for_each_entry(iopc_struct, mod, &pkg->modules) {
        get_structs_depends(pkg, i_deps, mod);
    }
    iopc_depends_uniquify(t_deps);
    iopc_depends_uniquify(i_deps);
}
