/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/
extension ic__tracer__array_t : libcommon.IopComplexTypeArray { }

extension ic__simple_hdr__array_t : libcommon.IopComplexTypeArray { }

extension ic__route__array_t : libcommon.IopClassArray { }

extension ic__routing_hdr__array_t : libcommon.IopComplexTypeArray { }

extension ic__hdr__array_t : libcommon.IopComplexTypeArray { }

extension ic__ic_priority__t : libcommon.IopEnum {
    public static let descriptor = ic__ic_priority__ep
    public static let min : Swift.Int32 = Swift.Int32(IC_PRIORITY_min)
    public static let max : Swift.Int32 = Swift.Int32(IC_PRIORITY_max)
    public static let count : Swift.Int32 = Swift.Int32(IC_PRIORITY_count)
}
extension ic__ic_priority__array_t : libcommon.IopSimpleArray { }
extension ic__ic_priority__opt_t : libcommon.IopOptional { }

public enum ic : libcommon.IopPackage {
    public typealias IcPriority = ic__ic_priority__t

    public final class Tracer : libcommon.IopStruct {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return ic__tracer__sp
        }

        public var `token` : Swift.UInt64
        public var `epoch` : Swift.UInt64

        public init(`token`: Swift.UInt64,
                    `epoch`: Swift.UInt64) {
            self.token = `token`
            self.epoch = `epoch`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: ic__tracer__t.self, capacity: 1).pointee
            self.token = data.token
            self.epoch = data.epoch
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: ic__tracer__t.self, capacity: 1)
            data.pointee.token = self.token
            data.pointee.epoch = self.epoch
        }
    }

    public final class SimpleHdr : libcommon.IopStruct {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return ic__simple_hdr__sp
        }

        public var `login` : Swift.String?
        public var `password` : Swift.String?
        public var `kind` : Swift.String?
        public var `payload` : Swift.Int32
        public var `host` : Swift.String?
        public var `group` : Swift.String?
        public var `source` : Swift.String?

        public init(`login`: Swift.String? = nil,
                    `password`: Swift.String? = nil,
                    `kind`: Swift.String? = nil,
                    `payload`: Swift.Int32 = -1,
                    `host`: Swift.String? = nil,
                    `group`: Swift.String? = nil,
                    `source`: Swift.String? = nil) {
            self.login = `login`
            self.password = `password`
            self.kind = `kind`
            self.payload = `payload`
            self.host = `host`
            self.group = `group`
            self.source = `source`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: ic__simple_hdr__t.self, capacity: 1).pointee
             self.login = Swift.String(data.login)
             self.password = Swift.String(data.password)
             self.kind = Swift.String(data.kind)
            self.payload = data.payload
             self.host = Swift.String(data.host)
             self.group = Swift.String(data.group)
             self.source = Swift.String(data.source)
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: ic__simple_hdr__t.self, capacity: 1)
            if let login_val = self.login {
                data.pointee.login = login_val.duplicated(on: allocator)
            }
            if let password_val = self.password {
                data.pointee.password = password_val.duplicated(on: allocator)
            }
            if let kind_val = self.kind {
                data.pointee.kind = kind_val.duplicated(on: allocator)
            }
            data.pointee.payload = self.payload
            if let host_val = self.host {
                data.pointee.host = host_val.duplicated(on: allocator)
            }
            if let group_val = self.group {
                data.pointee.group = group_val.duplicated(on: allocator)
            }
            if let source_val = self.source {
                data.pointee.source = source_val.duplicated(on: allocator)
            }
        }
    }

    open class Route : libcommon.IopClass {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return ic__route__sp
        }

        open override class var isAbstract : Swift.Bool {
            return true
        }


        public override init() {
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
        }
    }

    public final class RoutingHdr : libcommon.IopStruct {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return ic__routing_hdr__sp
        }

        public var `route` : ic_package.Route
        public var `ttl` : Swift.Int32
        public var `priority` : ic_package.IcPriority
        public var `tracer` : ic_package.Tracer?
        public var `originalHdr` : ic_package.Hdr?

        public init(`route`: ic_package.Route,
                    `ttl`: Swift.Int32,
                    `priority`: ic_package.IcPriority = ic_package.IcPriority(rawValue: 1),
                    `tracer`: ic_package.Tracer? = nil,
                    `originalHdr`: ic_package.Hdr? = nil) {
            self.route = `route`
            self.ttl = `ttl`
            self.priority = `priority`
            self.tracer = `tracer`
            self.originalHdr = `originalHdr`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: ic__routing_hdr__t.self, capacity: 1).pointee
            self.route = try ic_package.Route.make(Swift.UnsafeRawPointer(data.route)!)
            self.ttl = data.ttl
            self.priority = data.priority

            self.tracer = try ic_package.Tracer(data.tracer)

            self.originalHdr = try ic_package.Hdr(data.original_hdr)
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: ic__routing_hdr__t.self, capacity: 1)
            data.pointee.route = self.route.duplicated(on: allocator).bindMemory(to: ic__route__t.self, capacity: 1)
            data.pointee.ttl = self.ttl
            data.pointee.priority = self.priority
            if let tracer_val = self.tracer {
                data.pointee.tracer = tracer_val.duplicated(on: allocator).bindMemory(to: ic__tracer__t.self, capacity: 1)
            }
            if let originalHdr_val = self.originalHdr {
                data.pointee.original_hdr = originalHdr_val.duplicated(on: allocator).bindMemory(to: ic__hdr__t.self, capacity: 1)
            }
        }
    }

    public indirect enum Hdr : libcommon.IopUnion {
        public static let descriptor =  ic__hdr__sp

        case `simple`(ic_package.SimpleHdr)
        case `routing`(ic_package.RoutingHdr)

        public init(_ c: Swift.UnsafeRawPointer) throws {
            let (tag, data) = type(of: self)._explode(c)
            switch tag {
              case 1:
                self = .simple(try ic_package.SimpleHdr(data))
              case 2:
                self = .routing(try ic_package.RoutingHdr(data))
              default:
                throw libcommon.IopImportError.invalidUnionTag(type(of: self).descriptor, tag)
            }
        }

        public func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let (tag, data) = type(of: self)._explode(c)
            switch self {
              case .simple(let simple_val):
                tag[0] = 1
                simple_val.fill(data, on: allocator)
              case .routing(let routing_val):
                tag[0] = 2
                routing_val.fill(data, on: allocator)
            }
        }
    }

    public enum interfaces {
    }
    public enum modules {
    }
    public static let classes : [libcommon.IopClass.Type] = [ Route.self ]
}

public typealias ic_package = ic
