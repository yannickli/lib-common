=== Standards conformance ===

The platform globally follows the REST principles and conforms to 'HTTP/1.1'
as defined in <<HTTP_1.1>> and to JSONfootnote:[http://www.json.org/[]] format.

==== HTTP/1.1 conformance ====

include::http-conformance.adoc[]

==== JSON conformance ====

include::json-conformance.adoc[]

=== Interfaces constraints ===

include::iop-interfaces-constraints.adoc[]

=== Intersec descriptive language ===

JSON objects are weakly typed object, however most of the platform layers
uses a strong typing. So all the methods and objects rely on a strict structure
definition. This last is expressed with an in-house descriptive language which
is syntactically a D-like.

==== Simple types ====

Basic types will be mapped as follows:
[options="header"]
|===
| Intersec notation | JSON
| +byte+            | +number+
| +ubyte+           | +number+
| +short+           | +number+
| +ushort+          | +number+
| +int+             | +number+
| +uint+            | +number+
| +long+            | +number+ if less than 2^53^, +string+ otherwise
| +ulong+           | +number+ if less than 2^53^, +string+ otherwise
| +bool+            | +boolean+
| +double+          | +number+
| +string+          | +string+
| +xml+             | +string+
|===

In addition to those, some of the objects use the 'enumeration' notion.
An enumeration defines a set of allowed values. Each value has an integer
identifier and a textual one.
Enumerations are defined with the keyword 'enum'.
This notion have no equivalent in JSON, thus enumerations are commonly
translated to +string+ in JSON, but both identifier types (numeric and textual)
are handled.

==== Complex type ====

JSON is built on a structure commonly called +object+ which is a collection
of key/value pairs. The most direct expression in Intersec language is
structure.

Classes, defined with the keyword 'class', have no equivalent in JSON.
It's a structure with some inheritance tree. The instance type is defined
in the object with the specific key '_class'.

Unions, defined with the keyword 'union', have also no equivalent in JSON.
However an union is simply a structure with many members, but only one member
can be set at a given time.

For example:

[style="asciidoc",cols="1,2",options="header"]
|===
| Description | Valid JSON object
|
[source,d]
----
struct MyType {
    int    i;
    string s;
};
----
|
[source,python]
----
{
    "i": 3,
    "s": "myString"
}
----

|
[source,d]
----
class Father : 0 {
    int    i;
    string s;
};

class Child : 1 : Father {
    double d;
};
----
|
[source,python]
----
/* A father object */
{
    "_class": "Father",
    "i": 3,
    "s": "myString"
}
/* A child object */
{
    "_class": "Child",
    "i": 3,
    "s": "myString",
    "d": 42.0
}
----

|
[source,d]
----
union OtherType {
    MyType t;
    ulong  ul;
};
----
|
[source,python]
----
/* The first member is set. */
{
    "t": { ... }
}
/* The second member is set. */
{
    "ul": 3
}
----

|
[source,d]
----
enum MyEnum {
    VALUE_1,
    VALUE_2,
    VALUE_3,
};

struct MyType {
    MyEnum e;
};
----
|
[source,python]
----
{
    "e": "VALUE_1"
}
----
|===

==== Additional features ====

Types may use optional and repeated fields. The Intersec notation actually
supports four forms for fields:

-   Mandatory fields (default);
-   Optional fields: the type has a postfix question mark ``?'';
-   Repeated fields: the type has a postfix pair of brackets,
    like the standard C/Java array notation ``[]'';
-   Optional fields with default values: the field name is postfixed with
    the default value the element takes if not specified.
