/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/
#ifndef linux
#  warning "core.iop assumed linux alignments"
#endif
#ifndef __x86_64__
#  warning "core.iop assumed x86_64 alignments"
#endif

#include "core.iop.h"

/* Enum core.LogLevel {{{ */

static int const core__log_level__values[] = {
 -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8,
};
static int const iop__ranges__1[] = {
    0, -2,
    11,
};
static const lstr_t core__log_level__names[] = {
    LSTR_IMMED("DEFAULT"),
    LSTR_IMMED("INHERITS"),
    LSTR_IMMED("EMERG"),
    LSTR_IMMED("ALERT"),
    LSTR_IMMED("CRIT"),
    LSTR_IMMED("ERR"),
    LSTR_IMMED("WARNING"),
    LSTR_IMMED("NOTICE"),
    LSTR_IMMED("INFO"),
    LSTR_IMMED("DEBUG"),
    LSTR_IMMED("TRACE"),
};
static const iop_help_t core__log_level__default__v_help = {
    .brief = LSTR_IMMED("use default configuration"),
};
static const iop_enum_value_attr_t core__log_level__default__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__default__v_help } },
    },
};
static const iop_help_t core__log_level__inherits__v_help = {
    .brief = LSTR_IMMED("inherits the level of the parent logger"),
};
static const iop_enum_value_attr_t core__log_level__inherits__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__inherits__v_help } },
    },
};
static const iop_help_t core__log_level__emerg__v_help = {
    .brief = LSTR_IMMED("system is unusable"),
};
static const iop_enum_value_attr_t core__log_level__emerg__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__emerg__v_help } },
    },
};
static const iop_help_t core__log_level__alert__v_help = {
    .brief = LSTR_IMMED("action must be taken immediately"),
};
static const iop_enum_value_attr_t core__log_level__alert__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__alert__v_help } },
    },
};
static const iop_help_t core__log_level__crit__v_help = {
    .brief = LSTR_IMMED("critical conditions"),
};
static const iop_enum_value_attr_t core__log_level__crit__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__crit__v_help } },
    },
};
static const iop_help_t core__log_level__err__v_help = {
    .brief = LSTR_IMMED("error conditions"),
};
static const iop_enum_value_attr_t core__log_level__err__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__err__v_help } },
    },
};
static const iop_help_t core__log_level__warning__v_help = {
    .brief = LSTR_IMMED("warning conditions"),
};
static const iop_enum_value_attr_t core__log_level__warning__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__warning__v_help } },
    },
};
static const iop_help_t core__log_level__notice__v_help = {
    .brief = LSTR_IMMED("normal but significant condition"),
};
static const iop_enum_value_attr_t core__log_level__notice__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__notice__v_help } },
    },
};
static const iop_help_t core__log_level__info__v_help = {
    .brief = LSTR_IMMED("informational"),
};
static const iop_enum_value_attr_t core__log_level__info__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__info__v_help } },
    },
};
static const iop_help_t core__log_level__debug__v_help = {
    .brief = LSTR_IMMED("debug-level messages"),
};
static const iop_enum_value_attr_t core__log_level__debug__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__debug__v_help } },
    },
};
static const iop_help_t core__log_level__trace__v_help = {
    .brief = LSTR_IMMED("trace-level messages"),
};
static const iop_enum_value_attr_t core__log_level__trace__v_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_value_attr_arg_t[]){ { .v.p = &core__log_level__trace__v_help } },
    },
};
static const iop_enum_value_attrs_t core__log_level__e_desc_values_attrs[] = {
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__default__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__inherits__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__emerg__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__alert__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__crit__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__err__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__warning__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__notice__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__info__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__debug__v_attrs,
    },
    {
        .flags     = 32,
        .attrs_len = 1,
        .attrs     = core__log_level__trace__v_attrs,
    },
};
static const iop_help_t core__log_level__e_help = {
    .brief = LSTR_IMMED("List of supported log levels."),
};
static const iop_enum_attr_t core__log_level__e_attrs[] = {
    {
        .type = 5,
        .args = (iop_enum_attr_arg_t[]){ { .v.p = &core__log_level__e_help } },
    },
};
static const iop_enum_attrs_t core__log_level__e_desc_attrs = {
    .flags     = 32,
    .attrs_len = 1,
    .attrs     = core__log_level__e_attrs,
};
iop_enum_t const core__log_level__e = {
    .name         = LSTR_IMMED("LogLevel"),
    .fullname     = LSTR_IMMED("core.LogLevel"),
    .names        = core__log_level__names,
    .values       = core__log_level__values,
    .ranges       = iop__ranges__1,
    .ranges_len   = countof(iop__ranges__1) / 2,
    .enum_len     = 11,
    .flags        = 1,
    .en_attrs     = &core__log_level__e_desc_attrs,
    .values_attrs = core__log_level__e_desc_values_attrs,
};
iop_enum_t const * const core__log_level__ep = &core__log_level__e;

/* }}} */
/* Enum core.IopHttpMethod {{{ */

static int const core__iop_http_method__values[] = {
 0, 1, 2, 3, 4, 5, 6, 7,
};
static int const iop__ranges__2[] = {
    0, 0,
    8,
};
static const lstr_t core__iop_http_method__names[] = {
    LSTR_IMMED("OPTIONS"),
    LSTR_IMMED("GET"),
    LSTR_IMMED("HEAD"),
    LSTR_IMMED("POST"),
    LSTR_IMMED("PUT"),
    LSTR_IMMED("DELETE"),
    LSTR_IMMED("TRACE"),
    LSTR_IMMED("CONNECT"),
};
iop_enum_t const core__iop_http_method__e = {
    .name         = LSTR_IMMED("IopHttpMethod"),
    .fullname     = LSTR_IMMED("core.IopHttpMethod"),
    .names        = core__iop_http_method__names,
    .values       = core__iop_http_method__values,
    .ranges       = iop__ranges__2,
    .ranges_len   = countof(iop__ranges__2) / 2,
    .enum_len     = 8,
};
iop_enum_t const * const core__iop_http_method__ep = &core__iop_http_method__e;

/* }}} */
/* Structure core.LoggerConfiguration {{{ */

static const iop_help_t core__logger_configuration__full_name__f_help = {
    .brief = LSTR_IMMED("Name of the logger to configure."),
};
static iop_field_attr_t const core__logger_configuration__full_name__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__logger_configuration__full_name__f_help } },
    },
};
static const iop_help_t core__logger_configuration__level__f_help = {
    .brief = LSTR_IMMED("Logging level."),
    .details = LSTR_IMMED("This will be the logging level for this logger and all inheriting\012loggers that were not explicitly configured."),
};
static iop_field_attr_t const core__logger_configuration__level__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__logger_configuration__level__f_help } },
    },
};
static const iop_help_t core__logger_configuration__force_all__f_help = {
    .brief = LSTR_IMMED("Force the use of logging level for child loggers."),
    .details = LSTR_IMMED("If this flag is set, the level of that logger is propagated to all\012child loggers that were not explicitly configured, even those that\012were not supposed to inherit from that level."),
};
static iop_field_attr_t const core__logger_configuration__force_all__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__logger_configuration__force_all__f_help } },
    },
};
static const iop_help_t core__logger_configuration__is_silent__f_help = {
    .brief = LSTR_IMMED("If true, log handler is called, but default one does nothing."),
};
static iop_field_attr_t const core__logger_configuration__is_silent__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__logger_configuration__is_silent__f_help } },
    },
};
static iop_field_attrs_t const core__logger_configuration__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__logger_configuration__full_name__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__logger_configuration__level__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__logger_configuration__force_all__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__logger_configuration__is_silent__attrs,
    },
};
static iop_field_t const core__logger_configuration__desc_fields[] = {
    {
        .name      = LSTR_IMMED("fullName"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__logger_configuration__t, full_name),
        .size      = fieldsizeof(core__logger_configuration__t, full_name),
    },
    {
        .name      = LSTR_IMMED("level"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_ENUM,
        .data_offs = offsetof(core__logger_configuration__t, level),
        .size      = fieldsizeof(core__logger_configuration__t, level),
        .u1        = { .en_desc = &core__log_level__e },
    },
    {
        .name      = LSTR_IMMED("forceAll"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__logger_configuration__t, force_all),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__logger_configuration__t, force_all),
    },
    {
        .name      = LSTR_IMMED("isSilent"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__logger_configuration__t, is_silent),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__logger_configuration__t, is_silent),
    },
};
static int const iop__ranges__3[] = {
    0, 1,
    4,
};
static const iop_help_t core__logger_configuration__s_help = {
    .brief = LSTR_IMMED("Configuration of a specific logger."),
};
static const iop_struct_attr_t core__logger_configuration__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__logger_configuration__s_help } },
    },
};
static const iop_struct_attrs_t core__logger_configuration__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__logger_configuration__s_attrs,
};
const iop_struct_t core__logger_configuration__s = {
    .fullname   = LSTR_IMMED("core.LoggerConfiguration"),
    .fields     = core__logger_configuration__desc_fields,
    .ranges     = iop__ranges__3,
    .ranges_len = countof(iop__ranges__3) / 2,
    .fields_len = countof(core__logger_configuration__desc_fields),
    .size       = sizeof(core__logger_configuration__t),
    .flags      = 1,
    .st_attrs   = &core__logger_configuration__s_desc_attrs,
    .fields_attrs = core__logger_configuration__desc_fields_attrs,
};
iop_struct_t const * const core__logger_configuration__sp = &core__logger_configuration__s;

/* }}} */
/* Structure core.LogConfiguration {{{ */

static const iop_help_t core__log_configuration__root_level__f_help = {
    .brief = LSTR_IMMED("Root logging level."),
    .details = LSTR_IMMED("This will be the logging level for all the logger inherits from\012root logging level and that were not configured to another value\012separately.\012\012The default configuration is to enable TRACE in development builds,\012and to enable only DEBUG in release builds."),
};
static iop_field_attr_t const core__log_configuration__root_level__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_configuration__root_level__f_help } },
    },
};
static const iop_help_t core__log_configuration__force_all__f_help = {
    .brief = LSTR_IMMED("Force the use of the root level."),
    .details = LSTR_IMMED("If this flag is set, the root level is propagated to all logger\012that were not explicitly configured, even those that were not\012supposed to inherit from the root level."),
};
static iop_field_attr_t const core__log_configuration__force_all__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_configuration__force_all__f_help } },
    },
};
static const iop_help_t core__log_configuration__is_silent__f_help = {
    .brief = LSTR_IMMED("If true, log handler is called, but default one does nothing."),
};
static iop_field_attr_t const core__log_configuration__is_silent__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_configuration__is_silent__f_help } },
    },
};
static const iop_help_t core__log_configuration__specific__f_help = {
    .brief = LSTR_IMMED("Independent configuration of specific loggers."),
    .details = LSTR_IMMED("This can be used to perform a fine-grained configuration of the\012logging level of specific code modules."),
};
static iop_field_attr_t const core__log_configuration__specific__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_configuration__specific__f_help } },
    },
};
static iop_field_attrs_t const core__log_configuration__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_configuration__root_level__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_configuration__force_all__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_configuration__is_silent__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_configuration__specific__attrs,
    },
};
static iop_field_t const core__log_configuration__desc_fields[] = {
    {
        .name      = LSTR_IMMED("rootLevel"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_ENUM,
        .data_offs = offsetof(core__log_configuration__t, root_level),
        .u0        = { .defval_enum = -2 },
        .size      = fieldsizeof(core__log_configuration__t, root_level),
        .u1        = { .en_desc = &core__log_level__e },
    },
    {
        .name      = LSTR_IMMED("forceAll"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__log_configuration__t, force_all),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__log_configuration__t, force_all),
    },
    {
        .name      = LSTR_IMMED("isSilent"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__log_configuration__t, is_silent),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__log_configuration__t, is_silent),
    },
    {
        .name      = LSTR_IMMED("specific"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_REPEATED,
        .type      = IOP_T_STRUCT,
        .data_offs = offsetof(core__log_configuration__t, specific),
        .size      = sizeof(core__logger_configuration__t),
        .u1        = { .st_desc = &core__logger_configuration__s },
    },
};
static const iop_help_t core__log_configuration__s_help = {
    .brief = LSTR_IMMED("Configuration of the logging system."),
};
static const iop_struct_attr_t core__log_configuration__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__log_configuration__s_help } },
    },
};
static const iop_struct_attrs_t core__log_configuration__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__log_configuration__s_attrs,
};
const iop_struct_t core__log_configuration__s = {
    .fullname   = LSTR_IMMED("core.LogConfiguration"),
    .fields     = core__log_configuration__desc_fields,
    .ranges     = iop__ranges__3,
    .ranges_len = countof(iop__ranges__3) / 2,
    .fields_len = countof(core__log_configuration__desc_fields),
    .size       = sizeof(core__log_configuration__t),
    .flags      = 1,
    .st_attrs   = &core__log_configuration__s_desc_attrs,
    .fields_attrs = core__log_configuration__desc_fields_attrs,
};
iop_struct_t const * const core__log_configuration__sp = &core__log_configuration__s;

/* }}} */
/* Class core.LogFileConfiguration {{{ */

static const iop_help_t core__log_file_configuration__max_size__f_help = {
    .brief = LSTR_IMMED("Log file max size before rotation (in bytes)."),
};
static iop_field_attr_t const core__log_file_configuration__max_size__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_file_configuration__max_size__f_help } },
    },
};
static const iop_help_t core__log_file_configuration__max_time__f_help = {
    .brief = LSTR_IMMED("Log file max age before rotation (in seconds)."),
};
static iop_field_attr_t const core__log_file_configuration__max_time__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_file_configuration__max_time__f_help } },
    },
};
static const iop_help_t core__log_file_configuration__max_files__f_help = {
    .brief = LSTR_IMMED("Maximum number of log files."),
    .details = LSTR_IMMED("<= 0 means no limit."),
};
static iop_field_attr_t const core__log_file_configuration__max_files__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_file_configuration__max_files__f_help } },
    },
};
static const iop_help_t core__log_file_configuration__total_max_size__f_help = {
    .brief = LSTR_IMMED("Maximum total size of the log files (in bytes)."),
    .details = LSTR_IMMED("<= 0 means no limit."),
};
static iop_field_attr_t const core__log_file_configuration__total_max_size__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_file_configuration__total_max_size__f_help } },
    },
};
static const iop_help_t core__log_file_configuration__compress__f_help = {
    .brief = LSTR_IMMED("Activate log file compression."),
};
static iop_field_attr_t const core__log_file_configuration__compress__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__log_file_configuration__compress__f_help } },
    },
};
static iop_field_attrs_t const core__log_file_configuration__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_file_configuration__max_size__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_file_configuration__max_time__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_file_configuration__max_files__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_file_configuration__total_max_size__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__log_file_configuration__compress__attrs,
    },
};
static iop_field_t const core__log_file_configuration__desc_fields[] = {
    {
        .name      = LSTR_IMMED("maxSize"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_I32,
        .data_offs = offsetof(core__log_file_configuration__t, max_size),
        .u1        = { .defval_u64 = 0x20000000 },
        .size      = fieldsizeof(core__log_file_configuration__t, max_size),
    },
    {
        .name      = LSTR_IMMED("maxTime"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U64,
        .data_offs = offsetof(core__log_file_configuration__t, max_time),
        .u1        = { .defval_u64 = 0x15180 },
        .size      = fieldsizeof(core__log_file_configuration__t, max_time),
    },
    {
        .name      = LSTR_IMMED("maxFiles"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_I32,
        .data_offs = offsetof(core__log_file_configuration__t, max_files),
        .u1        = { .defval_u64 = 0x0 },
        .size      = fieldsizeof(core__log_file_configuration__t, max_files),
    },
    {
        .name      = LSTR_IMMED("totalMaxSize"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_I64,
        .data_offs = offsetof(core__log_file_configuration__t, total_max_size),
        .u1        = { .defval_u64 = 0x40000000 },
        .size      = fieldsizeof(core__log_file_configuration__t, total_max_size),
    },
    {
        .name      = LSTR_IMMED("compress"),
        .tag       = 5,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__log_file_configuration__t, compress),
        .u1        = { .defval_u64 = true },
        .size      = fieldsizeof(core__log_file_configuration__t, compress),
    },
};
static int const iop__ranges__4[] = {
    0, 1,
    5,
};
static const iop_help_t core__log_file_configuration__s_help = {
    .brief = LSTR_IMMED("Configuration of a log_file_t."),
    .details = LSTR_IMMED("This class defines how a log file is opened, rotates, expires and is\012compressed."),
};
static const iop_struct_attr_t core__log_file_configuration__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__log_file_configuration__s_help } },
    },
};
static const iop_struct_attrs_t core__log_file_configuration__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__log_file_configuration__s_attrs,
};
static const iop_class_attrs_t core__log_file_configuration__class_s = {
    .class_id          = 0,
};
const iop_struct_t core__log_file_configuration__s = {
    .fullname   = LSTR_IMMED("core.LogFileConfiguration"),
    .fields     = core__log_file_configuration__desc_fields,
    .ranges     = iop__ranges__4,
    .ranges_len = countof(iop__ranges__4) / 2,
    .fields_len = countof(core__log_file_configuration__desc_fields),
    .size       = sizeof(core__log_file_configuration__t),
    .flags      = 13,
    .is_union   = false,
    .st_attrs   = &core__log_file_configuration__s_desc_attrs,
    .fields_attrs = core__log_file_configuration__desc_fields_attrs,
    {
        .class_attrs  = &core__log_file_configuration__class_s,
    }
};
iop_struct_t const * const core__log_file_configuration__sp = &core__log_file_configuration__s;

/* }}} */
/* Class core.LicenceModule {{{ */

static const iop_help_t core__licence_module__expiration_date__f_help = {
    .brief = LSTR_IMMED("Expiration date of the licence module."),
    .details = LSTR_IMMED("After that date the module will stop."),
};
static int core__licence_module__expiration_date__check(const void *ptr, int n)
{
    for (int j = 0; j < n; j++) {
        lstr_t    val = IOP_FIELD(lstr_t   , ptr, j);

        if (val.len != 11) {
            iop_set_err("violation of constraint %s (%d) on field %s: length=%d",
                        "length", 11, "expirationDate", val.len);
            return -1;
        }
        for (int c = 0; c < val.len; c++) {
            switch (val.s[c]) {
                case 'a' ... 'z':
                case 'A' ... 'Z':
                case '0' ... '9':
                case '-':
                    break;
                default:
                    iop_set_err("violation of constraint %s (%s) on field %s: %*pM",
                                "pattern", "[a-zA-Z0-9\\-]*", "expirationDate", LSTR_FMT_ARG(val));
                    return -1;
            }
        }
    }
    return 0;
}
static iop_field_attr_t const core__licence_module__expiration_date__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence_module__expiration_date__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Expiration date\",\"fr\":\"Date d'expiration\"}") } },
    },
    {
        .type = 7,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 8,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 9,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("[a-zA-Z0-9\\-]*") } },
    },
};
static const iop_help_t core__licence_module__expiration_warning_delay__f_help = {
    .brief = LSTR_IMMED("Delay to emit warning before expiration."),
    .details = LSTR_IMMED("The module will start emitting warnings from \134ref expirationDate - \134ref expirationWarningDelay. Value is in seconds."),
};
static iop_field_attr_t const core__licence_module__expiration_warning_delay__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence_module__expiration_warning_delay__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Expiration warning delay\",\"fr\":\"Délai d'avertissement d'expiration\"}") } },
    },
};
static iop_field_attrs_t const core__licence_module__desc_fields_attrs[] = {
    {
        .flags             = 295808,
        .attrs_len         = 5,
        .check_constraints = &core__licence_module__expiration_date__check,
        .attrs             = core__licence_module__expiration_date__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence_module__expiration_warning_delay__attrs,
    },
};
static iop_field_t const core__licence_module__desc_fields[] = {
    {
        .name      = LSTR_IMMED("expirationDate"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_OPTIONAL,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__licence_module__t, expiration_date),
        .flags     = 1,
        .size      = fieldsizeof(core__licence_module__t, expiration_date),
    },
    {
        .name      = LSTR_IMMED("expirationWarningDelay"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__licence_module__t, expiration_warning_delay),
        .u1        = { .defval_u64 = 0x13c680 },
        .size      = fieldsizeof(core__licence_module__t, expiration_warning_delay),
    },
};
static int const iop__ranges__5[] = {
    0, 1,
    2,
};
static const iop_help_t core__licence_module__s_help = {
    .brief = LSTR_IMMED("Licence module."),
    .details = LSTR_IMMED("This class provides the base for a licence module format."),
};
static const iop_struct_attr_t core__licence_module__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__licence_module__s_help } },
    },
};
static const iop_struct_attrs_t core__licence_module__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__licence_module__s_attrs,
};
static const iop_class_attrs_t core__licence_module__class_s = {
    .is_abstract       = true,
    .class_id          = 0,
};
const iop_struct_t core__licence_module__s = {
    .fullname   = LSTR_IMMED("core.LicenceModule"),
    .fields     = core__licence_module__desc_fields,
    .ranges     = iop__ranges__5,
    .ranges_len = countof(iop__ranges__5) / 2,
    .fields_len = countof(core__licence_module__desc_fields),
    .size       = sizeof(core__licence_module__t),
    .flags      = 15,
    .is_union   = false,
    .st_attrs   = &core__licence_module__s_desc_attrs,
    .fields_attrs = core__licence_module__desc_fields_attrs,
    {
        .class_attrs  = &core__licence_module__class_s,
    }
};
iop_struct_t const * const core__licence_module__sp = &core__licence_module__s;

/* }}} */
/* Class core.Licence {{{ */

static const iop_help_t core__licence__expiration_date__f_help = {
    .brief = LSTR_IMMED("Expiration date of the licence."),
    .details = LSTR_IMMED("After that date the product could be used until \134ref expirationHardDate\012but it will emit errors."),
};
static int core__licence__expiration_date__check(const void *ptr, int n)
{
    for (int j = 0; j < n; j++) {
        lstr_t    val = IOP_FIELD(lstr_t   , ptr, j);

        if (val.len != 11) {
            iop_set_err("violation of constraint %s (%d) on field %s: length=%d",
                        "length", 11, "expirationDate", val.len);
            return -1;
        }
        for (int c = 0; c < val.len; c++) {
            switch (val.s[c]) {
                case 'a' ... 'z':
                case 'A' ... 'Z':
                case '0' ... '9':
                case '-':
                    break;
                default:
                    iop_set_err("violation of constraint %s (%s) on field %s: %*pM",
                                "pattern", "[a-zA-Z0-9\\-]*", "expirationDate", LSTR_FMT_ARG(val));
                    return -1;
            }
        }
    }
    return 0;
}
static iop_field_attr_t const core__licence__expiration_date__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__expiration_date__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Expiration date\",\"fr\":\"Date d'expiration\"}") } },
    },
    {
        .type = 7,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 8,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 9,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("[a-zA-Z0-9\\-]*") } },
    },
};
static const iop_help_t core__licence__expiration_hard_date__f_help = {
    .brief = LSTR_IMMED("Real expiration date of the licence."),
    .details = LSTR_IMMED("After that date the product will be disabled.\012If not provided, the default value is \134ref expirationDate."),
};
static int core__licence__expiration_hard_date__check(const void *ptr, int n)
{
    for (int j = 0; j < n; j++) {
        lstr_t    val = IOP_FIELD(lstr_t   , ptr, j);

        if (val.len != 11) {
            iop_set_err("violation of constraint %s (%d) on field %s: length=%d",
                        "length", 11, "expirationHardDate", val.len);
            return -1;
        }
        for (int c = 0; c < val.len; c++) {
            switch (val.s[c]) {
                case 'a' ... 'z':
                case 'A' ... 'Z':
                case '0' ... '9':
                case '-':
                    break;
                default:
                    iop_set_err("violation of constraint %s (%s) on field %s: %*pM",
                                "pattern", "[a-zA-Z0-9\\-]*", "expirationHardDate", LSTR_FMT_ARG(val));
                    return -1;
            }
        }
    }
    return 0;
}
static iop_field_attr_t const core__licence__expiration_hard_date__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__expiration_hard_date__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Real expiration date\",\"fr\":\"Date réelle d'expiration\"}") } },
    },
    {
        .type = 7,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 8,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 9,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("[a-zA-Z0-9\\-]*") } },
    },
};
static const iop_help_t core__licence__expiration_warning_delay__f_help = {
    .brief = LSTR_IMMED("Delay to emit warnings before expiration."),
    .details = LSTR_IMMED("The product will start emitting warnings from \134ref expirationDate - \134ref expirationWarningDelay. Value is in seconds."),
};
static iop_field_attr_t const core__licence__expiration_warning_delay__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__expiration_warning_delay__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Expiration warning delay\",\"fr\":\"Délai d'avertissement d'expiration\"}") } },
    },
};
static const iop_help_t core__licence__registered_to__f_help = {
    .brief = LSTR_IMMED("Licencee identification."),
};
static iop_field_attr_t const core__licence__registered_to__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__registered_to__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Registered to\",\"fr\":\"Attribuée à\"}") } },
    },
};
static const iop_help_t core__licence__version__f_help = {
    .brief = LSTR_IMMED("Version of the product licenced."),
};
static iop_field_attr_t const core__licence__version__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__version__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Version\",\"fr\":\"Version\"}") } },
    },
};
static const iop_help_t core__licence__production_use__f_help = {
    .brief = LSTR_IMMED("If true, the licencee is allowed to use the product for\012production."),
};
static iop_field_attr_t const core__licence__production_use__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__production_use__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Production use\",\"fr\":\"Usage en production\"}") } },
    },
};
static const iop_help_t core__licence__cpu_signatures__f_help = {
    .brief = LSTR_IMMED("Hardware limitation: CPU."),
};
static iop_field_attr_t const core__licence__cpu_signatures__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__cpu_signatures__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"CPU signatures\",\"fr\":\"Signatures CPU\"}") } },
    },
};
static const iop_help_t core__licence__mac_addresses__f_help = {
    .brief = LSTR_IMMED("Hardware limitation: MAC Address."),
};
static iop_field_attr_t const core__licence__mac_addresses__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__mac_addresses__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"MAC addresses\",\"fr\":\"Addresses MAC\"}") } },
    },
};
static const iop_help_t core__licence__modules__f_help = {
    .brief = LSTR_IMMED("Array containing a licence for each module."),
};
static iop_field_attr_t const core__licence__modules__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__modules__f_help } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Modules\",\"fr\":\"Modules\"}") } },
    },
};
static const iop_help_t core__licence__signature_ts__f_help = {
    .brief = LSTR_IMMED("Date at which the licence was signed."),
};
static iop_field_attr_t const core__licence__signature_ts__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__signature_ts__f_help } },
    },
    {
        .type = 13,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("iopSign:signatureTs") }, { .v.i64 = 1UL } },
    },
    {
        .type = 15,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("licence:label") }, {.v.s = LSTR_IMMED("{\"en\":\"Signature date\",\"fr\":\"Date de signature\"}") } },
    },
};
static const iop_help_t core__licence__show_details__f_help = {
    .brief = LSTR_IMMED("Show licence details on the web page."),
};
static iop_field_attr_t const core__licence__show_details__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__licence__show_details__f_help } },
    },
};
static iop_field_attrs_t const core__licence__desc_fields_attrs[] = {
    {
        .flags             = 295808,
        .attrs_len         = 5,
        .check_constraints = &core__licence__expiration_date__check,
        .attrs             = core__licence__expiration_date__attrs,
    },
    {
        .flags             = 295808,
        .attrs_len         = 5,
        .check_constraints = &core__licence__expiration_hard_date__check,
        .attrs             = core__licence__expiration_hard_date__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence__expiration_warning_delay__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence__registered_to__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence__version__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence__production_use__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence__cpu_signatures__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence__mac_addresses__attrs,
    },
    {
        .flags             = 294912,
        .attrs_len         = 2,
        .attrs             = core__licence__modules__attrs,
    },
    {
        .flags             = 303104,
        .attrs_len         = 3,
        .attrs             = core__licence__signature_ts__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__licence__show_details__attrs,
    },
};
static iop_field_t const core__licence__desc_fields[] = {
    {
        .name      = LSTR_IMMED("expirationDate"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__licence__t, expiration_date),
        .flags     = 1,
        .u0        = { .defval_len  = 11 },
        .u1        = { .defval_data = "31-dec-2035" },
        .size      = fieldsizeof(core__licence__t, expiration_date),
    },
    {
        .name      = LSTR_IMMED("expirationHardDate"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_OPTIONAL,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__licence__t, expiration_hard_date),
        .flags     = 1,
        .size      = fieldsizeof(core__licence__t, expiration_hard_date),
    },
    {
        .name      = LSTR_IMMED("expirationWarningDelay"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__licence__t, expiration_warning_delay),
        .u1        = { .defval_u64 = 0x13c680 },
        .size      = fieldsizeof(core__licence__t, expiration_warning_delay),
    },
    {
        .name      = LSTR_IMMED("registeredTo"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__licence__t, registered_to),
        .size      = fieldsizeof(core__licence__t, registered_to),
    },
    {
        .name      = LSTR_IMMED("version"),
        .tag       = 5,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__licence__t, version),
        .size      = fieldsizeof(core__licence__t, version),
    },
    {
        .name      = LSTR_IMMED("productionUse"),
        .tag       = 6,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__licence__t, production_use),
        .size      = fieldsizeof(core__licence__t, production_use),
    },
    {
        .name      = LSTR_IMMED("cpuSignatures"),
        .tag       = 7,
        .tag_len   = 0,
        .repeat    = IOP_R_REPEATED,
        .type      = IOP_T_I64,
        .data_offs = offsetof(core__licence__t, cpu_signatures),
        .size      = fieldsizeof(core__licence__t, cpu_signatures.tab[0]),
    },
    {
        .name      = LSTR_IMMED("macAddresses"),
        .tag       = 8,
        .tag_len   = 0,
        .repeat    = IOP_R_REPEATED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__licence__t, mac_addresses),
        .size      = fieldsizeof(core__licence__t, mac_addresses.tab[0]),
    },
    {
        .name      = LSTR_IMMED("modules"),
        .tag       = 9,
        .tag_len   = 0,
        .repeat    = IOP_R_REPEATED,
        .type      = IOP_T_STRUCT,
        .data_offs = offsetof(core__licence__t, modules),
        .size      = sizeof(core__licence_module__t *),
        .u1        = { .st_desc = &core__licence_module__s },
    },
    {
        .name      = LSTR_IMMED("signatureTs"),
        .tag       = 10,
        .tag_len   = 0,
        .repeat    = IOP_R_OPTIONAL,
        .type      = IOP_T_I64,
        .data_offs = offsetof(core__licence__t, signature_ts),
        .size      = fieldsizeof(core__licence__t, signature_ts),
    },
    {
        .name      = LSTR_IMMED("showDetails"),
        .tag       = 11,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__licence__t, show_details),
        .u1        = { .defval_u64 = true },
        .size      = fieldsizeof(core__licence__t, show_details),
    },
};
static int const iop__ranges__6[] = {
    0, 1,
    11,
};
static const iop_help_t core__licence__s_help = {
    .brief = LSTR_IMMED("Product licence."),
    .details = LSTR_IMMED("This class provides the base for a product licence format."),
};
static const iop_struct_attr_t core__licence__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__licence__s_help } },
    },
};
static const iop_struct_attrs_t core__licence__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__licence__s_attrs,
};
static const iop_class_attrs_t core__licence__class_s = {
    .class_id          = 0,
};
const iop_struct_t core__licence__s = {
    .fullname   = LSTR_IMMED("core.Licence"),
    .fields     = core__licence__desc_fields,
    .ranges     = iop__ranges__6,
    .ranges_len = countof(iop__ranges__6) / 2,
    .fields_len = countof(core__licence__desc_fields),
    .size       = sizeof(core__licence__t),
    .flags      = 15,
    .is_union   = false,
    .st_attrs   = &core__licence__s_desc_attrs,
    .fields_attrs = core__licence__desc_fields_attrs,
    {
        .class_attrs  = &core__licence__class_s,
    }
};
iop_struct_t const * const core__licence__sp = &core__licence__s;

/* }}} */
/* Structure core.ActivationToken {{{ */

static const iop_help_t core__activation_token__expiration_date__f_help = {
    .brief = LSTR_IMMED("Product expiration: the licence will no longer be active after\012 this date."),
};
static int core__activation_token__expiration_date__check(const void *ptr, int n)
{
    for (int j = 0; j < n; j++) {
        lstr_t    val = IOP_FIELD(lstr_t   , ptr, j);

        if (val.len != 11) {
            iop_set_err("violation of constraint %s (%d) on field %s: length=%d",
                        "length", 11, "expirationDate", val.len);
            return -1;
        }
        for (int c = 0; c < val.len; c++) {
            switch (val.s[c]) {
                case 'a' ... 'z':
                case 'A' ... 'Z':
                case '0' ... '9':
                case '-':
                    break;
                default:
                    iop_set_err("violation of constraint %s (%s) on field %s: %*pM",
                                "pattern", "[a-zA-Z0-9\\-]*", "expirationDate", LSTR_FMT_ARG(val));
                    return -1;
            }
        }
    }
    return 0;
}
static iop_field_attr_t const core__activation_token__expiration_date__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__activation_token__expiration_date__f_help } },
    },
    {
        .type = 7,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 8,
        .args = (iop_field_attr_arg_t[]){ { .v.i64 = 11LL } },
    },
    {
        .type = 9,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("[a-zA-Z0-9\\-]*") } },
    },
};
static const iop_help_t core__activation_token__token__f_help = {
    .brief = LSTR_IMMED("The activation token."),
};
static iop_field_attr_t const core__activation_token__token__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__activation_token__token__f_help } },
    },
};
static iop_field_attrs_t const core__activation_token__desc_fields_attrs[] = {
    {
        .flags             = 263040,
        .attrs_len         = 4,
        .check_constraints = &core__activation_token__expiration_date__check,
        .attrs             = core__activation_token__expiration_date__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__activation_token__token__attrs,
    },
};
static iop_field_t const core__activation_token__desc_fields[] = {
    {
        .name      = LSTR_IMMED("expirationDate"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_OPTIONAL,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__activation_token__t, expiration_date),
        .flags     = 1,
        .size      = fieldsizeof(core__activation_token__t, expiration_date),
    },
    {
        .name      = LSTR_IMMED("token"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__activation_token__t, token),
        .size      = fieldsizeof(core__activation_token__t, token),
    },
};
static const iop_help_t core__activation_token__s_help = {
    .brief = LSTR_IMMED("Activation token."),
    .details = LSTR_IMMED("An activation token is a small string which allows the product to\012work for a short time (for example 30 days).\012\012The activation token has three constraints:\012  - it must specify an expiration date for the product,\012  - it must expire itself after some date (and can't be used anymore),\012  - it must depend on the licence."),
};
static const iop_struct_attr_t core__activation_token__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__activation_token__s_help } },
    },
};
static const iop_struct_attrs_t core__activation_token__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__activation_token__s_attrs,
};
const iop_struct_t core__activation_token__s = {
    .fullname   = LSTR_IMMED("core.ActivationToken"),
    .fields     = core__activation_token__desc_fields,
    .ranges     = iop__ranges__5,
    .ranges_len = countof(iop__ranges__5) / 2,
    .fields_len = countof(core__activation_token__desc_fields),
    .size       = sizeof(core__activation_token__t),
    .flags      = 3,
    .st_attrs   = &core__activation_token__s_desc_attrs,
    .fields_attrs = core__activation_token__desc_fields_attrs,
};
iop_struct_t const * const core__activation_token__sp = &core__activation_token__s;

/* }}} */
/* Structure core.SignedLicence {{{ */

static const iop_help_t core__signed_licence__licence__f_help = {
    .brief = LSTR_IMMED("The licence structure."),
};
static iop_field_attr_t const core__signed_licence__licence__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__signed_licence__licence__f_help } },
    },
};
static const iop_help_t core__signed_licence__signature__f_help = {
    .brief = LSTR_IMMED("The signature of the previously defined licence."),
};
static iop_field_attr_t const core__signed_licence__signature__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__signed_licence__signature__f_help } },
    },
};
static const iop_help_t core__signed_licence__activation_token__f_help = {
    .brief = LSTR_IMMED("The associated activation token"),
};
static iop_field_attr_t const core__signed_licence__activation_token__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__signed_licence__activation_token__f_help } },
    },
};
static const iop_help_t core__signed_licence__included_subfiles__f_help = {
    .brief = LSTR_IMMED("List of subfiles included by the ' \134include ' feature."),
};
static iop_field_attr_t const core__signed_licence__included_subfiles__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__signed_licence__included_subfiles__f_help } },
    },
};
static iop_field_attrs_t const core__signed_licence__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__signed_licence__licence__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__signed_licence__signature__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__signed_licence__activation_token__attrs,
    },
    {
        .flags             = 263168,
        .attrs_len         = 1,
        .attrs             = core__signed_licence__included_subfiles__attrs,
    },
};
static iop_field_t const core__signed_licence__desc_fields[] = {
    {
        .name      = LSTR_IMMED("licence"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRUCT,
        .data_offs = offsetof(core__signed_licence__t, licence),
        .size      = sizeof(core__licence__t *),
        .u1        = { .st_desc = &core__licence__s },
    },
    {
        .name      = LSTR_IMMED("signature"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__signed_licence__t, signature),
        .size      = fieldsizeof(core__signed_licence__t, signature),
    },
    {
        .name      = LSTR_IMMED("activationToken"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_OPTIONAL,
        .type      = IOP_T_STRUCT,
        .data_offs = offsetof(core__signed_licence__t, activation_token),
        .size      = sizeof(core__activation_token__t),
        .u1        = { .st_desc = &core__activation_token__s },
    },
    {
        .name      = LSTR_IMMED("includedSubfiles"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_REPEATED,
        .type      = IOP_T_STRUCT,
        .data_offs = offsetof(core__signed_licence__t, included_subfiles),
        .size      = sizeof(core__iop_json_subfile__t),
        .u1        = { .st_desc = &core__iop_json_subfile__s },
    },
};
static const iop_help_t core__signed_licence__s_help = {
    .brief = LSTR_IMMED("Signed licence."),
};
static const iop_struct_attr_t core__signed_licence__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__signed_licence__s_help } },
    },
};
static const iop_struct_attrs_t core__signed_licence__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__signed_licence__s_attrs,
};
const iop_struct_t core__signed_licence__s = {
    .fullname   = LSTR_IMMED("core.SignedLicence"),
    .fields     = core__signed_licence__desc_fields,
    .ranges     = iop__ranges__3,
    .ranges_len = countof(iop__ranges__3) / 2,
    .fields_len = countof(core__signed_licence__desc_fields),
    .size       = sizeof(core__signed_licence__t),
    .flags      = 3,
    .st_attrs   = &core__signed_licence__s_desc_attrs,
    .fields_attrs = core__signed_licence__desc_fields_attrs,
};
iop_struct_t const * const core__signed_licence__sp = &core__signed_licence__s;

/* }}} */
/* Structure core.TlsCertAndKey {{{ */

static const iop_help_t core__tls_cert_and_key__cert__f_help = {
    .brief = LSTR_IMMED("Contents of a certificate file."),
};
static iop_field_attr_t const core__tls_cert_and_key__cert__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__tls_cert_and_key__cert__f_help } },
    },
};
static const iop_help_t core__tls_cert_and_key__key__f_help = {
    .brief = LSTR_IMMED("Contents of a private key file."),
};
static iop_field_attr_t const core__tls_cert_and_key__key__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__tls_cert_and_key__key__f_help } },
    },
};
static iop_field_attrs_t const core__tls_cert_and_key__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__tls_cert_and_key__cert__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__tls_cert_and_key__key__attrs,
    },
};
static iop_field_t const core__tls_cert_and_key__desc_fields[] = {
    {
        .name      = LSTR_IMMED("cert"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_DATA,
        .data_offs = offsetof(core__tls_cert_and_key__t, cert),
        .size      = fieldsizeof(core__tls_cert_and_key__t, cert),
    },
    {
        .name      = LSTR_IMMED("key"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_DATA,
        .data_offs = offsetof(core__tls_cert_and_key__t, key),
        .size      = fieldsizeof(core__tls_cert_and_key__t, key),
    },
};
static const iop_help_t core__tls_cert_and_key__s_help = {
    .brief = LSTR_IMMED("A certificate and its private key for TLS."),
    .details = LSTR_IMMED("Such files can be generated with the following command:\012\012  $ openssl req -newkey rsa:4096 -nodes -sha512 -x509 -days 3650\012                -nodes -out cert.pem -keyout priv-key.pem"),
};
static const iop_struct_attr_t core__tls_cert_and_key__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__tls_cert_and_key__s_help } },
    },
};
static const iop_struct_attrs_t core__tls_cert_and_key__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__tls_cert_and_key__s_attrs,
};
const iop_struct_t core__tls_cert_and_key__s = {
    .fullname   = LSTR_IMMED("core.TlsCertAndKey"),
    .fields     = core__tls_cert_and_key__desc_fields,
    .ranges     = iop__ranges__5,
    .ranges_len = countof(iop__ranges__5) / 2,
    .fields_len = countof(core__tls_cert_and_key__desc_fields),
    .size       = sizeof(core__tls_cert_and_key__t),
    .flags      = 1,
    .st_attrs   = &core__tls_cert_and_key__s_desc_attrs,
    .fields_attrs = core__tls_cert_and_key__desc_fields_attrs,
};
iop_struct_t const * const core__tls_cert_and_key__sp = &core__tls_cert_and_key__s;

/* }}} */
/* Union core.TlsCfg {{{ */

static const iop_help_t core__tls_cfg__keyname__f_help = {
    .brief = LSTR_IMMED("A keyname refering a key from the platform keychain."),
};
static iop_field_attr_t const core__tls_cfg__keyname__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__tls_cfg__keyname__f_help } },
    },
};
static const iop_help_t core__tls_cfg__data__f_help = {
    .brief = LSTR_IMMED("The certificate and key of the server."),
};
static iop_field_attr_t const core__tls_cfg__data__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__tls_cfg__data__f_help } },
    },
};
static iop_field_attrs_t const core__tls_cfg__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__tls_cfg__keyname__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__tls_cfg__data__attrs,
    },
};
static iop_field_t const core__tls_cfg__desc_fields[] = {
    {
        .name      = LSTR_IMMED("keyname"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__tls_cfg__t, keyname),
        .size      = fieldsizeof(core__tls_cfg__t, keyname),
    },
    {
        .name      = LSTR_IMMED("data"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRUCT,
        .data_offs = offsetof(core__tls_cfg__t, data),
        .size      = sizeof(core__tls_cert_and_key__t),
        .u1        = { .st_desc = &core__tls_cert_and_key__s },
    },
};
static const iop_help_t core__tls_cfg__s_help = {
    .brief = LSTR_IMMED("TLS configuration."),
    .details = LSTR_IMMED("These should be stored in the platform keychain, if available, and\012refered by their keyname. They may also be directly provided."),
};
static const iop_struct_attr_t core__tls_cfg__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__tls_cfg__s_help } },
    },
};
static const iop_struct_attrs_t core__tls_cfg__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__tls_cfg__s_attrs,
};
const iop_struct_t core__tls_cfg__s = {
    .fullname   = LSTR_IMMED("core.TlsCfg"),
    .fields     = core__tls_cfg__desc_fields,
    .ranges     = iop__ranges__5,
    .ranges_len = countof(iop__ranges__5) / 2,
    .fields_len = countof(core__tls_cfg__desc_fields),
    .size       = sizeof(core__tls_cfg__t),
    .flags      = 1,
    .is_union   = true,
    .st_attrs   = &core__tls_cfg__s_desc_attrs,
    .fields_attrs = core__tls_cfg__desc_fields_attrs,
};
iop_struct_t const * const core__tls_cfg__sp = &core__tls_cfg__s;

/* }}} */
/* Structure core.HttpdCfg {{{ */

static const iop_help_t core__httpd_cfg__bind_addr__f_help = {
    .brief = LSTR_IMMED("Address (host:port) to listen on"),
};
static int core__httpd_cfg__bind_addr__check(const void *ptr, int n)
{
    for (int j = 0; j < n; j++) {
        lstr_t    val = IOP_FIELD(lstr_t   , ptr, j);

        if (val.len == 0) {
            if (n > 1) {
                iop_set_err("violation of constraint %s on field %s[%d]",
                            "nonEmpty", "bindAddr", j);
            } else {
                iop_set_err("violation of constraint %s on field %s",
                            "nonEmpty", "bindAddr");
            }
            return -1;
        }
    }
    return 0;
}
static iop_field_attr_t const core__httpd_cfg__bind_addr__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__bind_addr__f_help } },
    },
    {
        .type = 13,
        .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED("cfg:fullAddr") }, { .v.i64 = 1UL } },
    },
};
static const iop_help_t core__httpd_cfg__outbuf_max_size__f_help = {
    .brief = LSTR_IMMED("Maximum size of the output buffer (in octets)"),
};
static iop_field_attr_t const core__httpd_cfg__outbuf_max_size__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__outbuf_max_size__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__pipeline_depth__f_help = {
    .brief = LSTR_IMMED("Maximum number of pending incoming queries"),
};
static iop_field_attr_t const core__httpd_cfg__pipeline_depth__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__pipeline_depth__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__noact_delay__f_help = {
    .brief = LSTR_IMMED("Maximum time of inactivity before connection closing (in ms)"),
};
static iop_field_attr_t const core__httpd_cfg__noact_delay__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__noact_delay__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__max_queries__f_help = {
    .brief = LSTR_IMMED("Maximum number of incoming queries handled into a connection life"),
};
static iop_field_attr_t const core__httpd_cfg__max_queries__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__max_queries__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__max_conns_in__f_help = {
    .brief = LSTR_IMMED("Maximum number of inbound connections"),
};
static iop_field_attr_t const core__httpd_cfg__max_conns_in__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__max_conns_in__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__on_data_threshold__f_help = {
    .brief = LSTR_IMMED("Amount of data buffered by the body parser before flushing"),
};
static iop_field_attr_t const core__httpd_cfg__on_data_threshold__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__on_data_threshold__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__header_line_max__f_help = {
    .brief = LSTR_IMMED("Maximum line length in headers"),
};
static iop_field_attr_t const core__httpd_cfg__header_line_max__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__header_line_max__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__header_size_max__f_help = {
    .brief = LSTR_IMMED("Maximum total size for headers"),
};
static iop_field_attr_t const core__httpd_cfg__header_size_max__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__header_size_max__f_help } },
    },
};
static const iop_help_t core__httpd_cfg__tls__f_help = {
    .brief = LSTR_IMMED("TLS data: certificate and private key."),
};
static iop_field_attr_t const core__httpd_cfg__tls__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpd_cfg__tls__f_help } },
    },
};
static iop_field_attrs_t const core__httpd_cfg__desc_fields_attrs[] = {
    {
        .flags             = 270368,
        .attrs_len         = 2,
        .check_constraints = &core__httpd_cfg__bind_addr__check,
        .attrs             = core__httpd_cfg__bind_addr__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__outbuf_max_size__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__pipeline_depth__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__noact_delay__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__max_queries__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__max_conns_in__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__on_data_threshold__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__header_line_max__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__header_size_max__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpd_cfg__tls__attrs,
    },
};
static iop_field_t const core__httpd_cfg__desc_fields[] = {
    {
        .name      = LSTR_IMMED("bindAddr"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__httpd_cfg__t, bind_addr),
        .flags     = 1,
        .size      = fieldsizeof(core__httpd_cfg__t, bind_addr),
    },
    {
        .name      = LSTR_IMMED("outbufMaxSize"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpd_cfg__t, outbuf_max_size),
        .u1        = { .defval_u64 = 0x2000000 },
        .size      = fieldsizeof(core__httpd_cfg__t, outbuf_max_size),
    },
    {
        .name      = LSTR_IMMED("pipelineDepth"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U16,
        .data_offs = offsetof(core__httpd_cfg__t, pipeline_depth),
        .u1        = { .defval_u64 = 0x20 },
        .size      = fieldsizeof(core__httpd_cfg__t, pipeline_depth),
    },
    {
        .name      = LSTR_IMMED("noactDelay"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpd_cfg__t, noact_delay),
        .u1        = { .defval_u64 = 0x7530 },
        .size      = fieldsizeof(core__httpd_cfg__t, noact_delay),
    },
    {
        .name      = LSTR_IMMED("maxQueries"),
        .tag       = 5,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpd_cfg__t, max_queries),
        .u1        = { .defval_u64 = 0x400 },
        .size      = fieldsizeof(core__httpd_cfg__t, max_queries),
    },
    {
        .name      = LSTR_IMMED("maxConnsIn"),
        .tag       = 6,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpd_cfg__t, max_conns_in),
        .u1        = { .defval_u64 = 0x3e8 },
        .size      = fieldsizeof(core__httpd_cfg__t, max_conns_in),
    },
    {
        .name      = LSTR_IMMED("onDataThreshold"),
        .tag       = 7,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpd_cfg__t, on_data_threshold),
        .u1        = { .defval_u64 = 0x4000 },
        .size      = fieldsizeof(core__httpd_cfg__t, on_data_threshold),
    },
    {
        .name      = LSTR_IMMED("headerLineMax"),
        .tag       = 8,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpd_cfg__t, header_line_max),
        .u1        = { .defval_u64 = 0x400 },
        .size      = fieldsizeof(core__httpd_cfg__t, header_line_max),
    },
    {
        .name      = LSTR_IMMED("headerSizeMax"),
        .tag       = 9,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpd_cfg__t, header_size_max),
        .u1        = { .defval_u64 = 0x10000 },
        .size      = fieldsizeof(core__httpd_cfg__t, header_size_max),
    },
    {
        .name      = LSTR_IMMED("tls"),
        .tag       = 10,
        .tag_len   = 0,
        .repeat    = IOP_R_OPTIONAL,
        .type      = IOP_T_UNION,
        .data_offs = offsetof(core__httpd_cfg__t, tls),
        .size      = sizeof(core__tls_cfg__t),
        .u1        = { .st_desc = &core__tls_cfg__s },
    },
};
static int const iop__ranges__7[] = {
    0, 1,
    10,
};
const iop_struct_t core__httpd_cfg__s = {
    .fullname   = LSTR_IMMED("core.HttpdCfg"),
    .fields     = core__httpd_cfg__desc_fields,
    .ranges     = iop__ranges__7,
    .ranges_len = countof(iop__ranges__7) / 2,
    .fields_len = countof(core__httpd_cfg__desc_fields),
    .size       = sizeof(core__httpd_cfg__t),
    .flags      = 3,
    .fields_attrs = core__httpd_cfg__desc_fields_attrs,
};
iop_struct_t const * const core__httpd_cfg__sp = &core__httpd_cfg__s;

/* }}} */
/* Structure core.HttpcCfg {{{ */

static const iop_help_t core__httpc_cfg__pipeline_depth__f_help = {
    .brief = LSTR_IMMED("Maximum number of pending outgoing queries"),
};
static iop_field_attr_t const core__httpc_cfg__pipeline_depth__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpc_cfg__pipeline_depth__f_help } },
    },
};
static const iop_help_t core__httpc_cfg__noact_delay__f_help = {
    .brief = LSTR_IMMED("Maximum time of inactivity before connection closing (in ms)"),
};
static iop_field_attr_t const core__httpc_cfg__noact_delay__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpc_cfg__noact_delay__f_help } },
    },
};
static const iop_help_t core__httpc_cfg__max_queries__f_help = {
    .brief = LSTR_IMMED("Maximum number of outgoing queries handled into a connection life"),
};
static iop_field_attr_t const core__httpc_cfg__max_queries__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpc_cfg__max_queries__f_help } },
    },
};
static const iop_help_t core__httpc_cfg__on_data_threshold__f_help = {
    .brief = LSTR_IMMED("Amount of data buffered by the body parser before flushing"),
};
static iop_field_attr_t const core__httpc_cfg__on_data_threshold__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpc_cfg__on_data_threshold__f_help } },
    },
};
static const iop_help_t core__httpc_cfg__header_line_max__f_help = {
    .brief = LSTR_IMMED("Maximum line length in headers"),
};
static iop_field_attr_t const core__httpc_cfg__header_line_max__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpc_cfg__header_line_max__f_help } },
    },
};
static const iop_help_t core__httpc_cfg__header_size_max__f_help = {
    .brief = LSTR_IMMED("Maximum total size for headers"),
};
static iop_field_attr_t const core__httpc_cfg__header_size_max__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__httpc_cfg__header_size_max__f_help } },
    },
};
static iop_field_attrs_t const core__httpc_cfg__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpc_cfg__pipeline_depth__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpc_cfg__noact_delay__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpc_cfg__max_queries__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpc_cfg__on_data_threshold__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpc_cfg__header_line_max__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__httpc_cfg__header_size_max__attrs,
    },
};
static iop_field_t const core__httpc_cfg__desc_fields[] = {
    {
        .name      = LSTR_IMMED("pipelineDepth"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U16,
        .data_offs = offsetof(core__httpc_cfg__t, pipeline_depth),
        .u1        = { .defval_u64 = 0x20 },
        .size      = fieldsizeof(core__httpc_cfg__t, pipeline_depth),
    },
    {
        .name      = LSTR_IMMED("noactDelay"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpc_cfg__t, noact_delay),
        .u1        = { .defval_u64 = 0x7530 },
        .size      = fieldsizeof(core__httpc_cfg__t, noact_delay),
    },
    {
        .name      = LSTR_IMMED("maxQueries"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpc_cfg__t, max_queries),
        .u1        = { .defval_u64 = 0x400 },
        .size      = fieldsizeof(core__httpc_cfg__t, max_queries),
    },
    {
        .name      = LSTR_IMMED("onDataThreshold"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpc_cfg__t, on_data_threshold),
        .u1        = { .defval_u64 = 0x4000 },
        .size      = fieldsizeof(core__httpc_cfg__t, on_data_threshold),
    },
    {
        .name      = LSTR_IMMED("headerLineMax"),
        .tag       = 5,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpc_cfg__t, header_line_max),
        .u1        = { .defval_u64 = 0x400 },
        .size      = fieldsizeof(core__httpc_cfg__t, header_line_max),
    },
    {
        .name      = LSTR_IMMED("headerSizeMax"),
        .tag       = 6,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_U32,
        .data_offs = offsetof(core__httpc_cfg__t, header_size_max),
        .u1        = { .defval_u64 = 0x10000 },
        .size      = fieldsizeof(core__httpc_cfg__t, header_size_max),
    },
};
static int const iop__ranges__8[] = {
    0, 1,
    6,
};
const iop_struct_t core__httpc_cfg__s = {
    .fullname   = LSTR_IMMED("core.HttpcCfg"),
    .fields     = core__httpc_cfg__desc_fields,
    .ranges     = iop__ranges__8,
    .ranges_len = countof(iop__ranges__8) / 2,
    .fields_len = countof(core__httpc_cfg__desc_fields),
    .size       = sizeof(core__httpc_cfg__t),
    .flags      = 1,
    .fields_attrs = core__httpc_cfg__desc_fields_attrs,
};
iop_struct_t const * const core__httpc_cfg__sp = &core__httpc_cfg__s;

/* }}} */
/* Structure core.IopJsonSubfile {{{ */

static const iop_help_t core__iop_json_subfile__file_path__f_help = {
    .brief = LSTR_IMMED("Path to the (un)packed json."),
    .details = LSTR_IMMED("On unpack, the returned path is relative to the main file.\012On pack, the path can be either absolute or relative to the main file."),
};
static iop_field_attr_t const core__iop_json_subfile__file_path__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__iop_json_subfile__file_path__f_help } },
    },
};
static const iop_help_t core__iop_json_subfile__iop_path__f_help = {
    .brief = LSTR_IMMED("IOP path from the main (un)packed object."),
};
static iop_field_attr_t const core__iop_json_subfile__iop_path__attrs[] = {
    {
        .type = 18,
        .args = (iop_field_attr_arg_t[]){ { .v.p = &core__iop_json_subfile__iop_path__f_help } },
    },
};
static iop_field_attrs_t const core__iop_json_subfile__desc_fields_attrs[] = {
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__iop_json_subfile__file_path__attrs,
    },
    {
        .flags             = 262144,
        .attrs_len         = 1,
        .attrs             = core__iop_json_subfile__iop_path__attrs,
    },
};
static iop_field_t const core__iop_json_subfile__desc_fields[] = {
    {
        .name      = LSTR_IMMED("filePath"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__iop_json_subfile__t, file_path),
        .size      = fieldsizeof(core__iop_json_subfile__t, file_path),
    },
    {
        .name      = LSTR_IMMED("iopPath"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__iop_json_subfile__t, iop_path),
        .size      = fieldsizeof(core__iop_json_subfile__t, iop_path),
    },
};
static const iop_help_t core__iop_json_subfile__s_help = {
    .brief = LSTR_IMMED("Sub-file (un)packed with the IOP-Json \134include feature."),
};
static const iop_struct_attr_t core__iop_json_subfile__s_attrs[] = {
    {
        .type = 6,
        .args = (iop_struct_attr_arg_t[]){ { .v.p = &core__iop_json_subfile__s_help } },
    },
};
static const iop_struct_attrs_t core__iop_json_subfile__s_desc_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__iop_json_subfile__s_attrs,
};
const iop_struct_t core__iop_json_subfile__s = {
    .fullname   = LSTR_IMMED("core.IopJsonSubfile"),
    .fields     = core__iop_json_subfile__desc_fields,
    .ranges     = iop__ranges__5,
    .ranges_len = countof(iop__ranges__5) / 2,
    .fields_len = countof(core__iop_json_subfile__desc_fields),
    .size       = sizeof(core__iop_json_subfile__t),
    .flags      = 1,
    .st_attrs   = &core__iop_json_subfile__s_desc_attrs,
    .fields_attrs = core__iop_json_subfile__desc_fields_attrs,
};
iop_struct_t const * const core__iop_json_subfile__sp = &core__iop_json_subfile__s;

/* }}} */
/* Interface core.Log {{{ */
/* Structure core.Log.setRootLevelArgs {{{ */

static iop_field_t const core__log__set_root_level_args__desc_fields[] = {
    {
        .name      = LSTR_IMMED("level"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_ENUM,
        .data_offs = offsetof(core__log__set_root_level_args__t, level),
        .size      = fieldsizeof(core__log__set_root_level_args__t, level),
        .u1        = { .en_desc = &core__log_level__e },
    },
    {
        .name      = LSTR_IMMED("forceAll"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__log__set_root_level_args__t, force_all),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__log__set_root_level_args__t, force_all),
    },
    {
        .name      = LSTR_IMMED("isSilent"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__log__set_root_level_args__t, is_silent),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__log__set_root_level_args__t, is_silent),
    },
};
static int const iop__ranges__9[] = {
    0, 1,
    3,
};
const iop_struct_t core__log__set_root_level_args__s = {
    .fullname   = LSTR_IMMED("core.Log.setRootLevelArgs"),
    .fields     = core__log__set_root_level_args__desc_fields,
    .ranges     = iop__ranges__9,
    .ranges_len = countof(iop__ranges__9) / 2,
    .fields_len = countof(core__log__set_root_level_args__desc_fields),
    .size       = sizeof(core__log__set_root_level_args__t),
};
iop_struct_t const * const core__log__set_root_level_args__sp = &core__log__set_root_level_args__s;

/* }}} */
/* Structure core.Log.setRootLevelRes {{{ */

static iop_field_t const core__log__set_root_level_res__desc_fields[] = {
    {
        .name      = LSTR_IMMED("level"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_ENUM,
        .data_offs = offsetof(core__log__set_root_level_res__t, level),
        .size      = fieldsizeof(core__log__set_root_level_res__t, level),
        .u1        = { .en_desc = &core__log_level__e },
    },
};
static int const iop__ranges__10[] = {
    0, 1,
    1,
};
const iop_struct_t core__log__set_root_level_res__s = {
    .fullname   = LSTR_IMMED("core.Log.setRootLevelRes"),
    .fields     = core__log__set_root_level_res__desc_fields,
    .ranges     = iop__ranges__10,
    .ranges_len = countof(iop__ranges__10) / 2,
    .fields_len = countof(core__log__set_root_level_res__desc_fields),
    .size       = sizeof(core__log__set_root_level_res__t),
};
iop_struct_t const * const core__log__set_root_level_res__sp = &core__log__set_root_level_res__s;

/* }}} */
/* Structure core.Log.resetRootLevelRes {{{ */

/* same as core.Log.setRootLevelRes */

const iop_struct_t core__log__reset_root_level_res__s = {
    .fullname   = LSTR_IMMED("core.Log.resetRootLevelRes"),
    .fields     = core__log__set_root_level_res__desc_fields,
    .ranges     = iop__ranges__10,
    .ranges_len = countof(iop__ranges__10) / 2,
    .fields_len = countof(core__log__set_root_level_res__desc_fields),
    .size       = sizeof(core__log__reset_root_level_res__t),
};
iop_struct_t const * const core__log__reset_root_level_res__sp = &core__log__reset_root_level_res__s;

/* }}} */
/* Structure core.Log.setLoggerLevelArgs {{{ */

static iop_field_t const core__log__set_logger_level_args__desc_fields[] = {
    {
        .name      = LSTR_IMMED("fullName"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__log__set_logger_level_args__t, full_name),
        .size      = fieldsizeof(core__log__set_logger_level_args__t, full_name),
    },
    {
        .name      = LSTR_IMMED("level"),
        .tag       = 2,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_ENUM,
        .data_offs = offsetof(core__log__set_logger_level_args__t, level),
        .size      = fieldsizeof(core__log__set_logger_level_args__t, level),
        .u1        = { .en_desc = &core__log_level__e },
    },
    {
        .name      = LSTR_IMMED("forceAll"),
        .tag       = 3,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__log__set_logger_level_args__t, force_all),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__log__set_logger_level_args__t, force_all),
    },
    {
        .name      = LSTR_IMMED("isSilent"),
        .tag       = 4,
        .tag_len   = 0,
        .repeat    = IOP_R_DEFVAL,
        .type      = IOP_T_BOOL,
        .data_offs = offsetof(core__log__set_logger_level_args__t, is_silent),
        .u1        = { .defval_u64 = false },
        .size      = fieldsizeof(core__log__set_logger_level_args__t, is_silent),
    },
};
const iop_struct_t core__log__set_logger_level_args__s = {
    .fullname   = LSTR_IMMED("core.Log.setLoggerLevelArgs"),
    .fields     = core__log__set_logger_level_args__desc_fields,
    .ranges     = iop__ranges__3,
    .ranges_len = countof(iop__ranges__3) / 2,
    .fields_len = countof(core__log__set_logger_level_args__desc_fields),
    .size       = sizeof(core__log__set_logger_level_args__t),
};
iop_struct_t const * const core__log__set_logger_level_args__sp = &core__log__set_logger_level_args__s;

/* }}} */
/* Structure core.Log.setLoggerLevelRes {{{ */

/* same as core.Log.setRootLevelRes */

const iop_struct_t core__log__set_logger_level_res__s = {
    .fullname   = LSTR_IMMED("core.Log.setLoggerLevelRes"),
    .fields     = core__log__set_root_level_res__desc_fields,
    .ranges     = iop__ranges__10,
    .ranges_len = countof(iop__ranges__10) / 2,
    .fields_len = countof(core__log__set_root_level_res__desc_fields),
    .size       = sizeof(core__log__set_logger_level_res__t),
};
iop_struct_t const * const core__log__set_logger_level_res__sp = &core__log__set_logger_level_res__s;

/* }}} */
/* Structure core.Log.resetLoggerLevelArgs {{{ */

static iop_field_t const core__log__reset_logger_level_args__desc_fields[] = {
    {
        .name      = LSTR_IMMED("fullName"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REQUIRED,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__log__reset_logger_level_args__t, full_name),
        .size      = fieldsizeof(core__log__reset_logger_level_args__t, full_name),
    },
};
const iop_struct_t core__log__reset_logger_level_args__s = {
    .fullname   = LSTR_IMMED("core.Log.resetLoggerLevelArgs"),
    .fields     = core__log__reset_logger_level_args__desc_fields,
    .ranges     = iop__ranges__10,
    .ranges_len = countof(iop__ranges__10) / 2,
    .fields_len = countof(core__log__reset_logger_level_args__desc_fields),
    .size       = sizeof(core__log__reset_logger_level_args__t),
};
iop_struct_t const * const core__log__reset_logger_level_args__sp = &core__log__reset_logger_level_args__s;

/* }}} */
/* Structure core.Log.resetLoggerLevelRes {{{ */

/* same as core.Log.setRootLevelRes */

const iop_struct_t core__log__reset_logger_level_res__s = {
    .fullname   = LSTR_IMMED("core.Log.resetLoggerLevelRes"),
    .fields     = core__log__set_root_level_res__desc_fields,
    .ranges     = iop__ranges__10,
    .ranges_len = countof(iop__ranges__10) / 2,
    .fields_len = countof(core__log__set_root_level_res__desc_fields),
    .size       = sizeof(core__log__reset_logger_level_res__t),
};
iop_struct_t const * const core__log__reset_logger_level_res__sp = &core__log__reset_logger_level_res__s;

/* }}} */
/* Structure core.Log.listLoggersArgs {{{ */

static iop_field_t const core__log__list_loggers_args__desc_fields[] = {
    {
        .name      = LSTR_IMMED("prefix"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_OPTIONAL,
        .type      = IOP_T_STRING,
        .data_offs = offsetof(core__log__list_loggers_args__t, prefix),
        .size      = fieldsizeof(core__log__list_loggers_args__t, prefix),
    },
};
const iop_struct_t core__log__list_loggers_args__s = {
    .fullname   = LSTR_IMMED("core.Log.listLoggersArgs"),
    .fields     = core__log__list_loggers_args__desc_fields,
    .ranges     = iop__ranges__10,
    .ranges_len = countof(iop__ranges__10) / 2,
    .fields_len = countof(core__log__list_loggers_args__desc_fields),
    .size       = sizeof(core__log__list_loggers_args__t),
};
iop_struct_t const * const core__log__list_loggers_args__sp = &core__log__list_loggers_args__s;

/* }}} */
/* Structure core.Log.listLoggersRes {{{ */

static iop_field_t const core__log__list_loggers_res__desc_fields[] = {
    {
        .name      = LSTR_IMMED("loggers"),
        .tag       = 1,
        .tag_len   = 0,
        .repeat    = IOP_R_REPEATED,
        .type      = IOP_T_STRUCT,
        .data_offs = offsetof(core__log__list_loggers_res__t, loggers),
        .size      = sizeof(core__logger_configuration__t),
        .u1        = { .st_desc = &core__logger_configuration__s },
    },
};
const iop_struct_t core__log__list_loggers_res__s = {
    .fullname   = LSTR_IMMED("core.Log.listLoggersRes"),
    .fields     = core__log__list_loggers_res__desc_fields,
    .ranges     = iop__ranges__10,
    .ranges_len = countof(iop__ranges__10) / 2,
    .fields_len = countof(core__log__list_loggers_res__desc_fields),
    .size       = sizeof(core__log__list_loggers_res__t),
};
iop_struct_t const * const core__log__list_loggers_res__sp = &core__log__list_loggers_res__s;

/* }}} */
static iop_rpc_t const core__log__if_funs[] = {
    {
        .name      = LSTR_IMMED("setRootLevel"),
        .tag       = 1,
        .args      = &core__log__set_root_level_args__s,
        .result    = &core__log__set_root_level_res__s,
        .exn       = &iop__void__s,
    },
    {
        .name      = LSTR_IMMED("resetRootLevel"),
        .tag       = 2,
        .args      = &iop__void__s,
        .result    = &core__log__reset_root_level_res__s,
        .exn       = &iop__void__s,
    },
    {
        .name      = LSTR_IMMED("setLoggerLevel"),
        .tag       = 3,
        .args      = &core__log__set_logger_level_args__s,
        .result    = &core__log__set_logger_level_res__s,
        .exn       = &iop__void__s,
    },
    {
        .name      = LSTR_IMMED("resetLoggerLevel"),
        .tag       = 4,
        .args      = &core__log__reset_logger_level_args__s,
        .result    = &core__log__reset_logger_level_res__s,
        .exn       = &iop__void__s,
    },
    {
        .name      = LSTR_IMMED("listLoggers"),
        .tag       = 5,
        .args      = &core__log__list_loggers_args__s,
        .result    = &core__log__list_loggers_res__s,
        .exn       = &iop__void__s,
    },
};
static const iop_help_t core__log__if_help = {
    .brief = LSTR_IMMED("Interface providing the basis for configuring and accessing\012 the logging system."),
};
static const iop_iface_attr_t core__log__if_attrs[] = {
    {
        .type = 6,
        .args = (iop_iface_attr_arg_t[]){ { .v.p = &core__log__if_help } },
    },
};
static const iop_iface_attrs_t core__log__desc_if_attrs = {
    .flags     = 64,
    .attrs_len = 1,
    .attrs     = core__log__if_attrs,
};
const iop_iface_t core__log__if = {
    .fullname   = LSTR_IMMED("core.Log"),
    .funs       = core__log__if_funs,
    .funs_len   = countof(core__log__if_funs),
    .flags      = 2,
    .iface_attrs  = &core__log__desc_if_attrs,
};
const iop_iface_t * const core__log__ifp = &core__log__if;

/* }}} */
/* Module core.Core {{{ */

static iop_iface_alias_t const core__core__aliases[] = {
    {
        .name  = LSTR_IMMED("log"),
        .iface = &core__log__if,
        .tag   = 16384,
    },
};
static const iop_help_t core__core__m_help = {
    .brief = LSTR_IMMED("Module exporting interfaces provided by lib-common."),
};
static const iop_mod_attr_t core__core__m_attrs[] = {
    {
        .type = 1,
        .args = (iop_mod_attr_arg_t[]){ { .v.p = &core__core__m_help } },
    },
};
static const iop_mod_attrs_t core__core__m_desc_attrs = {
    .flags     = 2,
    .attrs_len = 1,
    .attrs     = core__core__m_attrs,
};
iop_mod_t const core__core__mod = {
    .fullname   = LSTR_IMMED("core.Core"),
    .ifaces     = core__core__aliases,
    .ifaces_len = countof(core__core__aliases),
    .flags      = 1,
    .mod_attrs  = &core__core__m_desc_attrs,
};
iop_mod_t const * const core__core__modp = &core__core__mod;

/* }}} */
/* Package core {{{ */

static const iop_pkg_t *const core__deps[] = {
    NULL,
};

static const iop_enum_t *const core__enums[] = {
    &core__log_level__e,
    &core__iop_http_method__e,
    NULL,
};

static const iop_struct_t *const core__structs[] = {
    &core__logger_configuration__s,
    &core__log_configuration__s,
    &core__log_file_configuration__s,
    &core__licence_module__s,
    &core__licence__s,
    &core__activation_token__s,
    &core__signed_licence__s,
    &core__tls_cert_and_key__s,
    &core__tls_cfg__s,
    &core__httpd_cfg__s,
    &core__httpc_cfg__s,
    &core__iop_json_subfile__s,
    NULL,
};

static const iop_iface_t *const core__ifaces[] = {
    &core__log__if,
    NULL,
};

static const iop_mod_t *const core__mods[] = {
    &core__core__mod,
    NULL,
};

iop_pkg_t const core__pkg = {
    .name    = LSTR_IMMED("core"),
    .deps    = core__deps,
    .enums   = core__enums,
    .structs = core__structs,
    .ifaces  = core__ifaces,
    .mods    = core__mods,
};
iop_pkg_t const * const core__pkgp = &core__pkg;

/* }}} */

