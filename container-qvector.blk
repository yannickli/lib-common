/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "container-qvector.h"
#include "sort.h"

static void __qvector_reset(qvector_t *vec, size_t v_size, size_t threshold)
{
    mem_pool_t *mp = mp_ipool(vec->mp);
    size_t sz = vec->size;

    if (!(mp->mem_pool & MEM_BY_FRAME) && sz * v_size >= threshold) {
        mp_delete(mp, &vec->tab);
        __qvector_init(vec, NULL, 0, 0, vec->mp);
    } else {
        vec->len = 0;
    }
}

void qvector_reset(qvector_t *vec, size_t v_size)
{
    __qvector_reset(vec, v_size, 128 << 10);
}

void qvector_wipe(qvector_t *vec, size_t v_size)
{
    __qvector_reset(vec, v_size, 0);
}

static void qvector_get_grow_info(qvector_t *vec, size_t v_size, int extra,
                                  int *newsz, bool *needs_alloc)
{
    int newlen = vec->len + extra;

    if (unlikely(newlen < 0)) {
        e_panic("trying to allocate insane amount of memory");
    }

    if (newlen < vec->size) {
        *needs_alloc = false;
        return;
    }

    *newsz = p_alloc_nr(vec->size);
    if (*newsz < newlen) {
        *newsz = newlen;
    }

    *needs_alloc = true;
}

uint64_t __qvector_grow_get_new_alloc_size(qvector_t *nonnull vec,
                                           size_t v_size, int extra)
{
    int newsz;
    bool needs_alloc;

    qvector_get_grow_info(vec, v_size, extra, &newsz, &needs_alloc);

    if (!needs_alloc) {
        return 0;
    }
    return newsz * v_size;
}

void __qvector_grow(qvector_t *vec, size_t v_size, size_t v_align, int extra)
{
    int newsz;
    bool needs_alloc;

    qvector_get_grow_info(vec, v_size, extra, &newsz, &needs_alloc);
    if (!needs_alloc) {
        return;
    }

    vec->tab = mp_irealloc_fallback(&vec->mp, vec->tab, vec->len * v_size,
                                    newsz * v_size, v_align, MEM_RAW);
    vec->size = newsz;
}

void __qvector_optimize(qvector_t *vec, size_t v_size, size_t v_align,
                        size_t size)
{
    mem_pool_t *mp = mp_ipool(vec->mp);
    char *buf;

    if (size == 0) {
        qvector_reset(vec, v_size);
        return;
    }
    if ((mp->mem_pool & MEM_BY_FRAME)) {
        return;
    }
    buf = mpa_new_raw(mp, char, size * v_size, v_align);
    memcpy(buf, vec->tab, vec->len * v_size);
    mp_delete(mp, &vec->tab);
    __qvector_init(vec, buf, vec->len, size, vec->mp);
}

void *__qvector_splice(qvector_t *vec, size_t v_size, size_t v_align,
                       int pos, int rm_len, int inserted_len)
{
    assert (pos >= 0 && rm_len >= 0 && inserted_len >= 0);
    assert (pos <= vec->len && pos + rm_len <= vec->len);

    if (rm_len >= inserted_len) {
        memmove(vec->tab + v_size * (pos + inserted_len),
                vec->tab + v_size * (pos + rm_len),
                v_size * (vec->len - pos - rm_len));
        qvector_grow(vec, v_size, v_align, 0);
    } else {
        qvector_grow(vec, v_size, v_align, inserted_len - rm_len);
        memmove(vec->tab + v_size * (pos + inserted_len),
                vec->tab + v_size * (pos + rm_len),
                v_size * (vec->len - pos - rm_len));
    }
    vec->len += inserted_len - rm_len;
    return vec->tab + pos * v_size;
}

static void ___qv_sort(void *a, size_t v_size, size_t n, qvector_cmp_b cmp)
{
    uint8_t tmp[v_size], meantmp[v_size];
    void   *mean, *i, *j;
    size_t  n1;

#define swap(p,q)        ({ memcpy(tmp, p, v_size);      \
                            memcpy(p, q, v_size);        \
                            memcpy(q, tmp, v_size); })
#define rotate(p,r,q)    ({ memcpy(tmp, p, v_size);      \
                            memcpy(p, q, v_size);        \
                            memcpy(q, r, v_size);        \
                            memcpy(r, tmp, v_size); })

#define nth(base, i)     ((void *)((uint8_t *)(base) + (i) * v_size))

    if (n <= 1)
        return;

    for (;;) {
        i = a;
        j = nth(a, n - 1);

        if (cmp(i, j) > 0) {
            swap(i, j);
        }
        if (n == 2)
            return;

        mean = nth(i, n >> 1);
        if (cmp(i, mean) > 0) {
            swap(i, mean);
        } else
        if (cmp(mean, j) > 0) {
            swap(j, mean);
        }

        if (n == 3)
            return;         /* in case of 3 items */

        memcpy(meantmp, mean, v_size);  /* cause *mean is gonna change */
        for (;;) {
            /* We do not have guards in these loops because we assume
             * compare(x, x) returns 0.  If the comparison function is not
             * regular and returns != 0 on identical arguments, all bets
             * are off and this code may crash.
             */
            do {
                i = nth(i, 1);
            } while (cmp(meantmp, i) > 0);  /* find GE in left part */

            do {
                j = nth(j, -1);
            } while (cmp(j, meantmp) > 0);  /* find LE in right part */

            if (i < j) {
                swap(i, j);        /* swap if needed */
                continue;
            }
            break;
        }

        /* i >= j : we're done and need to recurse on both ranges.
         * either i == j   : don't look at the ith element
         * or     i == j+1 : and split between them.
         */

        /* Fix ranges: [a..i[ U [j+1..a+n[ become [a..a+n[ U [j..j+n1[ */
        j  = nth(j, 1);
        n1 = ((uint8_t *)nth(a, n) - (uint8_t *)j) / v_size;
        n  = ((uint8_t *)i - (uint8_t *)a) / v_size;

        /* We want to recurse on [a..a+n[ and [j..j+n1[, but in order
         * to minimize stack usage, we only recurse on the smaller
         * range and loop on the other.  First test the intersection as it may
         * cause to loop on the larger segment.
         */
        if (n <= n1) {
            SWAP(size_t, n, n1);
            SWAP(void *, a, j);
        }

        if (n1 > 1) {
            ___qv_sort(j, v_size, n1, cmp);
        }
    }
#undef nth
#undef swap
#undef rotate
}

__flatten
void __qv_sort32(void *a, size_t n, qvector_cmp_b cmp)
{
    ___qv_sort(a, 4, n, cmp);
}

__flatten
void __qv_sort64(void *a, size_t n, qvector_cmp_b cmp)
{
    ___qv_sort(a, 8, n, cmp);
}

__flatten
void __qv_sort(void *a, size_t v_size, size_t n, qvector_cmp_b cmp)
{
    ___qv_sort(a, v_size, n, cmp);
}

void __qvector_diff(const qvector_t *vec1, const qvector_t *vec2,
                    qvector_t *add, qvector_t *del, qvector_t *inter,
                    size_t v_size, size_t v_align, qvector_cmp_b cmp)
{
    int pos1 = 0, pos2 = 0;
    const void *tab1 = vec1->tab;
    const void *tab2 = vec2->tab;
    const void *elem1, *elem2;

#define nth(base, i)  ((void *)((uint8_t *)(base) + (i) * v_size))
#define append_tab(tab, src, len)                                            \
    if ((tab))                                                               \
        memcpy(qvector_growlen((tab), v_size, v_align, (len)),               \
               src, (len) * v_size);
#define append_add(src, len)    append_tab(add, src, len)
#define append_del(src, len)    append_tab(del, src, len)
#define append_inter(src, len)  append_tab(inter, src, len)

    if (add) {
        qvector_grow(add, v_size, v_align, vec2->len + add->len);
    }
    if (del) {
        qvector_grow(del, v_size, v_align, vec1->len + del->len);
    }

    elem1 = nth(tab1, 0);
    elem2 = nth(tab2, 0);

    while (pos1 < vec1->len && pos2 < vec2->len) {
        int s = cmp(elem1, elem2);

        if (s == 0) {
            append_inter(elem1, 1);
            elem1 = nth(tab1, ++pos1);
            elem2 = nth(tab2, ++pos2);
        } else
        if (s < 0) {
            append_del(elem1, 1);
            elem1 = nth(tab1, ++pos1);
        } else {
            append_add(elem2, 1);
            elem2 = nth(tab2, ++pos2);
        }
    }
    if (pos1 != vec1->len) {
        append_del(elem1, vec1->len - pos1);
    } else {
        append_add(elem2, vec2->len - pos2);
    }

#undef append_add
#undef append_del
#undef append_tab
#undef nth
}

int __qvector_bisect(const qvector_t *vec, size_t v_size, const void *elt,
                     bool *found, qvector_cmp_b cmp)
{
    return bisect_blk(elt, vec->tab, v_size, vec->len, found, cmp);
}

int __qvector_find(const qvector_t *vec, size_t v_size, const void *elt,
                   bool sorted, qvector_cmp_b cmp)
{
    if (sorted) {
        bool found = false;
        int pos = __qvector_bisect(vec, v_size, elt, &found, cmp);

        return found ? pos : -1;
    } else {
        for (int i = 0; i < vec->len; i++) {
            if (cmp(elt, vec->tab + v_size * i) == 0) {
                return i;
            }
        }
        return -1;
    }
}

bool __qvector_contains(const qvector_t *vec, size_t v_size, const void *elt,
                        bool sorted, qvector_cmp_b cmp)
{
    return __qvector_find(vec, v_size, elt, sorted, cmp) != -1;
}

void __qvector_uniq(qvector_t *vec, size_t v_size, qvector_cmp_b cmp,
                    qvector_del_b nullable del)
{
    vec->len = uniq_blk(vec->tab, v_size, vec->len, cmp, del);
}

void __qvector_deep_extend(qvector_t *vec_dst, const qvector_t *vec_src,
                           size_t v_size, size_t v_align, qvector_cpy_b cpy_f)
{
    size_t original_len = vec_dst->len;

    qvector_growlen(vec_dst, v_size, v_align, vec_src->len);
    tab_for_each_pos(pos, vec_src) {
        /* XXX: qvector_t.tab is of type (uint8_t *) so we need to do the
         *       pointer arithmetic ourselves because the true type of the
         *       array could be different.
         */
        cpy_f(vec_dst->tab + (pos + original_len) * v_size,
              vec_src->tab + pos * v_size);
    }
}
