/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "container.h"
#include "sort.h"

void qvector_reset(qvector_t *vec, size_t v_size)
{
    size_t sz = vec->size;

    if (vec->mem_pool == MEM_LIBC && sz * v_size > (128 << 10)) {
        libc_free(vec->tab, 0);
        p_clear(vec, 1);
    } else {
        __qvector_init(vec, vec->tab, 0, sz, vec->mem_pool);
    }
}

void qvector_wipe(qvector_t *vec, size_t v_size)
{
    switch (vec->mem_pool & MEM_POOL_MASK) {
      case MEM_STATIC:
      case MEM_STACK:
        qvector_reset(vec, v_size);
        return;
      default:
        ifree(vec->tab, vec->mem_pool);
        p_clear(vec, 1);
        return;
    }
}

void __qvector_grow(qvector_t *vec, size_t v_size, size_t v_align, int extra)
{
    int newlen = vec->len + extra;
    int newsz;

    if (unlikely(newlen < 0))
        e_panic("trying to allocate insane amount of memory");

    /* if tab fits, return */
    if (newlen < vec->size) {
        return;
    }

    newsz = p_alloc_nr(vec->size);
    if (newsz < newlen)
        newsz = newlen;
    if (vec->mem_pool == MEM_STATIC) {
        uint8_t *s = pa_new_raw(uint8_t, newsz * v_size, v_align);

        memcpy(s, vec->tab, vec->len * v_size);
        __qvector_init(vec, s, vec->len, newsz, MEM_LIBC);
    } else {
        vec->tab = (irealloc)(vec->tab, vec->len * v_size, newsz * v_size,
                              v_align, vec->mem_pool | MEM_RAW);
        vec->size = newsz;
    }
}

void __qvector_optimize(qvector_t *vec, size_t v_size, size_t v_align,
                        size_t size)
{
    char *buf;

    if (size == 0) {
        qvector_reset(vec, v_size);
        return;
    }
    if (vec->mem_pool != MEM_LIBC)
        return;
    buf = pa_new_raw(char, size * v_size, v_align);
    memcpy(buf, vec->tab, vec->len * v_size);
    libc_free(vec->tab, 0);
    __qvector_init(vec, buf, vec->len, size, MEM_LIBC);
}

void *__qvector_splice(qvector_t *vec, size_t v_size, size_t v_align,
                       int pos, int len, int dlen)
{
    assert (pos >= 0 && len >= 0 && dlen >= 0);
    assert (pos <= vec->len && pos + len <= vec->len);

    if (len >= dlen) {
        memmove(vec->tab + v_size * (pos + dlen),
                vec->tab + v_size * (pos + len),
                v_size * (vec->len - pos - len));
        qvector_grow(vec, v_size, v_align, 0);
    } else {
        qvector_grow(vec, v_size, v_align, dlen - len);
        memmove(vec->tab + v_size * (pos + dlen),
                vec->tab + v_size * (pos + len),
                v_size * (vec->len - pos - len));
    }
    vec->len += dlen - len;
    return vec->tab + pos * v_size;
}

static void ___qv_sort(void *a, size_t v_size, size_t n, qvector_cmp_b cmp)
{
    uint8_t tmp[v_size], meantmp[v_size];
    void   *mean, *i, *j;
    size_t  n1;

#define swap(p,q)        ({ memcpy(tmp, p, v_size);      \
                            memcpy(p, q, v_size);        \
                            memcpy(q, tmp, v_size); })
#define rotate(p,r,q)    ({ memcpy(tmp, p, v_size);      \
                            memcpy(p, q, v_size);        \
                            memcpy(q, r, v_size);        \
                            memcpy(r, tmp, v_size); })

#define nth(base, i)     ((void *)((uint8_t *)(base) + (i) * v_size))

    if (n <= 1)
        return;

    for (;;) {
        i = a;
        j = nth(a, n - 1);

        if (cmp(i, j) > 0) {
            swap(i, j);
        }
        if (n == 2)
            return;

        mean = nth(i, n >> 1);
        if (cmp(i, mean) > 0) {
            swap(i, mean);
        } else
        if (cmp(mean, j) > 0) {
            swap(j, mean);
        }

        if (n == 3)
            return;         /* in case of 3 items */

        memcpy(meantmp, mean, v_size);  /* cause *mean is gonna change */
        for (;;) {
            /* We do not have guards in these loops because we assume
             * compare(x, x) returns 0.  If the comparison function is not
             * regular and returns != 0 on identical arguments, all bets
             * are off and this code may crash.
             */
            do {
                i = nth(i, 1);
            } while (cmp(meantmp, i) > 0);  /* find GE in left part */

            do {
                j = nth(j, -1);
            } while (cmp(j, meantmp) > 0);  /* find LE in right part */

            if (i < j) {
                swap(i, j);        /* swap if needed */
                continue;
            }
            break;
        }

        /* i >= j : we're done and need to recurse on both ranges.
         * either i == j   : don't look at the ith element
         * or     i == j+1 : and split between them.
         */

        /* Fix ranges: [a..i[ U [j+1..a+n[ become [a..a+n[ U [j..j+n1[ */
        j  = nth(j, 1);
        n1 = ((uint8_t *)nth(a, n) - (uint8_t *)j) / v_size;
        n  = ((uint8_t *)i - (uint8_t *)a) / v_size;

        /* We want to recurse on [a..a+n[ and [j..j+n1[, but in order
         * to minimize stack usage, we only recurse on the smaller
         * range and loop on the other.  First test the intersection as it may
         * cause to loop on the larger segment.
         */
        if (n <= n1) {
            SWAP(size_t, n, n1);
            SWAP(void *, a, j);
        }

        if (n1 > 1) {
            ___qv_sort(j, v_size, n1, cmp);
        }
    }
#undef nth
#undef swap
#undef rotate
}

__flatten
void __qv_sort32(void *a, size_t n, qvector_cmp_b cmp)
{
    ___qv_sort(a, 4, n, cmp);
}

__flatten
void __qv_sort64(void *a, size_t n, qvector_cmp_b cmp)
{
    ___qv_sort(a, 8, n, cmp);
}

__flatten
void __qv_sort(void *a, size_t v_size, size_t n, qvector_cmp_b cmp)
{
    ___qv_sort(a, v_size, n, cmp);
}

void __qvector_diff(const qvector_t *vec1, const qvector_t *vec2,
                    qvector_t *add, qvector_t *del, qvector_t *inter,
                    size_t v_size, size_t v_align, qvector_cmp_b cmp)
{
    int pos1 = 0, pos2 = 0;
    const void *tab1 = vec1->tab;
    const void *tab2 = vec2->tab;
    const void *elem1, *elem2;

#define nth(base, i)  ((void *)((uint8_t *)(base) + (i) * v_size))
#define append_tab(tab, src, len)                                            \
    if ((tab))                                                               \
        memcpy(qvector_growlen((tab), v_size, v_align, (len)),               \
               src, (len) * v_size);
#define append_add(src, len)    append_tab(add, src, len)
#define append_del(src, len)    append_tab(del, src, len)
#define append_inter(src, len)  append_tab(inter, src, len)

    if (add) {
        qvector_grow(add, v_size, v_align, vec2->len + add->len);
    }
    if (del) {
        qvector_grow(del, v_size, v_align, vec1->len + del->len);
    }

    elem1 = nth(tab1, 0);
    elem2 = nth(tab2, 0);

    while (pos1 < vec1->len && pos2 < vec2->len) {
        int s = cmp(elem1, elem2);

        if (s == 0) {
            append_inter(elem1, 1);
            elem1 = nth(tab1, ++pos1);
            elem2 = nth(tab2, ++pos2);
        } else
        if (s < 0) {
            append_del(elem1, 1);
            elem1 = nth(tab1, ++pos1);
        } else {
            append_add(elem2, 1);
            elem2 = nth(tab2, ++pos2);
        }
    }
    if (pos1 != vec1->len) {
        append_del(elem1, vec1->len - pos1);
    } else {
        append_add(elem2, vec2->len - pos2);
    }

#undef append_add
#undef append_del
#undef append_tab
#undef nth
}

int __qvector_bisect(const qvector_t *vec, size_t v_size, const void *elt,
                     bool *found, qvector_cmp_b cmp)
{
    return bisect_blk(elt, vec->tab, v_size, vec->len, found, cmp);
}

int __qvector_find(const qvector_t *vec, size_t v_size, const void *elt,
                   bool sorted, qvector_cmp_b cmp)
{
    if (sorted) {
        bool found = false;
        int pos = __qvector_bisect(vec, v_size, elt, &found, cmp);

        return found ? pos : -1;
    } else {
        for (int i = 0; i < vec->len; i++) {
            if (cmp(elt, vec->tab + v_size * i) == 0) {
                return i;
            }
        }
        return -1;
    }
}

bool __qvector_contains(const qvector_t *vec, size_t v_size, const void *elt,
                        bool sorted, qvector_cmp_b cmp)
{
    return __qvector_find(vec, v_size, elt, sorted, cmp) != -1;
}

void __qvector_uniq(qvector_t *vec, size_t v_size, qvector_cmp_b cmp)
{
    vec->len = uniq_blk(vec->tab, v_size, vec->len, cmp);
}
