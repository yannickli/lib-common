/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include <lib-common/z.h>
#include <lib-common/container.h>
#include "qps-hat.h"

/* LCOV_EXCL_START */

/* {{{ Z-Helpers */

#define _CHECK_TRIE      do { \
        Z_ASSERT(qhat_check_consistency(&trie));                             \
        Z_HELPER_RUN(check_leak(&trie));                                     \
    } while (0)
#define CHECK_TRIE       if (!Z_HAS_MODE(FAST)) _CHECK_TRIE
#define PRINT_TRIE  \
    _CHECK_TRIE;                                                             \
    if (e_name_is_traced(1, "trie/test")) qhat_debug_print(&trie, 0)

static int check_leak(qhat_t *hat)
{
    qps_roots_t roots;

    qps_roots_init(&roots);
    qhat_get_qps_roots(hat, &roots);
    Z_ASSERT_ZERO(qps_check_leaks(hat->qps, &roots));
    qps_roots_wipe(&roots);
    Z_HELPER_END;
}

static int test_zeros(qps_t *qps, uint8_t size)
{
    qps_handle_t htrie = qhat_create(qps, size, true);
    qhat_t trie;
    uint32_t count;
    qhat_128_t zero = { 0, 0 };

    qhat_init(&trie, qps, htrie);

    /* Store 0s */
    for (uint32_t i = 0; i < 100000; i++) {
        qhat_set0(&trie, i, NULL);
        CHECK_TRIE;
    }
    PRINT_TRIE;

    count = 0;
    qhat_for_each_unsafe (en, &trie) {
        const void *slot = en.value;
        Z_ASSERT_EQ(en.key, count);
        Z_ASSERT_ZERO(memcmp(slot, &zero, size));
        count++;
    }
    Z_ASSERT_EQ(100000u, count);

    /* Remove one entry */
    Z_ASSERT(qhat_remove(&trie, 0, NULL));
    PRINT_TRIE;

    count = 0;
    qhat_for_each_unsafe (en, &trie) {
        const void *slot = en.value;
        Z_ASSERT_EQ(en.key, count + 1);
        Z_ASSERT_ZERO(memcmp(slot, &zero, size));
        count++;
    }
    Z_ASSERT_EQ(99999u, count);

    /* Remove other entries from the end */
    for (uint32_t i = 100000u; i-- > 1;) {
        Z_ASSERT(qhat_remove(&trie, i, NULL));
        CHECK_TRIE;
    }
    PRINT_TRIE;

    qhat_destroy(&trie);
    Z_HELPER_END;
}


static int test_128(qps_t *qps, bool null)
{
    qps_handle_t htrie = qhat_create(qps, 16, null);
    qhat_t trie;

    qhat_init(&trie, qps, htrie);
    qhat_compute_counts(&trie, true);
    Z_ASSERT_EQ(0u, trie.root->entry_count);
    Z_ASSERT_EQ(trie.root->value_len, 16u);
    Z_ASSERT_EQ(trie.desc->value_len, 16u);
    Z_ASSERT_NULL(qhat_get(&trie, 0));
    Z_ASSERT_NULL(qhat_get(&trie, 938483));

    for (uint32_t i = 0; i < 1025; i++) {
        uint32_t *slot = qhat_set(&trie, 0x40000400 - i);
        *slot = bswap32(i + 0x400);
        Z_ASSERT_EQ(i + 1, trie.root->entry_count);
        CHECK_TRIE;
    }
    PRINT_TRIE;

    for (uint32_t i = 0; i < 1025; i++) {
        const uint32_t *slot = qhat_get(&trie, i + 0x40000000);
        Z_ASSERT_EQ(*slot, bswap32(0x800 - i));
    }

    {
        uint32_t pos = 0;
        qhat_for_each_unsafe(en, &trie) {
            const uint32_t *slot = en.value;
            Z_ASSERT_EQ(en.key, pos + 0x40000000);
            Z_ASSERT_EQ(*slot, bswap32(0x800 - pos));
            pos++;
        }
        Z_ASSERT_EQ(pos, 1025u);
    }

    e_named_trace(3, "trie/test", "Removing key %x", 0x40000400 - 512);
    PRINT_TRIE;
    qhat_remove(&trie, 0x40000400 - 512, NULL);
    Z_ASSERT_EQ(1024u, trie.root->entry_count);
    for (uint32_t i = 0; i < 1025; i++) {
        qhat_128_t val;
        e_named_trace(3, "trie/test", "Removing key %x", 0x40000000 + i);
        CHECK_TRIE;
        qhat_remove(&trie, 0x40000000 + i, &val);
        Z_ASSERT_ZERO(val.h);
        if (i < 0x400 - 512) {
            Z_ASSERT_EQ(val.l, bswap32(0x800 - i));
            Z_ASSERT_EQ(1024u - (i + 1), trie.root->entry_count);
        } else
        if (i > 0x400 - 512) {
            Z_ASSERT_EQ(val.l, bswap32(0x800 - i));
            Z_ASSERT_EQ(1024u - i, trie.root->entry_count);
        } else {
            Z_ASSERT_ZERO(val.l);
            Z_ASSERT_EQ(1024u - 1 - i + 1, trie.root->entry_count);
        }
    }
    Z_ASSERT_EQ(0u, trie.root->entry_count);

    for (uint32_t i = 0; i < 1024; i++) {
        const void *slot = qhat_get(&trie, i + 0x40000001);
        Z_ASSERT_NULL(slot);
    }

    PRINT_TRIE;
    qps_snapshot(qps, NULL, 0, ^(uint32_t gen) { });
    qps_snapshot_wait(qps);

    qhat_destroy(&trie);
    Z_HELPER_END;
}

static int test_64(qps_t *qps, bool null)
{
    qps_handle_t htrie = qhat_create(qps, 8, null);
    qhat_t trie;

    qhat_init(&trie, qps, htrie);
    Z_ASSERT_NULL(qhat_get(&trie, 0));
    Z_ASSERT_NULL(qhat_get(&trie, 938483));

    for (uint32_t i = 0; i < 1025; i++) {
        uint64_t *slot = qhat_set(&trie, 0x40000400 - i);
        *slot = bswap64(i + 0x400);
        CHECK_TRIE;
    }
    PRINT_TRIE;

    for (uint32_t i = 0; i < 1025; i++) {
        const uint64_t *slot = qhat_get(&trie, i + 0x40000000);
        Z_ASSERT_EQ(*slot, bswap64(0x800 - i));
    }

    {
        uint32_t pos = 0;
        qhat_for_each_unsafe(en, &trie) {
            const uint64_t *slot = en.value;
            Z_ASSERT_EQ(en.key, pos + 0x40000000);
            Z_ASSERT_EQ(*slot, bswap64(0x800 - pos));
            pos++;
        }
        Z_ASSERT_EQ(pos, 1025u);
    }

    e_named_trace(3, "trie/test", "Removing key %x", 0x40000400 - 512);
    PRINT_TRIE;
    qhat_remove(&trie, 0x40000400 - 512, NULL);
    for (uint32_t i = 0; i < 1025; i++) {
        uint64_t val;
        e_named_trace(3, "trie/test", "Removing key %x", 0x40000000 + i);
        CHECK_TRIE;
        qhat_remove(&trie, 0x40000000 + i, &val);
        if (i != 0x400 - 512) {
            Z_ASSERT_EQ(val, bswap64(0x800 - i));
        } else {
            Z_ASSERT_ZERO(val);
        }
    }

    for (uint32_t i = 0; i < 1024; i++) {
        const void *slot = qhat_get(&trie, i + 0x40000001);
        Z_ASSERT_NULL(slot);
    }

    PRINT_TRIE;
    qhat_destroy(&trie);
    Z_HELPER_END;
}

static int test_32(qps_t *qps, bool null)
{
    qps_handle_t htrie = qhat_create(qps, 4, false);
    qhat_t trie;

    qhat_init(&trie, qps, htrie);
    Z_ASSERT_NULL(qhat_get(&trie, 0));
    Z_ASSERT_NULL(qhat_get(&trie, 938483));

    for (uint32_t i = 0; i < 1025; i++) {
        uint32_t *slot = qhat_set(&trie, 0x40000400 - i);
        *slot = bswap32(i + 0x400);
        CHECK_TRIE;
    }
    PRINT_TRIE;

    for (uint32_t i = 0; i < 1025; i++) {
        const uint32_t *slot = qhat_get(&trie, i + 0x40000000);
        Z_ASSERT_EQ(*slot, bswap32(0x800 - i));
    }

    {
        uint32_t pos = 0;
        qhat_for_each_unsafe(en, &trie) {
            const uint32_t *slot = en.value;
            Z_ASSERT_EQ(en.key, pos + 0x40000000);
            Z_ASSERT_EQ(*slot, bswap32(0x800 - pos));
            pos++;
        }
        Z_ASSERT_EQ(pos, 1025u);
    }

    e_named_trace(3, "trie/test", "Removing key %x", 0x40000400 - 512);
    PRINT_TRIE;
    qhat_remove(&trie, 0x40000400 - 512, NULL);
    for (uint32_t i = 0; i < 1025; i++) {
        uint32_t val;
        e_named_trace(3, "trie/test", "Removing key %x", 0x40000000 + i);
        CHECK_TRIE;
        qhat_remove(&trie, 0x40000000 + i, &val);
        if (i != 0x400 - 512) {
            Z_ASSERT_EQ(val, bswap32(0x800 - i));
        } else {
            Z_ASSERT_ZERO(val);
        }
    }

    for (uint32_t i = 0; i < 1024; i++) {
        const void *slot = qhat_get(&trie, i + 0x40000001);
        Z_ASSERT_NULL(slot);
    }

    PRINT_TRIE;
    qhat_destroy(&trie);
    Z_HELPER_END;
}

static int test_16(qps_t *qps, bool null)
{
    qps_handle_t htrie = qhat_create(qps, 2, null);
    qhat_t trie;

    qhat_init(&trie, qps, htrie);
    Z_ASSERT_NULL(qhat_get(&trie, 0));
    Z_ASSERT_NULL(qhat_get(&trie, 938483));

    for (uint32_t i = 0; i < 10000; i++) {
        uint16_t *slot = qhat_set(&trie, i + 50);
        *slot = i | 1;
        CHECK_TRIE;
    }
    PRINT_TRIE;

    if (null) {
        for (uint32_t i = 0; i < 50; i++) {
            Z_ASSERT_NULL(qhat_get(&trie, i));
        }
    }
    for (uint32_t i = 0; i < 10000; i++) {
        const uint16_t *slot = qhat_get(&trie, i + 50);
        Z_ASSERT_EQ(*slot, (uint16_t)i | 1);
    }

    {
        uint32_t i = 0;
        qhat_for_each_unsafe(en, &trie) {
            const uint16_t *slot = en.value;
            if (en.key < 50) {
                if (null) {
                    Z_ASSERT_NULL(slot);
                } else {
                    Z_ASSERT(slot == NULL || *slot == 0);
                }
            } else
            if (en.key < 10050) {
                Z_ASSERT_EQ(*slot, (uint16_t)i | 1);
                i++;
            } else {
                if (null) {
                    Z_ASSERT_NULL(slot);
                } else {
                    Z_ASSERT(slot == NULL || *slot == 0);
                }
            }
        }
        Z_ASSERT_EQ(i, 10000u);
    }

    qhat_destroy(&trie);
    Z_HELPER_END;
}

static int test_8(qps_t *qps, bool null)
{
    qps_handle_t htrie = qhat_create(qps, 1, null);
    qhat_t trie;

    qhat_init(&trie, qps, htrie);
    Z_ASSERT_NULL(qhat_get(&trie, 0));
    Z_ASSERT_NULL(qhat_get(&trie, 938483));

    for (uint32_t i = 0; i < 10000; i++) {
        uint8_t *slot = qhat_set(&trie, i + 50);
        *slot = i | 1;
        CHECK_TRIE;
    }
    PRINT_TRIE;

    if (null) {
        for (uint32_t i = 0; i < 50; i++) {
            Z_ASSERT_NULL(qhat_get(&trie, i));
        }
    }
    for (uint32_t i = 0; i < 10000; i++) {
        const uint8_t *slot = qhat_get(&trie, i + 50);
        Z_ASSERT_EQ(*slot, (uint8_t)i | 1);
    }

    {
        uint32_t i = 0;
        qhat_for_each_unsafe(en, &trie) {
            const uint8_t *slot = en.value;
            if (en.key < 50) {
                if (null) {
                    Z_ASSERT_NULL(slot);
                } else {
                    Z_ASSERT(slot == NULL || *slot == 0);
                }
            } else
            if (en.key < 10050) {
                Z_ASSERT_EQ(*slot, (uint8_t)i | 1, "error at %u", en.key);
                i++;
            } else {
                if (null) {
                    Z_ASSERT_NULL(slot, "error at %u", en.key);
                } else {
                    Z_ASSERT(slot == NULL || *slot == 0, "error at %u", en.key);
                }
            }
        }
        Z_ASSERT_EQ(i, 10000u);
    }

    qhat_destroy(&trie);
    Z_HELPER_END;
}

/* }}} */

Z_GROUP_EXPORT(qps_hat) {
    qps_t *qps;

    MODULE_REQUIRE(qps);

    if (qps_exists(z_grpdir_g.s)) {
        qps = qps_open(z_grpdir_g.s, "qps-hat", NULL);
    } else {
        qps = qps_create(z_grpdir_g.s, "qps-hat", 0755, NULL, 0);
    }
    assert (qps);

    Z_TEST(128, "128bits no null") { /* {{{ */
        Z_HELPER_RUN(test_128(qps, false));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(128_null, "128bits null") { /* {{{ */
        Z_HELPER_RUN(test_128(qps, true));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(128_null_zero, "128bits null zeros") { /* {{{ */
        Z_HELPER_RUN(test_zeros(qps, 16));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(64, "64bits no null") { /* {{{ */
        Z_HELPER_RUN(test_64(qps, false));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(64_null, "64bits null") { /* {{{ */
        Z_HELPER_RUN(test_64(qps, true));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(64_null_zero, "64bits null zeros") { /* {{{ */
        Z_HELPER_RUN(test_zeros(qps, 8));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(32, "32bits no null") { /* {{{ */
        Z_HELPER_RUN(test_32(qps, false));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(32_null, "32bits null") { /* {{{ */
        Z_HELPER_RUN(test_32(qps, true));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(32_null_zero, "32bits null zeros") { /* {{{ */
        Z_HELPER_RUN(test_zeros(qps, 4));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(16, "16bits no null") { /* {{{ */
        Z_HELPER_RUN(test_16(qps, false));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(16_null, "16bits null") { /* {{{ */
        Z_HELPER_RUN(test_16(qps, true));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(16_null_zero, "16bits null zeros") { /* {{{ */
        Z_HELPER_RUN(test_zeros(qps, 2));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(8, "8bits no null") { /* {{{ */
        Z_HELPER_RUN(test_8(qps, false));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(8_null, "8bits null") { /* {{{ */
        Z_HELPER_RUN(test_8(qps, true));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(8_null_zero, "8bits null zeros") { /* {{{ */
        Z_HELPER_RUN(test_zeros(qps, 1));
    } Z_TEST_END;

    /* }}} */
    Z_TEST(debug_print, "") { /* {{{ */
        t_scope;
        qps_handle_t htrie;
        qhat_t trie;
        const char *output_path;
        FILE *file;
        SB_1k(output);
        const char *exp_output_path;
        SB_1k(exp_output);

        Z_TEST_FLAGS("redmine_83283");

        htrie = qhat_create(qps, 4, false);
        qhat_init(&trie, qps, htrie);
        for (int i = 1; i < 43; i++) {
            uint32_t *v;

            v = qhat_set(&trie, i * 10);
            *v = i * 100;
        }
        for (int i = 1000000; i < 1010000; i++) {
            uint32_t *v;

            v = qhat_set(&trie, i);
            *v = i * 100;
        }

        output_path = t_fmt("%*pMqhat-debug-print.txt",
                            LSTR_FMT_ARG(z_tmpdir_g));
        file = fopen(output_path, "w");
        Z_ASSERT_P(file);
        qhat_debug_print_stream(&trie, QHAT_PRINT_KEYS, file);
        p_fclose(&file);

        Z_ASSERT_N(sb_read_file(&output, output_path));

        exp_output_path = t_fmt("%*pMtest-data/qhat/qhat-debug-print.txt",
                                LSTR_FMT_ARG(z_cmddir_g));
        Z_ASSERT_N(sb_read_file(&exp_output, exp_output_path),
                   "cannot read path `%s`", exp_output_path);

        Z_ASSERT_STREQUAL(output.data, exp_output.data);

        qhat_destroy(&trie);
    } Z_TEST_END;

    /* }}} */
    Z_TEST(compute_memory, "") { /* {{{ */
        qps_handle_t htrie;
        qhat_t trie;

        Z_TEST_FLAGS("redmine_83283");

        htrie = qhat_create(qps, 4, true);
        qhat_init(&trie, qps, htrie);
        for (int i = 0; i < 10000; i++) {
            uint64_t *v;

            v = qhat_set(&trie, i * 10000);
            *v = i + 1;
        }
        for (int i = 1000000; i < 1100000; i++) {
            uint32_t *v;

            v = qhat_set(&trie, i);
            *v = i * 100;
        }

        /* XXX The values below doesn't mean so much but the tests ensure we
         * don't change the QPS hat memory footprint or the behavior of the
         * functions that compute it without knowing. */
        Z_ASSERT_EQ(qhat_compute_memory(&trie), 622592ul);
        Z_ASSERT_EQ(qhat_compute_memory_overhead(&trie), 170136ul);
        qhat_destroy(&trie);
    } Z_TEST_END;

    /* }}} */
    Z_TEST(enumeration, "") { /* {{{ */
        t_scope;
        qps_handle_t htrie;
        qhat_t trie;
        qv_t(u32) keys;
        const int nb_keys = 5000;
        qhat_enumerator_t en;

        Z_TEST_FLAGS("redmine_83283");

        t_qv_init(&keys, nb_keys);
        htrie = qhat_create(qps, 4, false);
        qhat_init(&trie, qps, htrie);
        for (int i = 0; i < nb_keys; i++) {
            uint32_t key;
            uint32_t *v;

            key = mem_hash32(&i, sizeof(i));
            v = qhat_set(&trie, key);
            *v = key;
            qv_append(&keys, key);
        }
        dsort32(keys.tab, keys.len);
        qv_clip(&keys, uniq32(keys.tab, keys.len));

        /* Check that we can iterate on all the entries using 'next'. */
        en = qhat_get_enumerator(&trie);
        tab_for_each_entry(key, &keys) {
            Z_ASSERT(!en.end);
            Z_ASSERT_EQ(en.key, key);
            Z_ASSERT_EQ(*(uint32_t *)en.value, key);
            Z_ASSERT(qhat_enumerator_get_value(&en) == en.value);
            qhat_enumerator_next(&en, true, true);
        }
        Z_ASSERT(en.end);

        /* Check that we can iterate on all the entries using 'go_to'. */
        en = qhat_get_enumerator(&trie);
        tab_for_each_entry(key, &keys) {
            qhat_enumerator_go_to(&en, key, true, true);
            Z_ASSERT(!en.end);
            Z_ASSERT_EQ(en.key, key);
            Z_ASSERT_EQ(*(uint32_t *)en.value, key);
        }

        qhat_clear(&trie);
        qhat_destroy(&trie);
    } Z_TEST_END;

    /* }}} */
    Z_TEST(nullable_trie_nr, "") { /* {{{ */
        qps_handle_t htrie;
        qhat_t trie;
        qhat_enumerator_t en;

        Z_TEST_FLAGS("redmine_83666");

        htrie = qhat_create(qps, 4, true);
        qhat_init(&trie, qps, htrie);

        for (int i = 1; i < 50; i++) {
            *(uint32_t *)qhat_set(&trie, i) = i;
        }
        en = qhat_get_enumerator_at(&trie, 40);
        for (int i = 50; i < 100; i++) {
            *(uint32_t *)qhat_set(&trie, i) = i;
        }

        for (uint32_t key = 40; key < 100; key++) {
            /* FIXME The key goes directly from 49 to 64 but all the bits
             * between those two keys were supposed to be set. It means that
             * the QPS bitmap enumerator isn't "safe". As a consequence, the
             * QPS hat enumerator for nullable entries isn't "safe" either,
             * even when the "safe" parameter is used. */
            if (key == 50) {
                key = 64;
            }
            Z_ASSERT(!en.end);
            Z_ASSERT_EQ(en.key, key);
            qhat_enumerator_next(&en, false, true);
        }

        Z_ASSERT(en.end);
    } Z_TEST_END;

    /* }}} */

    qps_close(&qps);
    MODULE_RELEASE(qps);
} Z_GROUP_END

/* LCOV_EXCL_STOP */
