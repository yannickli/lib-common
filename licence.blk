/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "z.h"
#include <net/if.h>
#ifdef OS_LINUX
#include <net/if_arp.h>
#endif
#include <netinet/in.h>
#include <sys/ioctl.h>

#include "conf.h"
#include "licence.h"
#include "datetime.h"
#include "hash.h"
#include "property.h"
#include "core.iop.h"

#define ATTRS
#define F(x)  x
#include "licence-host-check.in.c"
#undef F
#undef ATTRS

/* Conf Licences {{{ */

int trace_override;

int list_my_macs(char *dst, size_t size)
{
    struct if_nameindex *iflist;
    struct if_nameindex *cur;
    int s = -1;
    int written, ret = 0;
    const char *sep = "";

    iflist = if_nameindex();
    if (!iflist) {
        return false;
    }

    s = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
    if (s < 0) {
        if_freenameindex(iflist);
        return false;
    }
    for (cur = iflist; cur->if_index; cur++) {
        byte mac[6];

        if (get_mac_addr(s, cur, mac) < 0) {
            continue;
        }
        written = snprintf(dst, size, "%s%02X:%02X:%02X:%02X:%02X:%02X",
                           sep, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
        sep = ",";
        if (written < 0 || (size_t)written >= size) {
            ret = 1;
            break;
        }
        dst += written;
        size -= written;
    }
    close(s);
    if_freenameindex(iflist);
    return ret;
}

static int property_cmp(property_t * const *a, property_t * const *b)
{
    return strcmp((*a)->name, (*b)->name);
}

int licence_do_signature(const conf_t *conf, char dst[65])
{
    int version;
    char buf[32];
    const char *p;
    char c;
    const char *blacklisted[] = {
        "signature",
        "encryptionKey",
        NULL
    };
    qv_t(props) tosign;
    const conf_section_t *s;
    int k0, k1, k2, k3;
    int len;
    sha2_ctx  ctx;

    version = conf_get_int(conf, "licence", "version", -1);
    if (version != 1) {
        return -1;
    }

    s = conf_get_section_by_name(conf, "licence");
    if (!s) {
        return -1;
    }

    qv_init(&tosign);
    qv_copy(&tosign, &s->vals);

    tab_for_each_pos_safe(i, &tosign) {
        property_t *prop = tosign.tab[i];

        for (const char **bl = blacklisted; *bl; bl++) {
            if (strequal(prop->name, *bl)) {
                qv_remove(&tosign, i);
                break;
            }
        }
    }
    qv_qsort(&tosign, property_cmp);

    /* XXX: version 1 is weak.
     */
    k0 = 0;
    k1 = 28;
    k2 = 17;
    k3 = 11;
    sha2_starts(&ctx, 0);
    for (int i = 0; i < tosign.len; i++) {
#define DO_SIGNATURE(content)                                       \
        len = strlen(content);                                      \
        k0 += len;                                                  \
        for (p = content; *p; p++) {                                \
            c = *p;                                                 \
            /* Signature is case-insensitive and does not sign non  \
             * 'usual' chars. We don't want to get into trouble     \
             * because the format of a field slightly changes.      \
             * */                                                   \
            if ('A' <= c && c <= 'Z') {                             \
                c = c - 'A' + 'a';                                  \
            } else                                                  \
            if (('a' <= c && c <= 'z')                              \
            ||  ('0' <= c && c <= '9')                              \
            || c == ':' || c == '-' || c == '+' || c == '*') {      \
                /* use it for signature */                          \
                /* XXX: '-' is very important : sms_max_rate = -1   \
                 * means unlimited, whereas '1' means 1/s ! */      \
                                                                    \
            } else {                                                \
                /* skip */                                          \
                continue;                                           \
            }                                                       \
            k1 = (k1 * c + 371) & 0xFFFF;                           \
            k2 = (k3 * 21407 + c) & 0xFFFF;                         \
            k3 = (k2 * 17669 + c) & 0xFFFF;                         \
        }                                                           \
        sha2_update(&ctx, content, len);

        if (!tosign.tab[i]->value) {
            continue;
        }
        DO_SIGNATURE(tosign.tab[i]->name);
        sha2_update(&ctx, ":", 1);
        DO_SIGNATURE(tosign.tab[i]->value);
    }
    k0 = (k0 * 3643) & 0xFFFF;
    len = snprintf(buf, sizeof(buf), "%04X%04X%04X%04X", k0, k1, k2, k3);
    sha2_update(&ctx, buf, len);
    sha2_finish_hex(&ctx, dst);
    qv_wipe(&tosign);
//    printf("signature = %s\n", dst);
    return 0;
}

bool licence_check_expiration_ok(const conf_t *conf)
{
    const char *expires = conf_get_raw(conf, "licence", "expires");
    struct tm t;

    if (!expires)
        return false;

    p_clear(&t, 1);
    t.tm_isdst = -1;

    if (strtotm(expires, &t))
        return false;

    return mktime(&t) > time(NULL);
}

bool licence_check_signature_ok(const conf_t *conf)
{
    char lic_computed[65];
    const char *lic_inconf;

    lic_inconf = conf_get_raw(conf, "licence", "signature");
    if (!lic_inconf)
        return false;

    if (licence_do_signature(conf, lic_computed)) {
        return false;
    }

    return strequal(lic_inconf, lic_computed);
}

bool licence_check_general_ok(const conf_t *conf)
{
    if (!licence_check_signature_ok(conf)) {
        return false;
    }
    if (!licence_check_expiration_ok(conf)) {
        return false;
    }
    if (conf_get_int(conf, "licence", "version", -1) != 1) {
        return false;
    }
    return true;
}

bool licence_check_specific_host_ok(const conf_t *conf)
{
    pstream_t ps, out;
    const char *p;

    /* cpu_signature is optional in licence section : If it does not
     * appear, we do not check it. */
    p = conf_get_raw(conf, "licence", "cpu_signature");
    if (p) {
        uint32_t cpusig;

        if (read_cpu_signature(&cpusig)) {
            return false;
        }

        ps = ps_initstr(p);
        while (!ps_done(&ps)) {
            uint32_t sig;

            if (ps_get_ps_chr_and_skip(&ps, ',', &out) < 0) {
                out = ps;
                ps = ps_init(NULL, 0);
            }
            ps_trim(&out);
            errno = 0;
            sig = strtol(out.s, &out.s, 0);
            if (errno || !ps_done(&out)) {
                continue;
            }
            if (sig == cpusig) {
                goto cpu_ok;
            }
        }
        return false;
    }

  cpu_ok:
    p = conf_get_raw(conf, "licence", "mac_addresses");
    if (!p) {
        return false;
    }
    ps = ps_initstr(p);
    while (!ps_done(&ps)) {
        char buf[64];

        if (ps_get_ps_chr_and_skip(&ps, ',', &out) < 0) {
            out = ps;
            ps = ps_init(NULL, 0);
        }
        ps_trim(&out);
        pstrcpylen(buf, sizeof(buf), out.s, ps_len(&out));
        if (is_my_mac_addr(buf)) {
            goto mac_ok;
        }
    }
    return false;

  mac_ok:
    return true;
}

bool licence_check_host_ok(const conf_t *conf)
{
    if (licence_check_general_ok(conf) == false) {
        return false;
    }
    return licence_check_specific_host_ok(conf);
}


#include <sched.h>

int list_my_cpus(char *dst, size_t size)
{
#ifdef __linux__
    /* OG: Should use cpu_set_t type and macros ? */
    /* OG: Should check return value of these system calls */
    int i = 0, pos = 0, res = -1;
    cpu_set_t oldmask, newmask;

    if (sched_getaffinity(0, sizeof(oldmask), &oldmask))
        goto exit;

    for (i = 0; i < ssizeof(oldmask) * 8; i++) {
        uint32_t cpusig;

        /* Only enumerate cpus enabled by default */
        if (!CPU_ISSET(i, &oldmask))
            continue;
        CPU_ZERO(&newmask);
        (void)CPU_SET(i, &newmask);

        /* Tell linux we prefer to run on CPU number i. */
        if (sched_setaffinity(0, sizeof(newmask), &newmask))
            goto exit;

        /* OG: this might not be necessary. */
        usleep(100);

        if (read_cpu_signature(&cpusig))
            goto exit;

        pos += snprintf(dst + pos, size - pos, "%s0x%08X",
                        pos ? "," : "", cpusig);
    }
    res = 0;

  exit:
    sched_setaffinity(0, sizeof(oldmask), (void*)&oldmask);
    return res;
#else
    uint32_t cpusig;

    if (!read_cpu_signature(&cpusig)) {
        snprintf(dst, size, "0x%08X", cpusig);
        return 0;
    }
    return -1;
#endif
}

/* }}} */
/* IOP Licences {{{ */

#define ATTRS
#define F(x)  x
#include "licence-expiry-check.in.c"
#undef F
#undef ATTRS

__must_check__
licence_expiry_t licence_check_module_expiry(const core__licence_module__t *e)
{
    time_t now = lp_getsec();
    time_t expiration, soon_expiration;

    if (!e->expiration_date.s) {
        return LICENCE_OK;
    }
    expiration = lstrtotime(e->expiration_date);
    if (!expect(expiration >= 0)) {
        return LICENCE_INVALID_EXPIRATION;
    }
    soon_expiration = expiration - e->expiration_warning_delay;

    if (soon_expiration <= now && now < expiration) {
        return LICENCE_EXPIRES_SOON;
    } else
    if (expiration <= now) {
        return LICENCE_HARD_EXPIRED;
    }
    return LICENCE_OK;
}

int licence_check_modules(const core__licence__t *licence)
{
    t_scope;
    static bool first_call = true;
    qh_t(lstr) fullnames;

    /* The goal of this code that is only executed the first time that
     * function is called is to check that there is not duplicate values of
     * field `name` in child classes of core.LicenceModule.
     */
    if (unlikely(first_call)) {
        QH(lstr, static_names);
        qh_t(lstr) *static_names_p = &static_names;

        first_call = false;
        iop_for_each_registered_classes(^(const iop_struct_t *child) {
            if (iop_class_is_a(child, &core__licence_module__s)
            && !child->class_attrs->is_abstract)
            {
                const lstr_t *name;

                name = &iop_get_cvar(&child, LSTR("name"))->s;
                if (qh_add(lstr, static_names_p, name) < 0) {
                    e_fatal("duplicated static name `%*pM` in the children "
                            "of core.LicenceModule", LSTR_FMT_ARG(*name));
                }
            }
        });
        qh_wipe(lstr, &static_names);
    }

    t_qh_init(lstr, &fullnames, licence->modules.len);

    tab_for_each_entry(e, &licence->modules) {
        lstr_t name = iop_get_cvar(e, LSTR("name"))->s;
        bool can_expire = iop_get_cvar(e, LSTR("canExpire"))->b;

        if (qh_add(lstr, &fullnames, &e->__vptr->fullname) < 0) {
            return e_error("licence module `%*pM` declared twice in "
                           "the licence file", LSTR_FMT_ARG(name));
        }
        if (e->expiration_date.s && !can_expire) {
            return e_error("licence module `%*pM` cannot expire",
                           LSTR_FMT_ARG(name));
        }
    }

    return 0;
}

__must_check__
const struct core__licence_module__t *
licence_get_module_desc(const struct core__licence__t *licence,
                        const iop_struct_t *mod)
{
    tab_for_each_entry(e, &licence->modules) {
        if (iop_obj_is_a_desc(e, mod)) {
            return e;
        }
    }
    return NULL;
}

__must_check__
bool licence_is_module_activated_desc(const struct core__licence__t *licence,
                                      const iop_struct_t *mod)
{
    const struct core__licence_module__t *e;
    time_t exp;

    e = licence_get_module_desc(licence, mod);
    if (!e) {
        return false;
    }

    if (!e->expiration_date.s) {
        return true;
    }

    exp = lstrtotime(e->expiration_date);
    if (!expect(exp >= 0)) {
        return false;
    }

    return exp >= lp_getsec();
}

/* }}} */
/* {{{ Activation tokens */

static void hash_crc64(void *ctx, const void *input, ssize_t ilen)
{
    *(uint64_t *)ctx = icrc64(*(uint64_t *)ctx, input, ilen);
}

#define BIN_TKN_TS_SZ  3

static uint64_t
activation_token_hash(const char buf[BIN_TKN_TS_SZ],
                      const core__licence__t *licence,
                      const char noise[sizeof(uint32_t)])
{
    uint64_t hash = 0;

    iop_hash(&core__licence__s, licence, hash_crc64, &hash,
             IOP_HASH_SKIP_MISSING | IOP_HASH_SKIP_DEFAULT);
    hash = icrc64(hash, noise, sizeof(uint32_t));
    return icrc64(hash, buf, BIN_TKN_TS_SZ);
}

int t_parse_activation_token(lstr_t rawtoken, const core__licence__t *licence,
                             time_t *product_exp_out, time_t *token_exp_out,
                             core__activation_token__t *token, sb_t *err)
{
    SB_1k(buf);
    uint8_t *val;
    int value;
    const char *error;
    time_t signature_ts = OPT_DEFVAL(licence->signature_ts, 0);
    time_t product_exp;
    time_t token_exp;
    bool hash_valid = false;

    if (!signature_ts) {
        error = "no signature timestamp";
        goto error;
    }

    if (ACTIVATION_TOKEN_LENGTH != rawtoken.len) {
        error = "invalid token length";
        goto error;
    }

    if (sb_add_unb64(&buf, rawtoken.data, ACTIVATION_TOKEN_LENGTH) < 0) {
        error = "cannot read token";
        goto error;
    }
    val = (uint8_t *)buf.data;
    if (licence) {
        be64_t stored_hash_be;
        uint64_t stored_hash;
        uint64_t hash;
        char *noisep = (char *)val + BIN_TKN_TS_SZ + sizeof(be64_t);

        memcpy(&stored_hash_be, val + BIN_TKN_TS_SZ, sizeof(be64_t));
        stored_hash = be_to_cpu64(stored_hash_be);
        hash = activation_token_hash((char *)val, licence, noisep);
        hash_valid = (stored_hash == hash);
    }
    val[0] ^= val[BIN_TKN_TS_SZ + sizeof(be64_t)];
    val[1] ^= val[BIN_TKN_TS_SZ + sizeof(be64_t) + 1];
    val[2] ^= val[BIN_TKN_TS_SZ + sizeof(be64_t) + 2];
    value = (val[0] << 4) | ((val[1] >> 4) & 0xF);
    product_exp = localtime_addday(signature_ts, value);
    value = ((val[1] & 0xF) << 8) | val[2];
    token_exp = localtime_addday(signature_ts, value);

    if (product_exp_out) {
        *product_exp_out = product_exp;
    }
    if (token_exp_out) {
        *token_exp_out = token_exp;
    }
    if (token) {
        char *product_exp_date_str = t_new_raw(char, 21);

        if (!expect(strftime(product_exp_date_str, 20, "%d-%b-%Y",
                             localtime(&product_exp)) > 0))
        {
            error = "cannot format product expiration date";
            goto error;
        }
        token->expiration_date = LSTR(product_exp_date_str);

        token->token = rawtoken;
    }
    if (!hash_valid) {
        if (err) {
            sb_adds(err, "invalid activation token signature");
            /* Note: it's not really a signature, just a hash. */
        }
        return -2;
    }
    return 0;

  error:
    if (err) {
        sb_adds(err, error);
    }
    return -1;
}

int t_format_activation_token(const core__signed_licence__t *licence,
                              time_t product_exp, time_t token_exp,
                              core__activation_token__t *token, sb_t *err)
{
    time_t signature_ts = OPT_VAL(licence->licence->signature_ts);
    int pe_diff = time_diff_days(signature_ts, product_exp);
    int te_diff = time_diff_days(signature_ts, token_exp);
    SB_1k(rawtoken);
    sb_b64_ctx_t b64ctx;
    char buf[BIN_TKN_TS_SZ];
    uint32_t noise = rand();
    const char *noisep = (char *)&noise;
    uint64_t cpuhash = 0;
    be64_t behash;
    char *product_exp_date_str = t_new_raw(char, 21);

    sb_add_b64_start(&rawtoken, 16, -1, &b64ctx);

    /* Put 12 bits from pt_diff and 12 from tt_diff. They are
     * obfuscated with the trailing noise. */
    if (signature_ts > product_exp || signature_ts > token_exp) {
        sb_adds(err, "signature timestamp is newer than some expiration");
        return -1;
    }
    if (pe_diff <= 0 || pe_diff >= (1 << 12)
    ||  te_diff <= 0 || te_diff >= (1 << 12))
    {
        sb_adds(err, "activation tokens cannot handle such expirations");
        return -1;
    }
    buf[0] = noisep[0] ^ ((pe_diff >> 4) & 0xFF);
    buf[1] = noisep[1] ^ (((pe_diff & 0xF) << 4) | ((te_diff >> 8) & 0xF));
    buf[2] = noisep[2] ^ (te_diff & 0xFF);
    sb_add_b64_update(&rawtoken, buf, BIN_TKN_TS_SZ, &b64ctx);

    /* Put the hash of the licence + noise + expirations */
    cpuhash = activation_token_hash(buf, licence->licence, noisep);
    behash = cpu_to_be64(cpuhash);
    sb_add_b64_update(&rawtoken, &behash, sizeof(behash), &b64ctx);

    /* Put some noise. */
    sb_add_b64_update(&rawtoken, &noise, sizeof(noise), &b64ctx);
    sb_add_b64_finish(&rawtoken, &b64ctx);

    if (!expect(rawtoken.len == ACTIVATION_TOKEN_LENGTH)) {
        return -1;
    }

    token->token = t_lstr_dup(LSTR_SB_V(&rawtoken));
    if (!expect(strftime(product_exp_date_str, 20, "%d-%b-%Y",
                         localtime(&product_exp)) > 0))
    {
        return -1;
    }
    token->expiration_date = LSTR(product_exp_date_str);
    return 0;
}

#undef BIN_TKN_TS_SZ

/* }}} */
/* tests {{{ */

static int find_local_mac(char buf[static 6 * 3])
{
    struct if_nameindex *iflist;
    int fd;
    bool found = false;

    Z_ASSERT(iflist = if_nameindex());
    Z_ASSERT_N(fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP));
    for (int i = 0; iflist[i].if_index; i++) {
        byte mac[6];

        if (get_mac_addr(fd, &iflist[i], mac) < 0) {
            continue;
        }
        found = true;
        snprintf(buf, 6 * 3, "%02X:%02X:%02X:%02X:%02X:%02X",
                 mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
        break;
    }
    Z_ASSERT(found, "no local interface ?!");
    close(fd);
    if_freenameindex(iflist);

    Z_HELPER_END;
}

Z_GROUP_EXPORT(licence)
{
    char buf[128];

    Z_TEST(list_my_macs, "check_list_my_macs") {
        Z_ASSERT_ZERO(list_my_macs(buf, sizeof(buf)));
    } Z_TEST_END;

    Z_TEST(is_my_mac_addr, "") {
        Z_HELPER_RUN(find_local_mac(buf));
        Z_ASSERT(is_my_mac_addr(buf));
    } Z_TEST_END;

    Z_TEST(signature_ok, "") {
        conf_t *conf;

        Z_ASSERT_N(chdir(z_cmddir_g.s));

        Z_ASSERT(conf = conf_load("samples/licence-v1-ok.conf"));
        Z_ASSERT(licence_check_signature_ok(conf));
        conf_delete(&conf);

        Z_ASSERT(conf = conf_load("samples/licence-v1-ko.conf"));
        Z_ASSERT(!licence_check_signature_ok(conf));
        conf_delete(&conf);
    } Z_TEST_END;

    Z_TEST(expiration_ok, "") {
        conf_t *conf;

        Z_ASSERT_N(chdir(z_cmddir_g.s));

        Z_ASSERT(conf = conf_load("samples/licence-v1-ok.conf"));
        Z_ASSERT(licence_check_expiration_ok(conf), "licence-test-ok failed to pass");
        conf_delete(&conf);

        Z_ASSERT(conf = conf_load("samples/licence-v1-ko.conf"));
        Z_ASSERT(!licence_check_expiration_ok(conf), "licence-test-ko passed");
        conf_delete(&conf);
    } Z_TEST_END;
} Z_GROUP_END

/* }}} */
