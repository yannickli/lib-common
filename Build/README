How to write an Intersec Makefile
=================================

Introduction
------------

Our build system is goal and sources driven: you just list the goals, and
the sources each of them needs. There is a full set of magic variables for
this purpose.


About Variables
---------------
// {{{

Standard Variables
~~~~~~~~~~~~~~~~~~

Makefiles are standard Makefiles in which you can define variables as you
could do in any Makefile:
+
----------------------------------
libs = libcommon.a
----------------------------------

By default, variables are file local and can only be used in the current
Makefile. However, you can define a set of variables to be exported using the
`_EXPORT` variables:
+
----------------------------------
_EXPORT = libs
----------------------------------
+
In this example, `myvar` becomes accessible from other files as `path/myvar`
to be used in magic variables (such as `_SOURCES` variables) and is subject to
double expansion. As a consequence it must be written with a double `$`:
+
----------------------------------
_EXPORT = libs

libs = lmsbase.a \
       $$(libcommon/libs)

lms-ep_SOURCES = ep-main.blk \
                 $$(lms/libs)
----------------------------------

Magic Variables
~~~~~~~~~~~~~~~

* `$/` is set to the absolute path to the root of the source tree with a
  trailing slash. It has to be used to give a path to static libraries you
  depend on, e.g.:
+
----------------------------------
something_SOURCES = \
	...                      \
	$/lib-common/libcommon.a \
        ...
----------------------------------

* `$!` is set to the absolute path to the build directory with a trailing
  slash, but its use is discouraged, it may be removed at some point.

* `$~` is the name of the build directory with a trailing slash, basically
  `$!` is equal to `$/$~`.


Variables with side effects
~~~~~~~~~~~~~~~~~~~~~~~~~~~

As a general rule, magic variables with side effects use a suffix comprising
an underscore (`_`) and some capital letters. The prefix would be the target
they have a side effect on, no prefix means that the side effect is global to
the local directory.

All these variables _must_ be defined with `=`, not with `:=`.

// }}}

List of variables with side effects
-----------------------------------
// {{{

Per directory variables
~~~~~~~~~~~~~~~~~~~~~~~

At the moment, the following set of variables are used at the directory level:

`_CFLAGS`::
        To force some `CFLAGS` to the local directory goals.

`_LDFLAGS`::
        To force some `LDFLAGS` to the local directory goals.

`_IOPINCPATH`::
        To add some path in the include path of the IOPC.

`_IOPJSONPATH`::
        To specify the directory in which IOP-JSON files are generated.

`_IOPCLASSRANGE`::
        To specify a class ids range that declared IOP classes must respect.
        Format is `min-max`.

`_NOCHECK`::
        To disable checks to the local directory goals.

`_DEPENDS`::
        This variable holds a list of local targets that must be remade before
        doing anything else automatic (meaning that it's not honoured for
        local rules, you must enforce that manually) in that directory.

`CLEANFILES`::
        This holds the list of files (or directories, necessarily with a
        trailing slash) that must be removed on clean.

`DISTCLEANFILES`::
        This holds the list of files (or directories, necessarily with a
        trailing slash) that must be removed on distclean.

Defining new goals
~~~~~~~~~~~~~~~~~~

The following suffixes are used to define goals of specific kinds:

`_PROGRAMS`::
        List of executable programs built for this directory
        (was `__EXE__` before).

`_LIBRARIES`::
        Static libraries (`.a` archives) (was `__LIB__` before).

`_SHARED_LIBRARIES`::
        Shared objects (`.so` files) (was `__SO__` before).

`_DATAS`::
        A target, named with its extension. The generation is done in-tree,
        and must be derived directly or indirectly from the `_SOURCES` that
        come with it.

`_DOCS`::
        List of documentations to be generated for this directory. Currently
        this only handles the generation of `.pdf` files. The generation is
        derived from the the `_SOURCES` that come with it. If the
        list of source is empty, the build system will suppose the source file
        is an asciidoc file with the same name as the generated PDF.

`_CSS`::
        List of css targets to be generated. This can be used to generate a
        `.css` file from meta-files such as `.less`. This requires both a
        `_SOURCES` list and a `_DESTDIR` directory in which the generated file
        should be written.

`_JS`::
       List of js targets to be generated. This can be used to compile the
       javascript using `r.js` into a prodable version. This requires both a
       `_SOURCES` that contains a list of directories and a `_CONFIG` that
       specifies the configuration file for `r.js`. And an optional `_MINIFY`
       that contains javascript files to compress.

`_JARS`::
       List jars targets to be generated. This can be used to compile and
       jar together several Java source files. This requires a
       `_SOURCES` containing the Java source files. An optional  `_CLASSPATH`
       can be added to specify the classpath to use when compiling the source
       files.

The build system doesn't support any other kind of goal yet, though you can
add local rules (FIXME: add some doc about how to do that).

The prefixes are not used yet, except to define new build 'overlays',
so it is wise to use them consistently over the source tree.


Per Goal Variables
~~~~~~~~~~~~~~~~~~

Each goal supports a complete set of variables, prefixed with the goal name.
All the following work for any kind of goal:

`_SOURCES`::
        This variable has the list of sources.  We support at the time of the
        writing: .h, .c, .tokens, .fc, .farch, .l, .a, .wa, .ld for binary
        generation, .adoc, .xml for doc generation (only one source per
        documentation is supported).
+
Note that anything that is put in that variable, in a relative way to the
current directory, is added to the order only depends chain of your goal even
if it' is not an understood extension. Though if it is not a real “source” for
the goal, the use of `goal_DEPENDS` is the proper way.
+
Also, in-tree generated files are built first for this target, you don't need
to do anything special about it.

`_LINKER`::
        This variable allow to override the command used to link. Usually this
        variable is set to `$(CXX)` when the program or library is a c++ one.

`_LDFLAGS`::
        This variable holds the list of additional link flags to pass to the
        link command.

`_CFLAGS`::
        This variable holds the additional C compilation flags to use for
        this goal.

`_IOPINCPATH`::
        This variable adds additional directories to the include path
        of the IOPC.

`_IOPJSONPATH`::
        This variable specifies the directory in which IOP-JSON files are
        generated.

`_IOPCLASSRANGE`::
        To specify a class ids range that declared IOP classes must respect.
        Format is `min-max`.

`_NOCHECK`::
        To disable checks when building this target.

`_DEPENDS`::
        This variable holds a number of other goals (relative to the
        Makefile's directory) that must be remade before remaking this goal.
+
Usual need arise when you use a local shared object that isn't listed in the
`_SOURCES`, and that you may need to redo for builds to succeed (if you add a
symbol in a `.so` and that a target uses it, link will fail is the `.so` isn't
rebuilt first).


NOTE: as a general rule any variable ending with `FLAGS` is kept and can be
reused in the build system to implement new kinds of goals.


For shared libraries (`_SHARED_LIBRARIES`) there is also:

`_SOVERSION`::
        This variable is mandatory for non plugins, though the build system
        won't enforce that (because of plugins).
+
This variable holds a list of up to two numbers. The first one will be used to
build the `SONAME` of the library, the second one is appended as a _build_
version.
+
For example, if you have `libfoo_SOVERSION = 1.2 3.4` then it will generate
the `libfoo.so.1.2.3.4` shared library, with a soname of `libfoo.so.1.2.3.4`.
And the symlinks `libfoo.so.1.2` and `libfoo.so` will be created pointing to
`libfoo.so.1.2.3.4` (the former is used for runtime, the latter for build
time).


For documentations, (`_DOCS`) you can also use:

`_DBLATEXFLAGS`::
        This variable holds a list of parameters to be passed to the
        `dblatex`


Per Source Variables
~~~~~~~~~~~~~~~~~~~~

There are a few variables that have side effects and that can be used at the
file level:

`_DEPENDS`::
        Any source file supports this variable to define goals that must be
        remade before this source is ever used to produce new files.
+
For example, for a lexer `mylexer.l`, `mylexer.l_DEPENDS` would hold goals
that are remade before `mylexer.c` is produced, and `mylexer.c_DEPENDS` goals
that are remade before the lexer is compiled.

`_CFLAGS` on `.c` files::
        For `.c` files, this variable holds additional C compilation flags to
        be used when this is built. For autogenerated `.c` files (e.g.
        lexers), the name of the generated souce must be used.
+
Example: `something.c_CFLAGS = -Wno-error`

`_NOCHECK` on `.c` files::
        To disable checks when building this C file.


`_IOPINCPATH` on `.iop` files::
        To add directories to the include path of the IOPC.

`_IOPJSONPATH` on `.iop` files::
        To specify the directory in which IOP-JSON file is generated.

`_IOPCLASSRANGE` on `.iop` files::
        To specify a class ids range that declared IOP classes must respect.
        Format is `min-max`.

For documentation sources, (`_DOCS`) you can also use:

`_ASCIIDOCFLAGS`::
        This variable holds a list of parameters to be passed to the
        `asciidoc` such as variable definitions (+-a var_name=value+).

Exported variables

// }}}

About Goals
-----------
// {{{

Exported Goals
~~~~~~~~~~~~~~

The build system automatically exports goals for:

* in-tree generated files (like lexers) supposed to be arch-independant;

* goals generated through goals variables (programs, libraries, ...).


Local Goals
~~~~~~~~~~~

It is possible to define any local goal you want, the build system will find
them, and make them available from it.

You can use local rule names in `_DEPENDS` variables, the build system will
recurse (old-way) in your directory and call it. If it in turn needs a
build-system exported rule, it will recurse (old-way) into the build-system
again, and so on. This has many drawbacks, so consider extending the
build-system if you need a new class of such rules often.

You must not use targets starting with `__`, these are magic to the
build-system and will be ignored. It is not possible to use the `clean` target
either (see Hookable Goals, and the `CLEANFILES` variable).


Hookable Goals
~~~~~~~~~~~~~~

The build-system defines three rules you can hook into:

`all::`::
        This rule is the default rule run if no argument is passed to make.
        You can add local things to be done here. Though it is discouraged to
        do so. (see `toplevel` goal).

`distclean::`::
        This is probably the most useful hook. When distclean is run (this
        rule is global, and it's the same for any directory you run it from),
        commands that you put there are run for any Makefile that extends it.
        Note that for simple things, `DISTCLEANFILES` is probably better suited.

In addition to these, the build-system provides a way to run a command when
make is run without arguments from a local directory, and only in this case
(if you run make from a subdirectory this goal won't be done):

`toplevel:`::
        This target can depend upon other (probably local, but anything works)
        goals that must be done when the user runs `make` from the same
        directory.
+
You can also define commands to be run from that target like any normal make
goal.
+
The use cases are e.g. to make the target that rebuilds documentation be the
default when you are running make from the `Documentation/` directory of your
project.

`doc:`::
        This target can be used to add specific documentation rules in a
        Makefile. The build system automatically generate a `doc` goal that
        build the `_DOCS` target. You can some tasks to that `doc` by adding
        a `doc:` in your local Makefile.

`www::`::
		This target can be used to generate web specific files. The build
		system automatically generates the css and javascript files goal that
		build the `_CSS' and `_JS` target. You can add some tasks to that
		`www` by adding `www::` in your local Makefile.

// }}}

Things to know
--------------
// {{{

SUBDIR detection
~~~~~~~~~~~~~~~~

The build system guesses where to “recurse” following chains of Makefiles that
include Build/base.mk. If you want to use the build system in a hierarchy of
directories looking like:

----------------------------------
a/b/c
----------------------------------

You must have the following Makefiles (even containing only the
`include ../../Build/base.mk` line):

----------------------------------
Makefile
a/Makefile
a/b/Makefile
a/b/c/Makefile
----------------------------------


Environment variables
~~~~~~~~~~~~~~~~~~~~~

`L`, `LINEAR`::
        The build-system automatically uses parallel build, this can be
        disabled by setting the environment variable `$L` or `$LINEAR`.

`V`, `VERBOSE`::
        The build-system is usually quite silent. You can set `$V` or
        `$VERBOSE` to change that.

`P`, `PROFILE`::
        The build-system can use different _profiles_ for the build (debug
        build, usual devel build, production build, ...). Profiles are defined
        toplevel in the source tree, and their use can be chosen through `$P`
        or `$PROFILE`. (`$BUILDFOR` is also supported for backward
        compatibility).
+
Example: `make P=debug some-target` will rebuild some-target with `CFLAGS`
forced to `-O0 -fno-inlines -Wno-uninitialized`.

`M`, `MONOCHROME`::
        The build-system in silent mode echoes commands using some color.
        Setting `$M`, `$MONOCHROME` (or for backward compatibility `$NOCOLOR`)
        disables that.

`NOCHECK`::
        The build-system doesn't run "CHECK" targets (mostly clang at the
        time).

`NOASSERT`::
        The build-system enable the assertions in compiled code if that variable
        is set to 1 and disable them is set to any other value. Note that by
        default, assertions are enabled in profiles `default` and `debug` and
        disabled in profile `release`. Disabling assertion is done using the
        insertion of the `DNDEBUG` flag. As a consequence, `NOASSERT` also
        enable/disable all the code conditionally built based on `NDEBUG` value.

`NOLINK`::
        Do not perform links (to gain speed on some builds).

// }}}

// vim:filetype=asciidoc:tw=78:noet
