How to write an Intersec Makefile
=================================

Introduction
------------

Our build system is goal and sources driven: you just list the goals, and
the sources each of them needs. There is a full set of magic variables for
this purpose.


About Variables
---------------
// {{{

Magic Variables
~~~~~~~~~~~~~~~

* `$/` is set to the absolute path to the root of the source tree with a
  trailing slash. It has to be used to give a path to static libraries you
  depend on, e.g.:
+
----------------------------------
something_SOURCES = \
	...                      \
	$/lib-common/libcommon.a \
        ...
----------------------------------

* `$!` is set to the absolute path to the build directory with a trailing
  slash, but its use is discouraged, it may be removed at some point.

* `$~` is the name of the build directory with a trailing slash, basically
  `$!` is equal to `$/$~`.


Variables with side effects
~~~~~~~~~~~~~~~~~~~~~~~~~~~

As a general rule, magic variables with side effects use a suffix comprising
an underscore (`_`) and some capital letters. The prefix would be the target
they have a side effect on, no prefix means that the side effect is global to
the local directory.

All these variables _must_ be defined with `=`, not with `:=`.

// }}}

List of variables with side effects
-----------------------------------
// {{{

Per directory variables
~~~~~~~~~~~~~~~~~~~~~~~

At the moment, the following set of variables are used at the directory level:

`_CFLAGS`::
        To force some `CFLAGS` to the local directory goals.

`_LDFLAGS`::
        To force some `LDFLAGS` to the local directory goals.

`_COMPILER`::
	Change the compiler used for this file, for now supported by .cc and
	.c files to use clang instead of gcc.

`_NOCHECK`::
	To disable checks to the local directory goals.

`_DEPENDS`::
        This variable holds a list of local targets that must be remade before
        doing anything else automatic (meaning that it's not honoured for
        local rules, you must enforce that manually) in that directory.

`CLEANFILES`::
        This holds the list of files (or directories, necessarily with a
        trailing slash) that must be removed on clean.

`DISTCLEANFILES`::
        This holds the list of files (or directories, necessarily with a
        trailing slash) that must be removed on distclean.

Defining new goals
~~~~~~~~~~~~~~~~~~

The following suffixes are used to define goals of specific kinds:

`_PROGRAMS`::
        List of executable programs built for this directory
        (was `__EXE__` before).

`_LIBRARIES`::
        Static libraries (`.a` archives) (was `__LIB__` before).

`_SHARED_LIBRARIES`::
        Shared objects (`.so` files) (was `__SO__` before).

`_DATAS`::
        A target, named with its extension. The generation is done in-tree,
        and must be derived directly or indirectly from the `_SOURCES` that
        come with it.


The build system doesn't support any other kind of goal yet, though you can
add local rules (FIXME: add some doc about how to do that).

The prefixes are not used yet, except to define new build 'overlays',
so it is wise to use them consistently over the source tree.


Per Goal Variables
~~~~~~~~~~~~~~~~~~

Each goal supports a complete set of variables, prefixed with the goal name.
All the following work for any kind of goal:

`_SOURCES`::
        This variable has the list of sources.  We support at the time of the
        writing: .h, .c, .tokens, .fc, .farch, .l, .a, .wa, .ld, .lua.
+
Note that anything that is put in that variable, in a relative way to the
current directory, is added to the order only depends chain of your goal even
if it' is not an understood extension. Though if it is not a real “source” for
the goal, the use of `goal_DEPENDS` is the proper way.
+
Also, in-tree generated files are built first for this target, you don't need
to do anything special about it.

`_LINKER`::
	This variable allow to override the command used to link. Usually this
        variable is set to `$(CXX)` when the program or library is a c++ one.

`_LDFLAGS`::
        This variable holds the list of additional link flags to pass to the
        link command.

`_CFLAGS`::
        This variable holds the additional C compilation flags to use for
        this goal.

`_NOCHECK`::
	To disable checks when building this target.

`_DEPENDS`::
        This variable holds a number of other goals (relative to the
        Makefile's directory) that must be remade before remaking this goal.
+
Usual need arise when you use a local shared object that isn't listed in the
`_SOURCES`, and that you may need to redo for builds to succeed (if you add a
symbol in a `.so` and that a target uses it, link will fail is the `.so` isn't
rebuilt first).


NOTE: as a general rule any variable ending with `FLAGS` is kept and can be
reused in the build system to implement new kinds of goals.


For shared libraries (`_SHARED_LIBRARIES`) there is also:

`_SOVERSION`::
        This variable is mandatory for non plugins, though the build system
        won't enforce that (because of plugins).
+
This variable holds a list of up to two numbers. The first one will be used to
build the `SONAME` of the library, the second one is appended as a _build_
version.
+
For example, if you have `libfoo_SOVERSION = 1.2 3.4` then it will generate
the `libfoo.so.1.2.3.4` shared library, with a soname of `libfoo.so.1.2.3.4`.
And the symlinks `libfoo.so.1.2` and `libfoo.so` will be created pointing to
`libfoo.so.1.2.3.4` (the former is used for runtime, the latter for build
time).


Per Source Variables
~~~~~~~~~~~~~~~~~~~~

There are a few variables that have side effects and that can be used at the
file level:

`_DEPENDS`::
        Any source file supports this variable to define goals that must be
        remade before this source is ever used to produce new files.
+
For example, for a lexer `mylexer.l`, `mylexer.l_DEPENDS` would hold goals
that are remade before `mylexer.c` is produced, and `mylexer.c_DEPENDS` goals
that are remade before the lexer is compiled.

`_CFLAGS` on `.c` files::
        For `.c` files, this variable holds additional C compilation flags to
        be used when this is built. For autogenerated `.c` files (e.g.
        lexers), the name of the generated souce must be used.
+
Example: `something.c_CFLAGS = -Wno-error`

`_NOCHECK` on `.c` files::
	To disable checks when building this C file.

// }}}

About Goals
-----------
// {{{

Exported Goals
~~~~~~~~~~~~~~

The build system automatically exports goals for:

* in-tree generated files (like lexers) supposed to be arch-independant;

* goals generated through goals variables (programs, libraries, ...).


Local Goals
~~~~~~~~~~~

It is possible to define any local goal you want, the build system will find
them, and make them available from it.

You can use local rule names in `_DEPENDS` variables, the build system will
recurse (old-way) in your directory and call it. If it in turn needs a
build-system exported rule, it will recurse (old-way) into the build-system
again, and so on. This has many drawbacks, so consider extending the
build-system if you need a new class of such rules often.

You must not use targets starting with `__`, these are magic to the
build-system and will be ignored. It is not possible to use the `clean` target
either (see Hookable Goals, and the `CLEANFILES` variable).


Hookable Goals
~~~~~~~~~~~~~~

The build-system defines three rules you can hook into:

`all::`::
        This rule is the default rule run if no argument is passed to make.
        You can add local things to be done here. Though it is discouraged to
        do so. (see `toplevel` goal).

`distclean::`::
        This is probably the most useful hook. When distclean is run (this
        rule is global, and it's the same for any directory you run it from),
        commands that you put there are run for any Makefile that extends it.
        Note that for simple things, `DISTCLEANFILES` is probably better suited.

In addition to these, the build-system provides a way to run a command when
make is run without arguments from a local directory, and only in this case
(if you run make from a subdirectory this goal won't be done):

`toplevel:`::
        This target can depend upon other (probably local, but anything works)
        goals that must be done when the user runs `make` from the same
        directory.
+
You can also define commands to be run from that target like any normal make
goal.
+
The use cases are e.g. to make the target that rebuilds documentation be the
default when you are running make from the `Documentation/` directory of your
project.

// }}}

Things to know
--------------
// {{{

SUBDIR detection
~~~~~~~~~~~~~~~~

The build system guesses where to “recurse” following chains of Makefiles that
include Build/base.mk. If you want to use the build system in a hierarchy of
directories looking like:

----------------------------------
a/b/c
----------------------------------

You must have the following Makefiles (even containing only the
`include ../../Build/base.mk` line):

----------------------------------
Makefile
a/Makefile
a/b/Makefile
a/b/c/Makefile
----------------------------------


Environment variables
~~~~~~~~~~~~~~~~~~~~~

`L`, `LINEAR`::
        The build-system automatically uses parallel build, this can be
        disabled by setting the environment variable `$L` or `$LINEAR`.

`V`, `VERBOSE`::
        The build-system is usually quite silent. You can set `$V` or
        `$VERBOSE` to change that.

`P`, `PROFILE`::
        The build-system can use different _profiles_ for the build (debug
        build, usual devel build, production build, ...). Profiles are defined
        toplevel in the source tree, and their use can be chosen through `$P`
        or `$PROFILE`. (`$BUILDFOR` is also supported for backward
        compatibility).
+
Example: `make P=debug some-target` will rebuild some-target with `CFLAGS`
forced to `-O0 -fno-inlines -Wno-uninitialized`.

`M`, `MONOCHROME`::
        The build-system in silent mode echoes commands using some color.
        Setting `$M`, `$MONOCHROME` (or for backward compatibility `$NOCOLOR`)
        disables that.

`NOCHECK`::
	The build-system doesn't run "CHECK" targets (mostly clang at the
        time).

`NOCOMPRESS`::
    The build-system doesn't compress the debug section of binaries leading to
    larger binary files. This can be used if you have to work with tools that
    does not support compressed-debug sections (like valgrind, pahole or some
    old version of gdb).

// }}}

// vim:filetype=asciidoc:tw=78
