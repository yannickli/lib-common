/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "arith.h"
#include "sort.h"

#define SIMPLE_SORT
#define type_t   uint8_t
#define dsort    dsort8
#define uniq     uniq8
#define bisect   bisect8
#define contains contains8
#include "sort-numeric.in.c"

#undef SIMPLE_SORT
#define type_t   uint16_t
#define dsort    dsort16
#define uniq     uniq16
#define bisect   bisect16
#define contains contains16
#include "sort-numeric.in.c"

#define type_t   uint32_t
#define dsort    dsort32
#define uniq     uniq32
#define bisect   bisect32
#define contains contains32
#include "sort-numeric.in.c"

#define type_t   uint64_t
#define dsort    dsort64
#define uniq     uniq64
#define bisect   bisect64
#define contains contains64
#include "sort-numeric.in.c"

#define t(ptr, p)  (((byte *)(ptr)) + (size * (p)))

size_t uniq(void *data, size_t size, size_t nmemb, cmp_r_t *cmp,
            void *cmp_arg, del_r_t * nullable del, void *del_arg)
{
    for (size_t i = 1; i < nmemb; i++) {
        if (unlikely(cmp(t(data, i), t(data, i - 1), cmp_arg) == 0)) {
            void *end = t(data, nmemb);
            void *w   = t(data, i);
            void *r   = t(data, i + 1);

            if (del) {
                del(w, del_arg);
            }

            for (;;) {
                void *s = r;

                while (r < end && cmp(r, t(w, -1), cmp_arg) == 0) {
                    r = t(r, 1);
                }

                if (del) {
                    for (; s < r; s = t(s, 1)) {
                        del(s, del_arg);
                    }
                }

                if (r == end) {
                    break;
                }

                memcpy(w, r, size);
                w = t(w, 1);
                r = t(r, 1);
            }
            nmemb = ((byte *)w - (byte *)data) / size;
            break;
        }
    }
    return nmemb;
}

size_t bisect(const void *what, const void *data, size_t size, size_t nmemb,
              bool *found, cmp_r_t *cmp, void *arg)
{
    size_t l = 0, r = nmemb;

    while (l < r) {
        size_t i = (l + r) / 2;
        int d = cmp(what, t(data, i), arg);

        if (d == 0) {
            if (found) {
                *found = true;
            }
            return i;
        }
        if (d < 0) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    if (found) {
        *found = false;
    }
    return r;
}

bool contains(const void *what, const void *data, size_t size, size_t nmemb,
              cmp_r_t *cmp, void *arg)
{
    size_t l = 0, r = nmemb;

    while (l < r) {
        size_t i = (l + r) / 2;
        int d = cmp(what, t(data, i), arg);

        if (d == 0)
            return true;
        if (d < 0) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return false;
}

static int cmp_blk(const void *a, const void *b, void *arg)
{
    cmp_b cmp = arg;

    return cmp(a, b);
}

static void del_blk(void *v, void *arg)
{
    del_b del = arg;

    del(v);
}

size_t uniq_blk(void *data, size_t size, size_t nmemb, cmp_b cmp,
                del_b nullable del)
{
    del_r_t *del_cb = del ? &del_blk : NULL;

    return uniq(data, size, nmemb, &cmp_blk, cmp, del_cb, del);
}

size_t bisect_blk(const void *what, const void *data, size_t size,
                  size_t nmemb, bool *found, cmp_b cmp)
{
    return bisect(what, data, size, nmemb, found, &cmp_blk, cmp);
}

bool contains_blk(const void *what, const void *data, size_t size,
                  size_t nmemb, cmp_b cmp)
{
    return contains(what, data, size, nmemb, &cmp_blk, cmp);
}

/* Tests {{{ */

#include "z.h"

static int u64_cmp(const void *a, const void *b, void *arg)
{
    const uint64_t *ua = a;
    const uint64_t *ub = b;

    return CMP(*ua, *ub);
}

typedef struct u64_del_t {
    uint64_t *tab;
    int       len;
} u64_del_t;

static void u64_del(void *v, void *arg)
{
    uint64_t *uv = v;
    u64_del_t *del = arg;

    del->tab[del->len++] = *uv;
}

Z_GROUP_EXPORT(sort) {
    const uint64_t vals64[] =
        { 8, 8, 1, 2, 4, 4, 12, 5, 3, 7, 10, 1, 4, 1, 12, 12 };
    const uint64_t sorted64[countof(vals64) + 1][countof(vals64)] = {
        {  },
        { 8 },
        { 8, 8 },
        { 1, 8, 8 },
        { 1, 2, 8, 8 },
        { 1, 2, 4, 8, 8 },
        { 1, 2, 4, 4, 8, 8 },
        { 1, 2, 4, 4, 8, 8, 12 },
        { 1, 2, 4, 4, 5, 8, 8, 12 },
        { 1, 2, 3, 4, 4, 5, 8, 8, 12 },
        { 1, 2, 3, 4, 4, 5, 7, 8, 8, 12 },
        { 1, 2, 3, 4, 4, 5, 7, 8, 8, 10, 12 },
        { 1, 1, 2, 3, 4, 4, 5, 7, 8, 8, 10, 12 },
        { 1, 1, 2, 3, 4, 4, 4, 5, 7, 8, 8, 10, 12 },
        { 1, 1, 1, 2, 3, 4, 4, 4, 5, 7, 8, 8, 10, 12 },
        { 1, 1, 1, 2, 3, 4, 4, 4, 5, 7, 8, 8, 10, 12, 12 },
        { 1, 1, 1, 2, 3, 4, 4, 4, 5, 7, 8, 8, 10, 12, 12, 12 }
    };
    const uint64_t uniqed64[countof(vals64) + 1][countof(vals64) + 1] = {
        { 0,  },
        { 1, 8 },
        { 1, 8 },
        { 2, 1, 8 },
        { 3, 1, 2, 8 },
        { 4, 1, 2, 4, 8 },
        { 4, 1, 2, 4, 8 },
        { 5, 1, 2, 4, 8, 12 },
        { 6, 1, 2, 4, 5, 8, 12 },
        { 7, 1, 2, 3, 4, 5, 8, 12 },
        { 8, 1, 2, 3, 4, 5, 7, 8, 12 },
        { 9, 1, 2, 3, 4, 5, 7, 8, 10, 12 },
        { 9, 1, 2, 3, 4, 5, 7, 8, 10, 12 },
        { 9, 1, 2, 3, 4, 5, 7, 8, 10, 12 },
        { 9, 1, 2, 3, 4, 5, 7, 8, 10, 12 },
        { 9, 1, 2, 3, 4, 5, 7, 8, 10, 12 },
        { 9, 1, 2, 3, 4, 5, 7, 8, 10, 12 }
    };
    const uint64_t deleted64[countof(vals64) + 1][countof(vals64) + 1] = {
        { 0 },
        { 0 },
        { 1, 8 },
        { 1, 8 },
        { 1, 8 },
        { 1, 8 },
        { 2, 4, 8 },
        { 2, 4, 8 },
        { 2, 4, 8,},
        { 2, 4, 8 },
        { 2, 4, 8 },
        { 2, 4, 8 },
        { 3, 1, 4, 8 },
        { 4, 1, 4, 4, 8 },
        { 5, 1, 1, 4, 4, 8 },
        { 6, 1, 1, 4, 4, 8, 12 },
        { 7, 1, 1, 4, 4, 8, 12, 12 }
    };

    Z_TEST(64, "optimized 64") {
        for (int i = 0; i < countof(vals64); i++) {
            uint64_t v[countof(vals64)];
            size_t   len = 0;

            p_copy(v, vals64, countof(vals64));
            dsort64(v, i);
            Z_ASSERT_EQUAL(sorted64[i], i, v, i);
            len = uniq64(v, i);
            Z_ASSERT_EQUAL(&uniqed64[i][1], uniqed64[i][0], v, len);

            for (uint64_t j = 0; j < 15; j++) {
                bool   found;
                size_t pos = (bisect64)(j, v, len, &found);
                size_t scan_pos = 0;

                while (scan_pos < len && v[scan_pos] < j) {
                    scan_pos++;
                }
                Z_ASSERT_EQ(pos, scan_pos);

                Z_ASSERT_LE(pos, len);
                if (pos == len) {
                    Z_ASSERT(!contains64(j, v, len));
                    Z_ASSERT(!found);
                    if (len != 0) {
                        Z_ASSERT_LT(v[len -1], j);
                    }
                } else {
                    Z_ASSERT_GE(v[pos], j);
                    Z_ASSERT_EQ(v[pos] == j, contains64(j, v, len));
                    Z_ASSERT_EQ(v[pos] == j, found);
                }
            }
        }
    } Z_TEST_END;

    Z_TEST(32, "optimized 32") {
        uint32_t vals32[countof(vals64)];

        for (int i = 0; i < countof(vals64); i++) {
            vals32[i] = vals64[i];
        }

        for (int i = 0; i < countof(vals32); i++) {
            uint32_t sorted32[countof(vals64)];
            uint32_t uniqed32[countof(vals64)];
            uint32_t v[countof(vals32)];
            size_t   len = 0;

            for (int j = 0; j < countof(vals64); j++) {
                sorted32[j] = sorted64[i][j];
                uniqed32[j] = uniqed64[i][j + 1];
            }

            p_copy(&v, &vals32, 1);
            dsort32(v, i);
            Z_ASSERT_EQUAL(sorted32, i, v, i);
            len = uniq32(v, i);
            Z_ASSERT_EQUAL(uniqed32, uniqed64[i][0], v, len);

            for (uint64_t j = 0; j < 15; j++) {
                bool   found;
                size_t pos = (bisect32)(j, v, len, &found);
                size_t scan_pos = 0;

                while (scan_pos < len && v[scan_pos] < j) {
                    scan_pos++;
                }
                Z_ASSERT_EQ(pos, scan_pos);

                Z_ASSERT_LE(pos, len);
                if (pos == len) {
                    Z_ASSERT(!contains32(j, v, len));
                    Z_ASSERT(!found);
                    if (len != 0) {
                        Z_ASSERT_LT(v[len -1], j);
                    }
                } else {
                    Z_ASSERT_GE(v[pos], j);
                    Z_ASSERT_EQ(v[pos] == j, contains32(j, v, len));
                    Z_ASSERT_EQ(v[pos] == j, found);
                }
            }
        }
    } Z_TEST_END;

    Z_TEST(16, "optimized 16") {
        uint16_t vals16[countof(vals64)];

        for (int i = 0; i < countof(vals64); i++) {
            vals16[i] = vals64[i];
        }

        for (int i = 0; i < countof(vals16); i++) {
            uint16_t sorted16[countof(vals64)];
            uint16_t uniqed16[countof(vals64)];
            uint16_t v[countof(vals16)];
            size_t   len = 0;

            for (int j = 0; j < countof(vals64); j++) {
                sorted16[j] = sorted64[i][j];
                uniqed16[j] = uniqed64[i][j + 1];
            }

            p_copy(&v, &vals16, 1);
            dsort16(v, i);
            Z_ASSERT_EQUAL(sorted16, i, v, i);
            len = uniq16(v, i);
            Z_ASSERT_EQUAL(uniqed16, uniqed64[i][0], v, len);

            for (uint64_t j = 0; j < 15; j++) {
                bool   found;
                size_t pos = (bisect16)(j, v, len, &found);
                size_t scan_pos = 0;

                while (scan_pos < len && v[scan_pos] < j) {
                    scan_pos++;
                }
                Z_ASSERT_EQ(pos, scan_pos);

                Z_ASSERT_LE(pos, len);
                if (pos == len) {
                    Z_ASSERT(!contains16(j, v, len));
                    Z_ASSERT(!found);
                    if (len != 0) {
                        Z_ASSERT_LT(v[len -1], j);
                    }
                } else {
                    Z_ASSERT_GE(v[pos], j);
                    Z_ASSERT_EQ(v[pos] == j, contains16(j, v, len));
                    Z_ASSERT_EQ(v[pos] == j, found);
                }
            }
        }
    } Z_TEST_END;

    Z_TEST(8, "optimized 8") {
        uint8_t vals8[countof(vals64)];

        for (int i = 0; i < countof(vals64); i++) {
            vals8[i] = vals64[i];
        }

        for (int i = 0; i < countof(vals8); i++) {
            uint8_t sorted8[countof(vals64)];
            uint8_t uniqed8[countof(vals64)];
            uint8_t v[countof(vals8)];
            size_t   len = 0;

            for (int j = 0; j < countof(vals64); j++) {
                sorted8[j] = sorted64[i][j];
                uniqed8[j] = uniqed64[i][j + 1];
            }

            p_copy(&v, &vals8, 1);
            dsort8(v, i);
            Z_ASSERT_EQUAL(sorted8, i, v, i);
            len = uniq8(v, i);
            Z_ASSERT_EQUAL(uniqed8, uniqed64[i][0], v, len);

            for (uint64_t j = 0; j < 15; j++) {
                bool   found;
                size_t pos = (bisect8)(j, v, len, &found);
                size_t scan_pos = 0;

                while (scan_pos < len && v[scan_pos] < j) {
                    scan_pos++;
                }
                Z_ASSERT_EQ(pos, scan_pos);

                Z_ASSERT_LE(pos, len);
                if (pos == len) {
                    Z_ASSERT(!contains8(j, v, len));
                    Z_ASSERT(!found);
                    if (len != 0) {
                        Z_ASSERT_LT(v[len -1], j);
                    }
                } else {
                    Z_ASSERT_GE(v[pos], j);
                    Z_ASSERT_EQ(v[pos] == j, contains8(j, v, len));
                    Z_ASSERT_EQ(v[pos] == j, found);
                }
            }
        }
    } Z_TEST_END;

    Z_TEST(generic, "generic implementation") {
        for (int i = 0; i < countof(vals64); i++) {
            uint64_t v[countof(vals64)];
            uint64_t d[countof(vals64)];
            size_t   len = 0;
            u64_del_t del = {
                .tab = d,
                .len = 0,
            };

            p_copy(v, vals64, countof(vals64));
            dsort64(v, i);
            Z_ASSERT_EQUAL(sorted64[i], i, v, i);
            len = uniq(v, 8, i, &u64_cmp, NULL, &u64_del, &del);
            Z_ASSERT_EQUAL(&uniqed64[i][1], uniqed64[i][0], v, len);
            Z_ASSERT_EQUAL(&deleted64[i][1], deleted64[i][0], del.tab,
                           del.len);

            for (uint64_t j = 0; j < 15; j++) {
                bool   found;
                size_t pos = bisect(&j, v, 8, len, &found, &u64_cmp, NULL);
                size_t scan_pos = 0;

                while (scan_pos < len && v[scan_pos] < j) {
                    scan_pos++;
                }
                Z_ASSERT_EQ(pos, scan_pos);

                Z_ASSERT_LE(pos, len);
                if (pos == len) {
                    Z_ASSERT(!contains(&j, v, 8, len, &u64_cmp, NULL));
                    Z_ASSERT(!found);
                    if (len != 0) {
                        Z_ASSERT_LT(v[len -1], j);
                    }
                } else {
                    Z_ASSERT_GE(v[pos], j);
                    Z_ASSERT_EQ(v[pos] == j,
                                contains(&j, v, 8, len, &u64_cmp, NULL));
                    Z_ASSERT_EQ(v[pos] == j, found);
                }
            }
        }
    } Z_TEST_END;
} Z_GROUP_END;

/* }}} */
