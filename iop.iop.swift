/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/
extension iop__field__array_t : libcommon.IopArray { }
extension iop__package_elem__array_t : libcommon.IopArray { }
extension iop__int_size__t : libcommon.IopEnum {
    public static let descriptor = iop__int_size__ep
    public static let min : Swift.Int32 = Swift.Int32(INT_SIZE_min)
    public static let max : Swift.Int32 = Swift.Int32(INT_SIZE_max)
    public static let count : Swift.Int32 = Swift.Int32(INT_SIZE_count)
}
extension iop__string_type__t : libcommon.IopEnum {
    public static let descriptor = iop__string_type__ep
    public static let min : Swift.Int32 = Swift.Int32(STRING_TYPE_min)
    public static let max : Swift.Int32 = Swift.Int32(STRING_TYPE_max)
    public static let count : Swift.Int32 = Swift.Int32(STRING_TYPE_count)
}
public enum iop : libcommon.IopPackage {
    public typealias IntSize = iop__int_size__t

    public typealias StringType = iop__string_type__t

    public final class IntType : libcommon.IopStruct {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__int_type__sp
        }

        public var `isSigned` : Swift.Bool
        public var `size` : iop_package.IntSize

        public init(`isSigned`: Swift.Bool,
                    `size`: iop_package.IntSize) {
            self.isSigned = `isSigned`
            self.size = `size`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: iop__int_type__t.self, capacity: 1)
            self.isSigned = data.pointee.is_signed
            self.size = data.pointee.size
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: iop__int_type__t.self, capacity: 1)
            data.pointee.is_signed = self.isSigned
            data.pointee.size = self.size
        }
    }

    public indirect enum IopType : libcommon.IopUnion {
        public static let descriptor =  iop__iop_type__sp

        case `i`(iop_package.IntType)
        case `b`
        case `d`
        case `s`(iop_package.StringType)
        case `v`
        case `typeName`(Swift.String)
        case `array`(iop_package.IopType)

        public init(_ c: Swift.UnsafeRawPointer) throws {
            let (tag, data) = type(of: self)._explode(c)
            switch tag {
              case 1:
                self = .i(try iop_package.IntType(data))
              case 2:
                self = .b
              case 3:
                self = .d
              case 4:
                self = .s(data.bindMemory(to: iop_package.StringType.self, capacity: 1).pointee)
              case 5:
                self = .v
              case 6:
                self = .typeName(Swift.String(data.bindMemory(to: LString.self, capacity: 1).pointee) ?? "")
              case 7:
                self = .array(try iop_package.IopType(data.bindMemory(to: Swift.UnsafeRawPointer.self, capacity: 1).pointee))
              default:
                throw libcommon.IopImportError.invalidUnionTag(type(of: self).descriptor, tag)
            }
        }

        public func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let (tag, data) = type(of: self)._explode(c)
            switch self {
              case .i(let i_val):
                tag[0] = 1
                i_val.fill(data, on: allocator)
              case .b:
                tag[0] = 2
              case .d:
                tag[0] = 3
              case .s(let s_val):
                tag[0] = 4
                data.bindMemory(to: iop_package.StringType.self, capacity: 1).pointee = `s_val`
              case .v:
                tag[0] = 5
              case .typeName(let typeName_val):
                tag[0] = 6
                data.bindMemory(to: libcommon.LString.self, capacity: 1).pointee = typeName_val.duplicated(on: allocator)
              case .array(let array_val):
                tag[0] = 7
                data.bindMemory(to: Swift.UnsafeMutableRawPointer.self, capacity: 1).pointee = array_val.duplicated(on: allocator)
            }
        }
    }

    public class PackageElem : libcommon.IopClass {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__package_elem__sp
        }

        open override class var isAbstract : Swift.Bool {
            return true
        }

        public var `name` : Swift.String

        public init(`name`: Swift.String) {
            self.name = `name`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: iop__package_elem__t.self, capacity: 1)
            self.name = Swift.String(data.pointee.name) ?? ""
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: iop__package_elem__t.self, capacity: 1)
             data.pointee.name = self.name.duplicated(on: allocator)
        }
    }

    public enum Value : libcommon.IopUnion {
        public static let descriptor =  iop__value__sp

        case `i`(Swift.Int64)
        case `u`(Swift.UInt64)
        case `d`(Swift.Double)
        case `s`(Swift.String)
        case `b`(Swift.Bool)

        public init(_ c: Swift.UnsafeRawPointer) throws {
            let (tag, data) = type(of: self)._explode(c)
            switch tag {
              case 1:
                self = .i(data.bindMemory(to: Swift.Int64.self, capacity: 1).pointee)
              case 2:
                self = .u(data.bindMemory(to: Swift.UInt64.self, capacity: 1).pointee)
              case 3:
                self = .d(data.bindMemory(to: Swift.Double.self, capacity: 1).pointee)
              case 4:
                self = .s(Swift.String(data.bindMemory(to: LString.self, capacity: 1).pointee) ?? "")
              case 5:
                self = .b(data.bindMemory(to: Swift.Bool.self, capacity: 1).pointee)
              default:
                throw libcommon.IopImportError.invalidUnionTag(type(of: self).descriptor, tag)
            }
        }

        public func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let (tag, data) = type(of: self)._explode(c)
            switch self {
              case .i(let i_val):
                tag[0] = 1
                data.bindMemory(to: Swift.Int64.self, capacity: 1).pointee = `i_val`
              case .u(let u_val):
                tag[0] = 2
                data.bindMemory(to: Swift.UInt64.self, capacity: 1).pointee = `u_val`
              case .d(let d_val):
                tag[0] = 3
                data.bindMemory(to: Swift.Double.self, capacity: 1).pointee = `d_val`
              case .s(let s_val):
                tag[0] = 4
                data.bindMemory(to: libcommon.LString.self, capacity: 1).pointee = s_val.duplicated(on: allocator)
              case .b(let b_val):
                tag[0] = 5
                data.bindMemory(to: Swift.Bool.self, capacity: 1).pointee = `b_val`
            }
        }
    }

    public final class OptInfo : libcommon.IopStruct {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__opt_info__sp
        }

        public var `defVal` : iop_package.Value?

        public init(`defVal`: iop_package.Value? = nil) {
            self.defVal = `defVal`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: iop__opt_info__t.self, capacity: 1)

            self.defVal = try iop_package.Value(data.pointee.def_val)
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: iop__opt_info__t.self, capacity: 1)
            if let defVal_val = self.defVal {
                data.pointee.def_val = defVal_val.duplicated(on: allocator).bindMemory(to: iop__value__t.self, capacity: 1)
            }
        }
    }

    public final class Field : libcommon.IopStruct {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__field__sp
        }

        public var `name` : Swift.String
        public var `type` : iop_package.IopType
        public var `optional` : iop_package.OptInfo?
        public var `tag` : Swift.UInt16?
        public var `isReference` : libcommon.IopVoid?

        public init(`name`: Swift.String,
                    `type`: iop_package.IopType,
                    `optional`: iop_package.OptInfo? = nil,
                    `tag`: Swift.UInt16? = nil,
                    `isReference`: libcommon.IopVoid? = nil) {
            self.name = `name`
            self.type = `type`
            self.optional = `optional`
            self.tag = `tag`
            self.isReference = `isReference`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: iop__field__t.self, capacity: 1)
            self.name = Swift.String(data.pointee.name) ?? ""

            var type_var = data.pointee.type
            self.type = try iop_package.IopType(&type_var)
            

            self.optional = try iop_package.OptInfo(data.pointee.optional)
            if data.pointee.tag.has_field {
                self.tag = data.pointee.tag.v
            }
            if data.pointee.is_reference {
                self.isReference = libcommon.IopVoid()
            }
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: iop__field__t.self, capacity: 1)
             data.pointee.name = self.name.duplicated(on: allocator)
            data.pointee.type = self.type.duplicated(on: allocator).bindMemory(to: iop__iop_type__t.self, capacity: 1).pointee
            if let optional_val = self.optional {
                data.pointee.optional = optional_val.duplicated(on: allocator).bindMemory(to: iop__opt_info__t.self, capacity: 1)
            }
            if let tag_val = self.tag {
                data.pointee.tag.has_field = true
                data.pointee.tag.v = tag_val
            } else {
                data.pointee.tag.has_field = false
            }
            data.pointee.is_reference = self.isReference != nil
        }
    }

    public class Structure : iop_package.PackageElem {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__structure__sp
        }

        open override class var isAbstract : Swift.Bool {
            return true
        }


        public override init(`name`: Swift.String) {
            super.init(name: `name`)
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            super.fill(c, on: allocator)
        }
    }

    public final class Struct : iop_package.Structure {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__struct__sp
        }

        open override class var isAbstract : Swift.Bool {
            return false
        }

        public var `fields` : [iop_package.Field]

        public init(`name`: Swift.String,
                    `fields`: [iop_package.Field] = []) {
            self.fields = `fields`
            super.init(name: `name`)
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: iop__struct__t.self, capacity: 1)
            self.fields = try data.pointee.fields.buffer.map {
                var fields_var = $0
                return try iop_package.Field(&fields_var)
                }
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: iop__struct__t.self, capacity: 1)
            libcommon.duplicate(complexTypeArray: self.fields, to: &data.pointee.fields, on: allocator)
            super.fill(c, on: allocator)
        }
    }

    public final class Union : iop_package.Structure {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__union__sp
        }

        open override class var isAbstract : Swift.Bool {
            return false
        }

        public var `fields` : [iop_package.Field]

        public init(`name`: Swift.String,
                    `fields`: [iop_package.Field] = []) {
            self.fields = `fields`
            super.init(name: `name`)
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: iop__union__t.self, capacity: 1)
            self.fields = try data.pointee.fields.buffer.map {
                var fields_var = $0
                return try iop_package.Field(&fields_var)
                }
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: iop__union__t.self, capacity: 1)
            libcommon.duplicate(complexTypeArray: self.fields, to: &data.pointee.fields, on: allocator)
            super.fill(c, on: allocator)
        }
    }

    public final class Package : libcommon.IopStruct {
        open override class var descriptor : Swift.UnsafePointer<iop_struct_t> {
            return iop__package__sp
        }

        public var `name` : Swift.String
        public var `elems` : [iop_package.PackageElem]

        public init(`name`: Swift.String,
                    `elems`: [iop_package.PackageElem] = []) {
            self.name = `name`
            self.elems = `elems`
            super.init()
        }

        public required init(_ c: Swift.UnsafeRawPointer) throws {
            let data = c.bindMemory(to: iop__package__t.self, capacity: 1)
            self.name = Swift.String(data.pointee.name) ?? ""
            self.elems = try data.pointee.elems.buffer.map {                return try iop_package.PackageElem.make(Swift.UnsafeRawPointer($0))}
            try super.init(c)
        }

        open override func fill(_ c: Swift.UnsafeMutableRawPointer, on allocator: libcommon.FrameBasedAllocator) {
            let data = c.bindMemory(to: iop__package__t.self, capacity: 1)
             data.pointee.name = self.name.duplicated(on: allocator)
            libcommon.duplicate(classArray: self.elems, to: &data.pointee.elems, on: allocator)
        }
    }

    public enum interfaces {
    }
    public enum modules {
    }
    public static let classes : [libcommon.IopClass.Type] = [ PackageElem.self, Structure.self, Struct.self, Union.self ]
}

public typealias iop_package = iop
