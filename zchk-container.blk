/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2015 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "zchk-container.h"
#include "container.h"
#include "z.h"
#include "sort.h"


/*{{{1 Qhash */

/* Keep these here, it's to check the macros are used and built */
qh_k32_t(test);
qh_k64_t(test_qh_64);

qm_k32_t(test, uint32_t);
qm_k64_t(test_qh_64, uint32_t);

qh_kptr_ckey_t(test_str, char, qhash_str_hash, qhash_str_equal);

Z_GROUP_EXPORT(qhash)
{
    Z_TEST(insertion, "qhash: insertion") {
        QH(test, h, false);
        uint64_t bits[2] = { 0, 0 };

        for (int i = 0; i < 128; i++) {
            qh_add(test, &h, i);
            SET_BIT(bits, i);
        }
        Z_ASSERT_EQ(h.hdr.len, 128U);

        qh_for_each_pos(test, pos, &h) {
            uint32_t v = h.keys[pos];

            Z_ASSERT(v < bitsizeof(bits) && TST_BIT(bits, v));
            CLR_BIT(bits, v);
        }

        Z_ASSERT(bits[0] == 0, "all values should have been seen");
        Z_ASSERT(bits[1] == 0, "all values should have been seen");
        qh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(collision, "qhash: collision") {
        QH(test, h, false);

        for (int i = 0; i < 128; i++) {
            qh_add(test, &h, i);
        }

        for (int i = 10; i < 128; i += 7) {
            Z_ASSERT(qh_add(test, &h, i), "double insertion of %d", i);
        }

        qh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(self , "qhash: self search") {
        QH(test, h, false);

        for (int i = 0; i < 128; i++) {
            qh_add(test, &h, i);
        }

        for (int i = 128; i-- > 0; ) {
            int32_t pos = qh_find(test, &h, i);

            Z_ASSERT(pos >= 0, "qh_find should find %d", i);
            qh_del_at(test, &h, pos);
        }

        Z_ASSERT_EQ(h.hdr.len, 0U);

        qh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(string, "qhash: string") {
        const char *t1 = "test1";
        const char *t2 = "test2";
        int32_t pos;
        QH(test_str, h, false);

        qh_add(test_str, &h, t1);
        qh_add(test_str, &h, t2);

        pos = qh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t1);
        Z_ASSERT_STREQUAL(h.keys[pos], t1);

        pos = qh_find(test_str, &h, t2);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t2);

        Z_ASSERT_EQ(qh_len(test_str, &h), 2);

        qh_del_at(test_str, &h, pos);
        qh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(h.keys[i], t1, "qh_for_each_pos has failed");
        }

        /* Remove t1 */
        pos = qh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qh_del_at(test_str, &h, pos);
        Z_ASSERT_EQ(qh_len(test_str, &h), 0);

        qh_add(test_str, &h, t1);
        Z_ASSERT_EQ(qh_len(test_str, &h), 1);

        pos = qh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(h.keys[i], t1, "2nd qh_for_each_pos has failed");
        }
        qh_wipe(test_str, &h);
    } Z_TEST_END;

    Z_TEST(shrink_bug , "qhash: test for hdr->bits overflow after shrink") {
        qh_t(u32) qh;

        qh_init(u32, &qh, false);

        qh_set_minsize(u32, &qh, 1);
        Z_ASSERT_N(qh_add(u32, &qh, 0));
        Z_ASSERT_EQ(qh.hdr.size, 11U);
        /* Force qh.hdr.size to grow up to x16 */
        for (int i = 1; i < 8192; i++) {
            Z_ASSERT_N(qh_add(u32, &qh, i));
        }
        Z_ASSERT_EQ(qh.hdr.size, 12289U);

        /* Remove some elements */
        for (int i = 1; i < 8191; i++) {
            if (i % 42 == 0)
                continue;
            qh_del_key(u32, &qh, i);
        }
        Z_ASSERT_EQ(qh.hdr.len, 197U);
        Z_ASSERT_EQ(qh.hdr.size, 12289U);

        /* Now add one element which should force a shrink */
        Z_ASSERT_N(qh_add(u32, &qh, 1));
        Z_ASSERT_EQ(qh.hdr.len, 198U);
        Z_ASSERT_EQ(qh.hdr.size, 3079U);
        Z_ASSERT_P(qh.old);

        qh_for_each_pos(u32, pos, &qh) {
            qh_del_at(u32, &qh, pos);
        }
        Z_ASSERT_EQ(qh.hdr.len, 0U);

        qh_wipe(u32, &qh);
    } Z_TEST_END
} Z_GROUP_END

/*1}}}*/
/*{{{1 QHhash */

/* Keep these here, it's to check the macros are used and built */
qhh_k32_t(test, 16);
qhh_k64_t(test_qh_64, 16);

qhm_k32_t(test, 16, uint32_t);
qhm_k64_t(test_qh_64, 16, uint32_t);

qhh_kptr_ckey_t(test_str, 16, char, qhhash_str_hash, qhhash_str_equal);

qhm_kvec_t(test_lstr, 16, lstr_t, uint32_t, qhhash_lstr_hash, qhhash_lstr_equal);
qhm_kptr_t(test_ptr,  16, void,   uint32_t, qhhash_hash_ptr,  qhhash_ptr_equal);

Z_GROUP_EXPORT(qhugehash)
{
    Z_TEST(insertion, "qhhash: insertion") {
        qhh_t(test) h;
        uint64_t bits[2] = { 0, 0 };

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
            SET_BIT(bits, i);
        }
        Z_ASSERT_EQ(h.hdr.len, 128U);

        qhh_for_each_pos(test, pos, &h) {
            uint32_t v = *qhh_key_p(test, &h, pos);

            Z_ASSERT(v < bitsizeof(bits) && TST_BIT(bits, v));
            CLR_BIT(bits, v);
        }

        Z_ASSERT(bits[0] == 0, "all values should have been seen");
        Z_ASSERT(bits[1] == 0, "all values should have been seen");
        qhh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(collision, "qhhash: collision") {
        qhh_t(test) h;

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
        }

        for (int i = 0; i < 128; i++) {
            Z_ASSERT(qhh_add(test, &h, i), "double insertion of %d", i);
        }

        qhh_clear(test, &h);
        Z_ASSERT_ZERO(qhh_len(test, &h));

        qhh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(self, "qhhash: self search") {
        qhh_t(test) h;

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
        }
        Z_ASSERT_EQ(qhh_len(test, &h), 128ul);

        for (int i = 128; i-- > 0; ) {
            int64_t pos = qhh_find(test, &h, i);

            Z_ASSERT(pos >= 0, "qh_find should find %d", i);
            qhh_del_at(test, &h, pos);
        }

        Z_ASSERT_ZERO(qhh_len(test, &h));

        qhh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(string, "qhhash: string") {
        const char *t1 = "test1";
        const char *t2 = "test2";
        int64_t pos;
        qhh_t(test_str) h;

        qhh_init(test_str, &h, false);

        Z_ASSERT_N(qhh_add(test_str, &h, t1));
        Z_ASSERT_N(qhh_add(test_str, &h, t2));

        pos = qhh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t1);
        Z_ASSERT_STREQUAL(*qhh_key_p(test_str, &h, pos), t1);

        pos = qhh_find(test_str, &h, t2);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t2);

        Z_ASSERT_EQ(qhh_len(test_str, &h), 2ul);

        qhh_del_at(test_str, &h, pos);
        Z_ASSERT_EQ(qhh_len(test_str, &h), 1ul);
        qhh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(*qhh_key_p(test_str, &h, i), t1,
                              "qh_for_each_pos has failed");
        }

        /* Remove t1 */
        pos = qhh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qhh_del_at(test_str, &h, pos);
        Z_ASSERT_ZERO(qhh_len(test_str, &h));

        qhh_add(test_str, &h, t1);
        Z_ASSERT_EQ(qhh_len(test_str, &h), 1ul);

        pos = qhh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qhh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(*qhh_key_p(test_str, &h, i), t1,
                              "2nd qh_for_each_pos has failed");
        }
        qhh_wipe(test_str, &h);
    } Z_TEST_END;

    Z_TEST(qhh_hash, "qhhash: qhh_hash/qhh_del_key_h") {
        qhh_t(test) h;

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
        }

        for (int i = 128; i-- > 0; ) {
            uint32_t hash = qhh_hash(test, &h, i);
            int64_t  pos;

            pos = qhh_del_key_h(test, &h, hash, i);
            Z_ASSERT(pos >= 0, "qh_find should find %d", i);
        }

        Z_ASSERT_ZERO(qhh_len(test, &h));

        qhh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(qhm_hash, "qhhash: qhm_hash/qhm_del_key_h") {
        qhm_t(test) h;

        qhm_init(test, &h, false);

        for (uint32_t i = 0; i < 128; i++) {
            Z_ASSERT_N(qhm_add(test, &h, i, i));
        }

        for (uint32_t i = 128; i-- > 0; ) {
            uint32_t hash = qhm_hash(test, &h, i);
            int64_t  pos;

            pos = qhm_del_key_h(test, &h, hash, i);
            Z_ASSERT(pos >= 0, "qm_find should find %d", i);
            Z_ASSERT_EQ(*qhm_value_p(test, &h, pos), i);
        }

        Z_ASSERT_ZERO(qhm_len(test, &h));

        qhm_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(__qhm_put , "qhhash: __qhm_put") {
        lstr_t str;

#define CHECK(type, key)  \
        do {                                                                \
            uint64_t pos;                                                   \
            qhm_t(type) h;                                                  \
                                                                            \
            qhm_init(type, &h, true);                                       \
            pos = __qhm_put(type, &h, (key), 1, 0);                         \
            Z_ASSERT_EQ(pos & QHASH_COLLISION, 0u);                         \
            pos = __qhm_put(type, &h, (key), 2, 0);                         \
            Z_ASSERT_NE(pos & QHASH_COLLISION, 0u);                         \
            Z_ASSERT_EQ(*qhm_value_p(type, &h, pos), 1u);                   \
            pos = __qhm_put(type, &h, (key), 2, QHASH_OVERWRITE);           \
            Z_ASSERT_NE(pos & QHASH_COLLISION, 0u);                         \
            Z_ASSERT_EQ(*qhm_value_p(type, &h, pos), 2u);                   \
            qhm_wipe(type, &h);                                             \
        } while (0)

        /* IKEY */
        CHECK(test, 1);

        /* VKEY */
        str = LSTR_IMMED_V("foo");
        CHECK(test_lstr, &str);

        /* PKEY */
        CHECK(test_ptr, (void *)0xf00);

#undef CHECK

    } Z_TEST_END

} Z_GROUP_END

/*1}}}*/
/*{{{1 Qvectors */

static _Bool qv_sort_tst(void)
{
    bool ok = true;
    qv_t(u32) tab;

#define N  128
    qv_inita(u32, &tab, N);
    for (int i = 0; i < N; i++)
        qv_append(u32, &tab, rand());
    qv_sort(u32)(&tab, ^int (const uint32_t *v1, const uint32_t *v2) {
        return CMP(*v1, *v2);
    });
    for (int i = 1; ok && i < tab.len; i++) {
        ok = tab.tab[i - 1] <= tab.tab[i];
    }
#undef N

    return ok;
}

static void build_sorted_uniq_vec(qv_t(u32) *vec)
{
#define N  1024
    int size = ha_rand_range(0, N);

    for (int i = 0; i < size; i++) {
        qv_append(u32, vec, ha_rand_range(0, 4 * N));
    }
    dsort32(vec->tab, vec->len);
    vec->len = uniq32(vec->tab, vec->len);
}

static _Bool qv_diff_tst(void)
{
    t_scope;
    qv_t(u32) vec1, vec2, res;

    t_qv_init(u32, &vec1, N);
    t_qv_init(u32, &vec2, N);
    t_qv_init(u32, &res,  N);

    build_sorted_uniq_vec(&vec1);
    build_sorted_uniq_vec(&vec2);

    qv_diff(u32)(&vec1, &vec2, &res,
                 ^int (const uint32_t *v1, const uint32_t *v2) {
        return CMP(*v1, *v2);
    });

    THROW_FALSE_IF(res.len != (int)uniq32(res.tab, res.len));

    qv_for_each_pos(u32, pos, &res) {
        if (!contains32(res.tab[pos], vec1.tab, vec1.len)
        ||   contains32(res.tab[pos], vec2.tab, vec2.len))
        {
            return false;
        }
    }
    qv_for_each_pos(u32, pos, &vec1) {
        if (!contains32(vec1.tab[pos], vec2.tab, vec2.len)
        &&  !contains32(vec1.tab[pos], res.tab,  res.len))
        {
            return false;
        }
    }

    return true;
#undef N
}

static _Bool qv_search_tst(void)
{
    t_scope;

    qv_t(i32) vec;
    int N = 10;
    qv_cmp_b(i32) cmp = ^int (const int32_t* a, const int32_t* b){
        return CMP(*a, *b);
    };

    t_qv_init(i32, &vec, N);
    for (int i = 0; i < N; i++)
        qv_append(i32, &vec, 1 + i * 2);

    for (int i = -2; i < 2 * N + 2; i++) {
        bool found_bisect = false;
        int pos_bisect = qv_bisect(i32)(&vec, i, &found_bisect, cmp);
        int pos_find = qv_find(i32)(&vec, i, true, cmp);
        bool contain = qv_contains(i32)(&vec, i, true, cmp);

        /* compare with result on assumed unsorted vector */
        THROW_FALSE_IF(pos_find != qv_find(i32)(&vec, i, false, cmp));
        THROW_FALSE_IF(contain != qv_contains(i32)(&vec, i, false, cmp));

        if (i < 1) {
            THROW_FALSE_IF(pos_bisect != 0);
            THROW_FALSE_IF(pos_find != -1);
        } else
        if (i < 1 + N * 2) {
            THROW_FALSE_IF(found_bisect != i % 2);
            if (found_bisect) {
                THROW_FALSE_IF(pos_bisect != (i - 1) / 2);
                THROW_FALSE_IF(pos_find   != (i - 1) / 2);
            } else {
                THROW_FALSE_IF(pos_bisect != (i - 1) / 2 + 1);
                THROW_FALSE_IF(pos_find   != -1);
            }
        } else {
            THROW_FALSE_IF(found_bisect);
            THROW_FALSE_IF(pos_bisect != N);
            THROW_FALSE_IF(pos_find != -1);
        }
        THROW_FALSE_IF(found_bisect != contain);
    }

    return true;
}

Z_GROUP_EXPORT(qvector)
{
    Z_TEST(qv_sort, "qvector: qv_sort") {
        Z_ASSERT(qv_sort_tst());
    } Z_TEST_END;

    Z_TEST(qv_diff, "qvector: qv_diff") {
        Z_ASSERT(qv_diff_tst());
    } Z_TEST_END;

    Z_TEST(qv_search, "qvector: bisect, find and contains") {
        Z_ASSERT(qv_search_tst());
    } Z_TEST_END;

} Z_GROUP_END;

/*1}}}*/
/*{{{1 Heap */

Z_GROUP_EXPORT(qhp)
{
    Z_TEST(sort, "qhp: sort") {
        qhp_t(i32_min)  qhp;
        int32_t         tab[] = { 5, 2, 9, 7, 1, 3, 0, 8, 6, 4 };

        qhp_inita(i32_min, &qhp, countof(tab));

        for (int i = 0; i < countof(tab); i++) {
            qhp_insert(i32_min, &qhp, tab[i]);
            Z_ASSERT_EQ(qhp_len(i32_min, &qhp), i + 1, "unexpected length");
        }

        for (int i = 0; i < countof(tab); i++) {
            int it;

            Z_ASSERT(!qhp_is_empty(i32_min, &qhp), "qhp is empty");
            it = qhp_take_first(i32_min, &qhp);

            Z_ASSERT_EQ(it, i, "expected `%d', got `%d'", i, it);
        }
    } Z_TEST_END

    Z_TEST(inline_struct, "qhp: inline structure") {
        qhp_t(inl_heap)  qhp;
        int32_t          tab[] = { 5, 2, 9, 7, 1, 3, 0, 8, 6, 4 };

        qhp_inita(inl_heap, &qhp, countof(tab));

        for (int i = 0; i < countof(tab); i++) {
            test_node_inl_t node = { .val = tab[i] };
            int pos;

            pos = qhp_insert(inl_heap, &qhp, node);
            node = qhp_get(inl_heap, &qhp, pos);
            Z_ASSERT_EQ(pos, node.pos, "invalid position after insertion: "
                        "expected `%d', got `%d'", pos, node.pos);
        }

        qhp_for_each_pos(inl_heap, pos, &qhp) {
            test_node_inl_t node = qhp_get(inl_heap, &qhp, pos);
            Z_ASSERT_EQ(pos, node.pos, "invalid position: "
                        "expected `%d', got `%d'", pos, node.pos);
        }
    } Z_TEST_END

    Z_TEST(remove, "qhp: remove") {
        t_scope;
        qhp_t(test_heap) qhp;
        int             tab[]       = { 5, 2, 9, 7, 1, 3, 0, 8, 6, 4 };
        int             to_remove[] = {       2,          6,       9 };
        int             expected[]  = {    1, 2, 3,    5, 6, 7, 8,   };
        test_node_t     nodes[countof(tab)];

        STATIC_ASSERT (countof(expected)
                    == countof(tab) - countof(to_remove));

        p_clear(nodes, countof(nodes));
        t_qhp_init(test_heap, &qhp, 1024);

        for (int i = 0; i < countof(tab); i++) {
            nodes[i].val = tab[i];
            qhp_insert(test_heap, &qhp, &nodes[i]);
        }

        for (int i = 0; i < countof(to_remove); i++) {
            test_node_t *node = &nodes[to_remove[i]];
            test_node_t *removed;

            Z_ASSERT_EQ(qhp_len(test_heap, &qhp), countof(nodes) - i,
                        "unexpected qhp length");
            removed = qhp_remove(test_heap, &qhp, node->pos);
            Z_ASSERT(node == removed, "removed wrong node");
        }

        Z_ASSERT_EQ(qhp_len(test_heap, &qhp), countof(expected),
                    "unexpected qhp length");

        for (int i = 0; i < countof(expected); i++) {
            int val = qhp_take_first(test_heap, &qhp)->val;

            Z_ASSERT_EQ(expected[i], val, "expected `%d', got `%d'",
                        expected[i], val);
        }

        Z_ASSERT(qhp_is_empty(test_heap, &qhp), "qhp is not empty");
    } Z_TEST_END

    Z_TEST(lstr, "qhp: lstr") {
        t_scope;
        qhp_t(lstr_min)  qhp;
        lstr_t           toto = LSTR_IMMED_V("toto");
        lstr_t           tata = LSTR_IMMED_V("tata");
        lstr_t           tutu = LSTR_IMMED_V("tutu");

        t_qhp_init(lstr_min, &qhp, 3);

        qhp_insert(lstr_min, &qhp, &toto);
        qhp_insert(lstr_min, &qhp, &tata);
        qhp_insert(lstr_min, &qhp, &tutu);

        Z_ASSERT_LSTREQUAL(tata, *qhp_take_first(lstr_min, &qhp),
                           "expected \"toto\"");
        Z_ASSERT_LSTREQUAL(toto, *qhp_take_first(lstr_min, &qhp),
                           "expected \"tata\"");
        Z_ASSERT_LSTREQUAL(tutu, *qhp_take_first(lstr_min, &qhp),
                           "expected \"tutu\"");
    } Z_TEST_END
} Z_GROUP_END

/*1}}}*/
