/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include "zchk-container.h"
#include "container.h"
#include "z.h"
#include "sort.h"


/*{{{1 Qhash */

/* Keep these here, it's to check the macros are used and built */
qh_k32_t(test);
qh_k64_t(test_qh_64);

qm_k32_t(test, uint32_t);
qm_k64_t(test_qh_64, uint32_t);

qh_kptr_ckey_t(test_str, char, qhash_str_hash, qhash_str_equal);

qm_kvec_t(test_lstr, lstr_t, uint32_t, qhash_lstr_hash, qhash_lstr_equal);
qm_kptr_t(test_ptr,  void,   uint32_t, qhash_hash_ptr,  qhash_ptr_equal);

Z_GROUP_EXPORT(qhash)
{
    Z_TEST(insertion, "qhash: insertion") {
        QH(test, h, false);
        uint64_t bits[2] = { 0, 0 };

        for (int i = 0; i < 128; i++) {
            qh_add(test, &h, i);
            SET_BIT(bits, i);
        }
        Z_ASSERT_EQ(h.hdr.len, 128U);

        qh_for_each_pos(test, pos, &h) {
            uint32_t v = h.keys[pos];

            Z_ASSERT(v < bitsizeof(bits) && TST_BIT(bits, v));
            CLR_BIT(bits, v);
        }

        Z_ASSERT(bits[0] == 0, "all values should have been seen");
        Z_ASSERT(bits[1] == 0, "all values should have been seen");
        qh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(collision, "qhash: collision") {
        QH(test, h, false);

        for (int i = 0; i < 128; i++) {
            qh_add(test, &h, i);
        }

        for (int i = 10; i < 128; i += 7) {
            Z_ASSERT(qh_add(test, &h, i), "double insertion of %d", i);
        }

        qh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(self , "qhash: self search") {
        QH(test, h, false);

        for (int i = 0; i < 128; i++) {
            qh_add(test, &h, i);
        }

        for (int i = 128; i-- > 0; ) {
            int32_t pos = qh_find(test, &h, i);

            Z_ASSERT(pos >= 0, "qh_find should find %d", i);
            qh_del_at(test, &h, pos);
        }

        Z_ASSERT_EQ(h.hdr.len, 0U);

        qh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(string, "qhash: string") {
        const char *t1 = "test1";
        const char *t2 = "test2";
        int32_t pos;
        QH(test_str, h, false);

        qh_add(test_str, &h, t1);
        qh_add(test_str, &h, t2);

        pos = qh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t1);
        Z_ASSERT_STREQUAL(h.keys[pos], t1);

        pos = qh_find(test_str, &h, t2);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t2);

        Z_ASSERT_EQ(qh_len(test_str, &h), 2);

        qh_del_at(test_str, &h, pos);
        qh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(h.keys[i], t1, "qh_for_each_pos has failed");
        }

        /* Remove t1 */
        pos = qh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qh_del_at(test_str, &h, pos);
        Z_ASSERT_EQ(qh_len(test_str, &h), 0);

        qh_add(test_str, &h, t1);
        Z_ASSERT_EQ(qh_len(test_str, &h), 1);

        pos = qh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(h.keys[i], t1, "2nd qh_for_each_pos has failed");
        }
        qh_wipe(test_str, &h);
    } Z_TEST_END;

    Z_TEST(qh_hash , "qhash: qh_hash/qh_del_key_h") {
        QH(test, h, false);

        for (int i = 0; i < 128; i++) {
            qh_add(test, &h, i);
        }

        for (int i = 128; i-- > 0; ) {
            uint32_t hash = qh_hash(test, &h, i);
            int32_t  pos;

            pos = qh_del_key_h(test, &h, hash, i);
            Z_ASSERT(pos >= 0, "qh_find should find %d", i);
        }

        Z_ASSERT_EQ(h.hdr.len, 0U);

        qh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(qm_hash , "qhash: qm_hash/qh_del_key_h") {
        QM(test, h, false);

        for (uint32_t i = 0; i < 128; i++) {
            qm_add(test, &h, i, i);
        }

        for (uint32_t i = 128; i-- > 0; ) {
            uint32_t hash = qm_hash(test, &h, i);
            int32_t  pos;

            pos = qm_del_key_h(test, &h, hash, i);
            Z_ASSERT(pos >= 0, "qm_find should find %d", i);
            Z_ASSERT_EQ(h.values[pos], i);
        }

        Z_ASSERT_EQ(h.hdr.len, 0U);

        qm_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(__qm_put , "qhash: __qm_put") {
        lstr_t str;

#define CHECK(type, key)  \
        do {                                                                \
            uint32_t pos;                                                   \
                                                                            \
            QM(type, h, true);                                              \
            pos = __qm_put(type, &h, (key), 1, 0);                          \
            Z_ASSERT_EQ(pos & QHASH_COLLISION, 0u);                         \
            pos = __qm_put(type, &h, (key), 2, 0);                          \
            Z_ASSERT_NE(pos & QHASH_COLLISION, 0u);                         \
            Z_ASSERT_EQ(h.values[pos & ~QHASH_COLLISION], 1u);              \
            pos = __qm_put(type, &h, (key), 2, QHASH_OVERWRITE);            \
            Z_ASSERT_NE(pos & QHASH_COLLISION, 0u);                         \
            Z_ASSERT_EQ(h.values[pos & ~QHASH_COLLISION], 2u);              \
                                                                            \
            qm_wipe(type, &h);                                              \
        } while (0)

        /* IKEY */
        CHECK(test, 1);

        /* VKEY */
        str = LSTR_IMMED_V("foo");
        CHECK(test_lstr, &str);

        /* PKEY */
        CHECK(test_ptr, (void *)0xf00);

#undef CHECK

    } Z_TEST_END

    Z_TEST(shrink_bug , "qhash: test for hdr->bits overflow after shrink") {
        qh_t(u32) qh;

        qh_init(u32, &qh, false);

        qh_set_minsize(u32, &qh, 1);
        Z_ASSERT_N(qh_add(u32, &qh, 0));
        Z_ASSERT_EQ(qh.hdr.size, 11U);
        /* Force qh.hdr.size to grow up to x16 */
        for (int i = 1; i < 8192; i++) {
            Z_ASSERT_N(qh_add(u32, &qh, i));
        }
        Z_ASSERT_EQ(qh.hdr.size, 12289U);

        /* Remove some elements */
        for (int i = 1; i < 8191; i++) {
            if (i % 42 == 0)
                continue;
            qh_del_key(u32, &qh, i);
        }
        Z_ASSERT_EQ(qh.hdr.len, 197U);
        Z_ASSERT_EQ(qh.hdr.size, 12289U);

        /* Now add one element which should force a shrink */
        Z_ASSERT_N(qh_add(u32, &qh, 1));
        Z_ASSERT_EQ(qh.hdr.len, 198U);
        Z_ASSERT_EQ(qh.hdr.size, 3079U);
        Z_ASSERT_P(qh.old);

        qh_for_each_pos(u32, pos, &qh) {
            qh_del_at(u32, &qh, pos);
        }
        Z_ASSERT_EQ(qh.hdr.len, 0U);

        qh_wipe(u32, &qh);
    } Z_TEST_END
} Z_GROUP_END

/*1}}}*/
/*{{{1 QHhash */

/* Keep these here, it's to check the macros are used and built */
qhh_k32_t(test, 16);
qhh_k64_t(test_qh_64, 16);

qhm_k32_t(test, 16, uint32_t);
qhm_k64_t(test_qh_64, 16, uint32_t);

qhh_kptr_ckey_t(test_str, 16, char, qhhash_str_hash, qhhash_str_equal);

qhm_kvec_t(test_lstr, 16, lstr_t, uint32_t, qhhash_lstr_hash, qhhash_lstr_equal);
qhm_kptr_t(test_ptr,  16, void,   uint32_t, qhhash_hash_ptr,  qhhash_ptr_equal);

Z_GROUP_EXPORT(qhugehash)
{
    Z_TEST(insertion, "qhhash: insertion") {
        qhh_t(test) h;
        uint64_t bits[2] = { 0, 0 };

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
            SET_BIT(bits, i);
        }
        Z_ASSERT_EQ(h.hdr.len, 128U);

        qhh_for_each_pos(test, pos, &h) {
            uint32_t v = *qhh_key_p(test, &h, pos);

            Z_ASSERT(v < bitsizeof(bits) && TST_BIT(bits, v));
            CLR_BIT(bits, v);
        }

        Z_ASSERT(bits[0] == 0, "all values should have been seen");
        Z_ASSERT(bits[1] == 0, "all values should have been seen");
        qhh_deep_wipe(test, &h, IGNORE);
    } Z_TEST_END;

    Z_TEST(collision, "qhhash: collision") {
        qhh_t(test) h;

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
        }

        for (int i = 0; i < 128; i++) {
            Z_ASSERT(qhh_add(test, &h, i), "double insertion of %d", i);
        }

        qhh_deep_clear(test, &h, IGNORE);
        Z_ASSERT_ZERO(qhh_len(test, &h));
        qhh_clear(test, &h);
        qhh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(self, "qhhash: self search") {
        qhh_t(test) h;

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
        }
        Z_ASSERT_EQ(qhh_len(test, &h), 128ul);

        for (int i = 128; i-- > 0; ) {
            int64_t pos = qhh_find(test, &h, i);

            Z_ASSERT(pos >= 0, "qh_find should find %d", i);
            qhh_del_at(test, &h, pos);
        }

        Z_ASSERT_ZERO(qhh_len(test, &h));

        qhh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(string, "qhhash: string") {
        const char *t1 = "test1";
        const char *t2 = "test2";
        int64_t pos;
        qhh_t(test_str) h;

        qhh_init(test_str, &h, false);

        Z_ASSERT_N(qhh_add(test_str, &h, t1));
        Z_ASSERT_N(qhh_add(test_str, &h, t2));

        pos = qhh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t1);
        Z_ASSERT_STREQUAL(*qhh_key_p(test_str, &h, pos), t1);

        pos = qhh_find(test_str, &h, t2);
        Z_ASSERT(pos >= 0, "qh_find should find %s", t2);

        Z_ASSERT_EQ(qhh_len(test_str, &h), 2ul);

        qhh_del_at(test_str, &h, pos);
        Z_ASSERT_EQ(qhh_len(test_str, &h), 1ul);
        qhh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(*qhh_key_p(test_str, &h, i), t1,
                              "qh_for_each_pos has failed");
        }

        /* Remove t1 */
        pos = qhh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qhh_del_at(test_str, &h, pos);
        Z_ASSERT_ZERO(qhh_len(test_str, &h));

        qhh_add(test_str, &h, t1);
        Z_ASSERT_EQ(qhh_len(test_str, &h), 1ul);

        pos = qhh_find(test_str, &h, t1);
        Z_ASSERT(pos >= 0, "can't find t1 ('%s')", t1);
        qhh_for_each_pos(test_str, i, &h) {
            Z_ASSERT_STREQUAL(*qhh_key_p(test_str, &h, i), t1,
                              "2nd qh_for_each_pos has failed");
        }
        qhh_wipe(test_str, &h);
    } Z_TEST_END;

    Z_TEST(qhh_hash, "qhhash: qhh_hash/qhh_del_key_h") {
        qhh_t(test) h;

        qhh_init(test, &h, false);

        for (int i = 0; i < 128; i++) {
            Z_ASSERT_N(qhh_add(test, &h, i));
        }

        for (int i = 128; i-- > 0; ) {
            uint32_t hash = qhh_hash(test, &h, i);
            int64_t  pos;

            pos = qhh_del_key_h(test, &h, hash, i);
            Z_ASSERT(pos >= 0, "qh_find should find %d", i);
        }

        Z_ASSERT_ZERO(qhh_len(test, &h));

        qhh_wipe(test, &h);
    } Z_TEST_END;

    Z_TEST(qhm_hash, "qhhash: qhm_hash/qhm_del_key_h") {
        qhm_t(test) h;

        qhm_init(test, &h, false);

        for (uint32_t i = 0; i < 128; i++) {
            Z_ASSERT_N(qhm_add(test, &h, i, i));
        }

        for (uint32_t i = 128; i-- > 0; ) {
            uint32_t hash = qhm_hash(test, &h, i);
            int64_t  pos;

            pos = qhm_del_key_h(test, &h, hash, i);
            Z_ASSERT(pos >= 0, "qm_find should find %d", i);
            Z_ASSERT_EQ(*qhm_value_p(test, &h, pos), i);
        }

        Z_ASSERT_ZERO(qhm_len(test, &h));

        qhm_deep_clear(test, &h, IGNORE, IGNORE);
        qhm_clear(test, &h);
        qhm_deep_wipe(test, &h, IGNORE, IGNORE);
    } Z_TEST_END;

    Z_TEST(__qhm_put , "qhhash: __qhm_put") {
        lstr_t str;

#define CHECK(type, key)  \
        do {                                                                \
            uint64_t pos;                                                   \
            qhm_t(type) h;                                                  \
                                                                            \
            qhm_init(type, &h, true);                                       \
            pos = __qhm_put(type, &h, (key), 1, 0);                         \
            Z_ASSERT_EQ(pos & QHASH_COLLISION, 0u);                         \
            pos = __qhm_put(type, &h, (key), 2, 0);                         \
            Z_ASSERT_NE(pos & QHASH_COLLISION, 0u);                         \
            Z_ASSERT_EQ(*qhm_value_p(type, &h, pos), 1u);                   \
            pos = __qhm_put(type, &h, (key), 2, QHASH_OVERWRITE);           \
            Z_ASSERT_NE(pos & QHASH_COLLISION, 0u);                         \
            Z_ASSERT_EQ(*qhm_value_p(type, &h, pos), 2u);                   \
            qhm_wipe(type, &h);                                             \
        } while (0)

        /* IKEY */
        CHECK(test, 1);

        /* VKEY */
        str = LSTR_IMMED_V("foo");
        CHECK(test_lstr, &str);

        /* PKEY */
        CHECK(test_ptr, (void *)0xf00);

#undef CHECK

    } Z_TEST_END

} Z_GROUP_END

/*1}}}*/
/*{{{1 Qvectors */

static _Bool qv_sort_tst(void)
{
    bool ok = true;
    qv_t(u32) tab;

#define N  128
    qv_inita(u32, &tab, N);
    for (int i = 0; i < N; i++)
        qv_append(u32, &tab, rand());
    qv_sort(u32)(&tab, ^int (const uint32_t *v1, const uint32_t *v2) {
        return CMP(*v1, *v2);
    });
    for (int i = 1; ok && i < tab.len; i++) {
        ok = tab.tab[i - 1] <= tab.tab[i];
    }
#undef N

    return ok;
}

static void build_sorted_uniq_vec(qv_t(u32) *vec)
{
#define N  1024
    int size = ha_rand_range(0, N);

    for (int i = 0; i < size; i++) {
        qv_append(u32, vec, ha_rand_range(0, 4 * N));
    }
    dsort32(vec->tab, vec->len);
    vec->len = uniq32(vec->tab, vec->len);
#undef N
}

/* XXX: qv_diff performed in a separate function as block rewriting inside
 * Z_GROUP_EXPORT breaks compilation */
static void do_qv_diff(qv_t(u32) *vec1, qv_t(u32) *vec2,
                       qv_t(u32) *add, qv_t(u32) *del, qv_t(u32) *inter)
{
    qv_diff(u32)(vec1, vec2, add, del, inter,
                 ^int (const uint32_t *v1, const uint32_t *v2) {
                     return CMP(*v1, *v2);
                 });
}

static _Bool qv_search_tst(void)
{
    t_scope;

    qv_t(i32) vec;
    int N = 10;
    qv_cmp_b(i32) cmp = ^int (const int32_t* a, const int32_t* b){
        return CMP(*a, *b);
    };

    t_qv_init(i32, &vec, N);
    for (int i = 0; i < N; i++)
        qv_append(i32, &vec, 1 + i * 2);

    for (int i = -2; i < 2 * N + 2; i++) {
        bool found_bisect = false;
        int pos_bisect = qv_bisect(i32)(&vec, i, &found_bisect, cmp);
        int pos_find = qv_find(i32)(&vec, i, true, cmp);
        bool contain = qv_contains(i32)(&vec, i, true, cmp);

        /* compare with result on assumed unsorted vector */
        THROW_FALSE_IF(pos_find != qv_find(i32)(&vec, i, false, cmp));
        THROW_FALSE_IF(contain != qv_contains(i32)(&vec, i, false, cmp));

        if (i < 1) {
            THROW_FALSE_IF(pos_bisect != 0);
            THROW_FALSE_IF(pos_find != -1);
        } else
        if (i < 1 + N * 2) {
            THROW_FALSE_IF(found_bisect != i % 2);
            if (found_bisect) {
                THROW_FALSE_IF(pos_bisect != (i - 1) / 2);
                THROW_FALSE_IF(pos_find   != (i - 1) / 2);
            } else {
                THROW_FALSE_IF(pos_bisect != (i - 1) / 2 + 1);
                THROW_FALSE_IF(pos_find   != -1);
            }
        } else {
            THROW_FALSE_IF(found_bisect);
            THROW_FALSE_IF(pos_bisect != N);
            THROW_FALSE_IF(pos_find != -1);
        }
        THROW_FALSE_IF(found_bisect != contain);
    }

    return true;
}

Z_GROUP_EXPORT(qvector)
{
    Z_TEST(qv_for_each, "qvector: enumerations") {
        t_scope;
        uint32_t table[] = { 8, 9, 1, 2, 5 };
        int it;
        qv_t(u32) vec;

        t_qv_init(u32, &vec, countof(table));
        it = 0;
        qv_for_each_pos(u32, pos, &vec) {
            it++;
        }
        Z_ASSERT_ZERO(it);
        qv_for_each_pos_safe(u32, pos, &vec) {
            it++;
        }
        Z_ASSERT_ZERO(it);

        qv_for_each_ptr(u32, ptr, &vec) {
            it++;
        }
        Z_ASSERT_ZERO(it);

        qv_for_each_entry(u32, e, &vec) {
            IGNORE(e);
            it++;
        }
        Z_ASSERT_ZERO(it);

        qv_splice(u32, &vec, 0, 0, table, countof(table));

        qv_for_each_pos(u32, pos, &vec) {
            Z_ASSERT_EQ(pos, it);
            it++;
        }
        Z_ASSERT_EQ(it, vec.len);
        qv_for_each_pos_safe(u32, pos, &vec) {
            it--;
            Z_ASSERT_EQ(pos, it);
        }
        Z_ASSERT_ZERO(it);

        it = 0;
        qv_for_each_ptr(u32, ptr, &vec) {
            Z_ASSERT_EQ(*ptr, table[it]);
            it++;
        }
        Z_ASSERT_EQ(it, vec.len);

        it = 0;
        qv_for_each_entry(u32, e, &vec) {
            Z_ASSERT_EQ(e, table[it]);
            it++;
        }
        Z_ASSERT_EQ(it, vec.len);
    } Z_TEST_END;

    Z_TEST(qv_sort, "qvector: qv_sort") {
        Z_ASSERT(qv_sort_tst());
    } Z_TEST_END;

    Z_TEST(qv_diff, "qvector: qv_diff") {
        /* {{{ */
#define N  1024
        t_scope;
        qv_t(u32) vec1, vec2, add, del, inter;

        t_qv_init(u32, &vec1,  N);
        t_qv_init(u32, &vec2,  N);
        t_qv_init(u32, &add,   N);
        t_qv_init(u32, &del,   N);
        t_qv_init(u32, &inter, N);

        build_sorted_uniq_vec(&vec1);
        build_sorted_uniq_vec(&vec2);

        do_qv_diff(&vec1, &vec2, &add, &del, &inter);

        Z_ASSERT(add.len   == (int)uniq32(add.tab,   add.len));
        Z_ASSERT(del.len   == (int)uniq32(del.tab,   del.len));
        Z_ASSERT(inter.len == (int)uniq32(inter.tab, inter.len));

        qv_for_each_pos(u32, pos, &add) {
            Z_ASSERT(!contains32(add.tab[pos], vec1.tab, vec1.len)
                     && contains32(add.tab[pos], vec2.tab, vec2.len));
        }
        qv_for_each_pos(u32, pos, &del) {
            Z_ASSERT(contains32(del.tab[pos], vec1.tab, vec1.len)
                     && !contains32(del.tab[pos], vec2.tab, vec2.len));
        }
        qv_for_each_pos(u32, pos, &inter) {
            Z_ASSERT(contains32(inter.tab[pos], vec1.tab, vec1.len)
                     && contains32(inter.tab[pos], vec2.tab, vec2.len));
        }
        qv_for_each_pos(u32, pos, &vec1) {
            Z_ASSERT(contains32(vec1.tab[pos], vec2.tab, vec2.len)
                     || contains32(vec1.tab[pos], del.tab,  del.len));
            Z_ASSERT(!contains32(vec1.tab[pos], vec2.tab, vec2.len)
                     || contains32(vec1.tab[pos], inter.tab, inter.len));
        }
        qv_for_each_pos(u32, pos, &vec2) {
            Z_ASSERT(contains32(vec2.tab[pos], vec1.tab, vec1.len)
                     || contains32(vec2.tab[pos], add.tab,  add.len));
            Z_ASSERT(!contains32(vec2.tab[pos], vec1.tab, vec1.len)
                     || contains32(vec2.tab[pos], inter.tab, inter.len));
        }

        /* Test that passing NULL to add, del and inter doesn't segfault */
        do_qv_diff(&vec1, &vec2, NULL, NULL, NULL);
#undef N
        /* }}} */
    } Z_TEST_END;

    Z_TEST(qv_search, "qvector: bisect, find and contains") {
        Z_ASSERT(qv_search_tst());
    } Z_TEST_END;
} Z_GROUP_END;

/*1}}}*/
/*{{{1 Heap */

Z_GROUP_EXPORT(qhp)
{
    Z_TEST(sort, "qhp: sort") {
        qhp_t(i32_min)  qhp;
        int32_t         tab[] = { 5, 2, 9, 7, 1, 3, 0, 8, 6, 4 };

        qhp_inita(i32_min, &qhp, countof(tab));

        for (int i = 0; i < countof(tab); i++) {
            qhp_insert(i32_min, &qhp, tab[i]);
            Z_ASSERT_EQ(qhp_len(i32_min, &qhp), i + 1, "unexpected length");
        }

        for (int i = 0; i < countof(tab); i++) {
            int it;

            Z_ASSERT(!qhp_is_empty(i32_min, &qhp), "qhp is empty");
            it = qhp_take_first(i32_min, &qhp);

            Z_ASSERT_EQ(it, i, "expected `%d', got `%d'", i, it);
        }
    } Z_TEST_END

    Z_TEST(inline_struct, "qhp: inline structure") {
        qhp_t(inl_heap)  qhp;
        int32_t          tab[] = { 5, 2, 9, 7, 1, 3, 0, 8, 6, 4 };

        qhp_inita(inl_heap, &qhp, countof(tab));

        for (int i = 0; i < countof(tab); i++) {
            test_node_inl_t node = { .val = tab[i] };
            int pos;

            pos = qhp_insert(inl_heap, &qhp, node);
            node = qhp_get(inl_heap, &qhp, pos);
            Z_ASSERT_EQ(pos, node.pos, "invalid position after insertion: "
                        "expected `%d', got `%d'", pos, node.pos);
        }

        qhp_for_each_pos(inl_heap, pos, &qhp) {
            test_node_inl_t node = qhp_get(inl_heap, &qhp, pos);
            Z_ASSERT_EQ(pos, node.pos, "invalid position: "
                        "expected `%d', got `%d'", pos, node.pos);
        }
    } Z_TEST_END

    Z_TEST(remove, "qhp: remove") {
        t_scope;
        qhp_t(test_heap) qhp;
        int             tab[]       = { 5, 2, 9, 7, 1, 3, 0, 8, 6, 4 };
        int             to_remove[] = {       2,          6,       9 };
        int             expected[]  = {    1, 2, 3,    5, 6, 7, 8,   };
        test_node_t     nodes[countof(tab)];

        STATIC_ASSERT (countof(expected)
                    == countof(tab) - countof(to_remove));

        p_clear(nodes, countof(nodes));
        t_qhp_init(test_heap, &qhp, 1024);

        for (int i = 0; i < countof(tab); i++) {
            nodes[i].val = tab[i];
            qhp_insert(test_heap, &qhp, &nodes[i]);
        }

        for (int i = 0; i < countof(to_remove); i++) {
            test_node_t *node = &nodes[to_remove[i]];
            test_node_t *removed;

            Z_ASSERT_EQ(qhp_len(test_heap, &qhp), countof(nodes) - i,
                        "unexpected qhp length");
            removed = qhp_remove(test_heap, &qhp, node->pos);
            Z_ASSERT(node == removed, "removed wrong node");
        }

        Z_ASSERT_EQ(qhp_len(test_heap, &qhp), countof(expected),
                    "unexpected qhp length");

        for (int i = 0; i < countof(expected); i++) {
            int val = qhp_take_first(test_heap, &qhp)->val;

            Z_ASSERT_EQ(expected[i], val, "expected `%d', got `%d'",
                        expected[i], val);
        }

        Z_ASSERT(qhp_is_empty(test_heap, &qhp), "qhp is not empty");
    } Z_TEST_END

    Z_TEST(lstr, "qhp: lstr") {
        t_scope;
        qhp_t(lstr_min)  qhp;
        lstr_t           toto = LSTR_IMMED_V("toto");
        lstr_t           tata = LSTR_IMMED_V("tata");
        lstr_t           tutu = LSTR_IMMED_V("tutu");

        t_qhp_init(lstr_min, &qhp, 3);

        qhp_insert(lstr_min, &qhp, &toto);
        qhp_insert(lstr_min, &qhp, &tata);
        qhp_insert(lstr_min, &qhp, &tutu);

        Z_ASSERT_LSTREQUAL(tata, *qhp_take_first(lstr_min, &qhp),
                           "expected \"toto\"");
        Z_ASSERT_LSTREQUAL(toto, *qhp_take_first(lstr_min, &qhp),
                           "expected \"tata\"");
        Z_ASSERT_LSTREQUAL(tutu, *qhp_take_first(lstr_min, &qhp),
                           "expected \"tutu\"");
    } Z_TEST_END
} Z_GROUP_END

/*1}}}*/
/*{{{1 Red-Black Tree */

typedef struct {
    int       v;
    rb_node_t link;
} rb_test_t;
GENERIC_FUNCTIONS(rb_test_t, rb_test);

#define RB_TEST_GET_KEY(rb_test)  (rb_test)->v

rb_tree_t(rb_test, rb_test_t, int, link, RB_TEST_GET_KEY, CMP);

Z_GROUP_EXPORT(rbt)
{
    Z_TEST(insert, "") {
        rb_t(rb_test)  rbt;
        rb_test_t     *t1, *t2;

        rb_init(rb_test, &rbt);
        t1 = rb_test_new();
        t2 = rb_test_new();

        t1->v = 2;
        t2->v = 5;

        Z_ASSERT_NULL(rb_insert(rb_test, &rbt, t1),  "insertion #1");
        Z_ASSERT_NULL(rb_insert(rb_test, &rbt, t2),  "insertion #2");
        Z_ASSERT(rb_find(rb_test, &rbt, 2) == t1,  "find #1");
        Z_ASSERT_NULL(rb_find(rb_test, &rbt, 3), "find #2");
        Z_ASSERT(rb_find(rb_test, &rbt, 5) == t2,  "find #3");
        rb_remove(rb_test, &rbt, t1);
        Z_ASSERT_NULL(rb_find(rb_test, &rbt, 2), "deletion #1");
        Z_ASSERT(rb_find(rb_test, &rbt, 5) == t2,  "find #4");
        rb_remove(rb_test, &rbt, t2);
        Z_ASSERT_NULL(rb_find(rb_test, &rbt, 5), "deletion #2");

        rb_test_delete(&t1);
        rb_test_delete(&t2);
    } Z_TEST_END

    Z_TEST(upper_lower, "") {
        rb_t(rb_test) rbt;

        rb_init(rb_test, &rbt);
        for (int i = 0; i <= 10; i++) {
            rb_test_t *t = rb_test_new();

            t->v = 2 * i;
            Z_ASSERT_NULL(rb_insert(rb_test, &rbt, t), "%d", i);
        }

        for (int i = -1; i < 22; i++) {
            rb_test_t *t;

            if (!(i % 2)) {
                Z_ASSERT(t = rb_find(rb_test, &rbt, i), "%d", i);
                Z_ASSERT_EQ(i, t->v, "%d", i);

                Z_ASSERT(t = rb_find_upper(rb_test, &rbt, i), "%d", i);
                Z_ASSERT_EQ(i, t->v, "%d", i);

                Z_ASSERT(t = rb_find_lower(rb_test, &rbt, i), "%d", i);
                Z_ASSERT_EQ(i, t->v, "%d", i);
            } else {
                Z_ASSERT_NULL(rb_find(rb_test, &rbt, i), "%d", i);

                if (i < 20) {
                    Z_ASSERT(t = rb_find_upper(rb_test, &rbt, i), "%d", i);
                    Z_ASSERT_EQ(i + 1, t->v, "%d", i);
                } else {
                    Z_ASSERT_NULL(rb_find_upper(rb_test, &rbt, i), "%d", i);
                }

                if (i > 0) {
                    Z_ASSERT(t = rb_find_lower(rb_test, &rbt, i), "%d", i);
                    Z_ASSERT_EQ(i - 1, t->v, "%d", i);
                } else {
                    Z_ASSERT_NULL(rb_find_lower(rb_test, &rbt, i), "%d", i);
                }
            }
        }

        rb_deep_wipe(rb_test, &rbt, rb_test_delete);
    } Z_TEST_END;
} Z_GROUP_END

/*1}}}*/
