#!/usr/bin/python

import subprocess as S
import sys, os, re

linere = re.compile('tst (?P<res>[a-z]*) (?P<file>[^:]*):(?P<line>[0-9]*):(?P<desc>.*)')
modre  = re.compile('(?P<mod>[^:]*): *(?P<rest>.*)')

if os.getenv("TERM") and sys.stdout.isatty():
    def mkcolor(color, txt, bold = 1):
        return "\033[%d;%im%s\033[0m" % (bold, color, txt)
else:
    def mkcolor(color, txt):
        return txt

def print_report1(color, pfx, g):
    sys.stdout.write("%s:%s:%s %s\n" % (g['file'], g['line'], mkcolor(color, pfx), g['desc']))

def full_report(file, g):
    tfail = g['fail']
    tpass = g['pass']
    tskip = g['skip']
    total = tfail + tpass + tskip
    sys.stdout.write("%24s  " % (file));
    sys.stdout.write(mkcolor(32, "PASS: %3d  " % (tpass)))
    if tskip:
        sys.stdout.write(mkcolor(33, "SKIP: %3d  " % (tskip)))
    if tfail:
        sys.stdout.write(mkcolor(31, "FAIL: %3d  " % (tfail)))
    modreres = modre.match(g['desc'])
    if modreres:
        d = modreres.groupdict()
        sys.stdout.write("--  %s: %s\n" % (mkcolor(33, d['mod'], 0), d['rest']))
    else:
        sys.stdout.write("--  %s\n" % (g['desc']))
    sys.stdout.flush()

def parse_lines(file, lines):
    res = 0
    cur = None
    for line in lines:
        reres = linere.match(line)
        if not reres: continue
        g = reres.groupdict()

        if g['res'] == 'desc':
            if cur:
                full_report(file, cur)
            cur = g
            cur['pass'] = 0
            cur['fail'] = 0
            cur['skip'] = 0
            continue

        if g['res'] not in ('skip', 'pass', 'fail'):
            sys.stderr.write("Unknown tst command %s\n" % (g['res']))
            sys.exit(-1)

        if g['res'] == 'fail':
            res = 1
            cur['fail'] += 1
            print_report1(31, "fail", g)
        else:
            if g['res'] == 'skip':
                print_report1(33, "skip", g)
            cur[g['res']] += 1
    if cur:
        full_report(file, cur)
    return res

def run_test(file):
    try:
        p = S.Popen([file], stdout=None, stderr=S.PIPE)
        lines = p.communicate()[1].split("\n")
        if p.returncode:
            parse_lines(file, lines)
            sys.stderr.write("%s: %s returned with value %d\n" %
                    (mkcolor(31, "FAIL"), file, p.returncode))
            return 1
        return parse_lines(file, lines)
    except OSError, e:
        sys.stderr.write("unable to fork %s: %s\n" % (file, os.strerror(e.errno)))
        return 1

if __name__ == "__main__":
    res = 0
    #TODO: run tests in parallel
    for file in sys.argv[1:]:
        res += run_test(file)
    sys.exit(res and 1)
