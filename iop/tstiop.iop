/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2004-2016 INTERSEC SA                                   */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/


/* This file is used to test the IOPs and act as a non-regression test. This
 * file should always compile correctly */
package tstiop;

/* Types of base */

struct HashV1 {
    bool?  b;
    int[]  i;
    string s;
};

struct HashV2 {
    bool?  b;
    long[] i;
    string s;
};

@(test:gen1, 1)
enum MyEnumA {
    @(test:gen2, 2.2)
    A = 0x0,
    B = 0x1,
    C = 0x2,
};

@strict
enum MyEnumB {
    A,
    B,
    C,
};

union MyUnionA {
    int    ua;
    byte   ub;
    string us;
};

union MyUnionB {
    int         bval;
    MyUnionA    a;
};

union MyUnionC {
    int iOfC;
    double dOfC;
};

class MyClass1 : 1 {
    int int1;
};

class MyClass2 : 2 :MyClass1 {
    int int2;
};

class MyClass3 : 3 : MyClass2 {
    int int3;
    bool bool1;
    string? string1;
};


@(test:gen3, "3")
@(test:json, "field": { "f1": "val1", "f2": -1.0e2 } )
struct MyStructA {
    @(test:gen4, 4)
    int a;
    uint b;
    byte cOfMyStructA;
    ubyte d;
    short e;
    ushort f;
    long g;
    ulong h;
    ulong[] htab;
    bytes i;
    string j;
    xml xmlField;
    MyEnumA k;
    MyUnionA l;
    MyUnionA& lr;
    MyClass2 cls2;
    double m;
    bool n;
    int p;
    int q;
    int r;
    int s;
    int t;
};

struct MyStructAOpt {
    int? a;
    uint? b;
    byte? cOfMyStructA;
    ubyte? d;
    short? e;
    ushort? f;
    long? g;
    ulong? h;
    bytes? i;
    string? j;
    MyEnumA? k;
    MyUnionA? l;
    MyUnionA? lr;
    double? m;
    bool? n;
    MyStructB? o;
    MyClass2? cls2;
    int? p;
    int? q;
    int? r;
    int? s;
    int? t;
};

struct MyStructB {
    int? a;
    int[] b;
};


/* Recursion */
struct MyStructC {
    int a;
    MyStructC? b;
    MyStructC[] c;
};

/* Tags */
struct MyStructD {
0x2:
    int a;
42:
    int b;
};

struct MyStructE {
    int a;
    MyUnionA b;
    MyStructB c;
};

struct MyStructF {
    string[] a;
    bytes[] b;
    MyStructB[] c;
    MyUnionA[] d;
    MyClass1[] e;
    MyClass1? f;
};

/* Default values */
struct MyStructG {
    int a       = -1;
    uint b      = 2;
    byte cOfG   = 3;
    ubyte d     = 4;
    short e     = 5;
    ushort f    = 6;
    long g      = 7;
    ulong h     = 8;
    bytes i     = "default data value";
    string j    = "fo\"o?cbaré©";
    MyEnumA k   = MY_ENUM_A_C;
    double l    = 10.5;
    bool m      = true;
};

/* Constant folding */
struct MyStructH {
    int a = 10 + 2 * 3 * 4 - 10;                    // 24 => 0x18
    int b = 10 * 2 + 3 + 4 * 10;                    // 63 => 0x3f
    int c = 8 + 4 + - 2 + 2 * - 5 / 2 + 1;          // 6
    int d = 32 / 4 ** 2 / 2;                        // 1
    int e = 8 / 4 / 2;                              // 1
    int f = 8 / (4 / 2);                            // 4
    int g = 4 ** 3 ** 2;                            // 262144 => 0x40000
    int h = 4 + - 2 ** 2;                           // 0
    int i = 1 + 4 ** 3 ** 1 + 1 - 1;                // 65 => 41
    int j = 0xfffff & 32 << 2 | 3;                  // 131 => 0x83
    int k = (1 << 17) - 1;                          // 131071 => 0x1ffff
    int l = -1 + 2 * 30 + ~3;                       // 55 => 0x37
};

/* Constant folding with enums */
enum MyEnumC {
    A = 1 << 0,
    B = 1 << 1,
    C = 1 << 2,
    D = 1 << 3,
    E = 1 << 4,
};

/* Enum printf formatting with %*pE. */
enum MyEnumD {
    FOO = 0,
    BAR = 2,
    FOO_BAR = 4,
};

struct MyStructI {
    int[]       i;
    long[]      l;
    ulong[]     u;
    double[]    d;
    MyEnumC[]   e;
};

struct MyStructJ {
    int         cval;
    MyUnionB    b;
    MyUnionB[]  btab;
};

struct MyStructK {
    MyStructJ   j;
};

struct MyStructL {
    MyEnumA     a;
    MyEnumB     b;
    MyEnumB[]   btab;
    MyEnumC     c;
};

struct MyStructM {
    MyStructK   k;
};

struct MyStructN {
    ulong u;
    long i;
};

%C{
    qvector_t(my_struct_a, tstiop__my_struct_a__t);
    qvector_t(my_struct_a_opt, tstiop__my_struct_a_opt__t);
    qvector_t(my_struct_g, tstiop__my_struct_g__t);
    qvector_t(my_struct_m, tstiop__my_struct_m__t);
    qvector_t(my_class2, tstiop__my_class2__t *);
%}


struct Repeated {
    /* optimized fields */
    byte[]   i8;
    ubyte[]  u8;
    bool[]   b;
    short[]  i16;
    ushort[] u16;

    /* generic repeated values */
    int[]    i32;
    string[] s;
};

struct ConstraintS {
    @maxOccurs(5) @min(1-(1 << 7))
    byte[]      i8;
    @maxOccurs(5) @min(1-(1 << 15))
    short[]     i16;
    @maxOccurs(5) @min(1-(1 << 31))
    int[]       i32;
    @maxOccurs(5) @min(1-(1 << 63))
    long[]      i64;
    @minOccurs(2) @maxOccurs(5) @minLength(4) @pattern("[a-zA-Z0-9_\-]*")
    string[]    s;
    @private
    bool?       priv;
    @private
    bool        priv2 = true;
    ConstraintS[] tab;
};

union ConstraintU {
    @nonZero @max(1 << 7)
    ubyte   u8;
    @nonZero @max(1 << 15)
    ushort  u16;
    @nonZero @max(1 << 31)
    uint    u32;
    @nonZero @max(1 << 63)
    ulong   u64;
    @nonEmpty @cdata @maxLength(10) @pattern("[^\[\]]*")
    string  s;
    ConstraintS cs;
};

struct MyAException {
    int    errcode;
    string desc;
};

struct MyBException {
    int    errcode;
    string desc;
    bool   foo;
};

union MyExceptions {
    MyAException a;
    MyBException b;
};

struct MyHashed {
    int a;
};

struct MyHashedExtended {
    int a;
    int? b;
    int[] c;
    int d = 12;
    string s = "default-value";
};

struct MyReferencedStruct {
    int a;
};

union MyReferencedUnion {
    int b;
};

struct MyRefStruct {
    MyReferencedStruct& s;
    MyReferencedUnion&   u;
};

union MyRefUnion {
    MyReferencedStruct& s;
    MyReferencedUnion&   u;
};

struct StructJpackFlags {
    @private int? priv;
    int? opt;
    int def = 1;
    int[] rep;
};

/* {{{ zchk iop.iop_for_each_field */

struct MiniStruct {
    int a;
};

struct TabStruct {
    MiniStruct[] tab;
};

union AOrB {
    MiniStruct a;
    int b;
};

struct Void {
};

class Ancestor {
    string name;
};

class GrandPa : 1 : Ancestor {
};

class Daddy : 2 : GrandPa {
    bool? b;
};

struct ObjContainer {
    Ancestor obj;
};

struct ZIopForEach {
    Void voidStruct1;
    int integer;
    uint? optUint1;
    ulong[] ulongTab;
    uint? optUint2;
    MiniStruct miniStruct;
    ulong[] emptyTab;
    TabStruct& refTabStruct;
    AOrB? optUnion1;
    Void voidStruct2;
    AOrB? optUnion2;
    Ancestor ancestor;
    Ancestor[] objTab;
};

/* }}} */

/* Interfaces */

@(test:gen5, 5)
interface MyIfaceA {
    @(test:gen6, 6)
    funA      in (int a, MyStructA b)  out (MyUnionA c, int d);
    funb                               out (int a, int b);
    funC      in MyStructA             out MyStructB;
    funD                               out MyStructA;
    funE      in void                  out (int a);
    funF      in (int a, int b)        out MyStructB;
    funG                               out void;
    funH      in void                  out void;
    funI                               out void;
    funJ      in void                  out void;
    funK      in MyStructA             out (int a, int b);
    funL      in MyUnionA              out void;
    funM      in MyStructA             out (int a, int b) throw (int err);
    funN      in MyStructA             out (int a, int b) throw MyAException;
    funO      in MyStructA             out (int a, int b) throw MyExceptions;
    funAsync  in (int test)            out null;
};

module MyModA {
    MyIfaceA a;
};

interface Iface {
    f in (int i) out (int i);
};

module T {
    Iface iface;
};
