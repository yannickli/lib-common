/**************************************************************************/
/*                                                                        */
/*  Copyright (C) INTERSEC SA                                             */
/*                                                                        */
/*  Should you receive a copy of this source code, you must check you     */
/*  have a proper, written authorization of INTERSEC to hold it. If you   */
/*  don't have such an authorization, you must DELETE all source code     */
/*  files in your possession, and inform INTERSEC of the fact you obtain  */
/*  these files. Should you not comply to these terms, you can be         */
/*  prosecuted in the extent permitted by applicable law.                 */
/*                                                                        */
/**************************************************************************/

#include <sysexits.h>
#include <math.h>
#include <lib-common/parseopt.h>
#include <lib-common/time.h>
#include <lib-common/el.h>
#include "thr.h"

static struct {
    int  help;

    int  sort_minsize;
} _G = {
    .sort_minsize = 128,
};

struct job {
    thr_job_t job;
    int       i;
};

static void run(thr_job_t *job_, thr_syn_t *syn)
{
    struct job *job = container_of(job_, struct job, job);

    job->i = log(job->i);
}

static void test_contention(void)
{
    struct job jobs[2 * thr_parallelism_g * THR_JOB_MAX];

    for (int j = 0; j < 32 << 10; j++) {
        thr_syn_t syn;

        thr_acc_reset();
        thr_syn_init(&syn);
        for (size_t i = 0; i < 2 * thr_parallelism_g * THR_JOB_MAX; i++) {
            jobs[i] = (struct job) {
                .job.run = run,
                .i       = i,
            };
            thr_syn_schedule(&syn, &jobs[i].job);
        }
        thr_syn_wait(&syn);
        thr_acc_trace(0, "");
        thr_syn_wipe(&syn);
    }
}

struct sort_job {
    thr_job_t  job;
    uint32_t  *a;
    size_t     n;
};

static void par_qsort_run(thr_job_t *job, thr_syn_t *syn);
static void par_qsort(thr_syn_t *syn, uint32_t *a, size_t n, bool use_blocks)
{
    uint32_t qstmp, qsop2;
    uint32_t *mean, *i, *j;
    size_t n1;

#define swap(p,q)        (qstmp = *(p), *(p) = *(q), *(q) = qstmp)
#define rotate(p,r,q)    (qstmp = *(p), *(p) = *(r), *(r) = *(q), *(q) = qstmp)
#define comp_gt(a,b)     (*(a) > *(b))

    for (;;) {
        i = a;
        j = a + n - 1;

        if (comp_gt(i, j)) {
            swap(i, j);
        }
        if (n <= 2)
            return;

        mean = i + (n >> 1);
        if (comp_gt(i, mean)) {
            swap(i, mean);
        } else
        if (comp_gt(mean, j)) {
            swap(j, mean);
        }
        if (n == 3)
            return;         /* in case of 3 items */

        qsop2 = *mean;       /* cause *mean is gonna change */

        for (;;) {
            /* We do not have guards in these loops because we assume
             * compare(x, x) returns 0.  If the comparison function is not
             * regular and returns != 0 on identical arguments, all bets
             * are off and this code may crash.
             */
            while (++i, comp_gt(&qsop2, i))  /* find GE in left part */
                continue;

            while (--j, comp_gt(j, &qsop2))  /* find LE in right part */
                continue;

            if (i < j) {
                swap(i, j);        /* swap if needed */
                continue;
            }
            break;
        }

        /* i >= j : we're done and need to recurse on both ranges.
         * either i == j   : don't look at the ith element
         * or     i == j+1 : and split between them.
         */

        /* Fix ranges: [a..i[ U [j+1..a+n[ become [a..a+n[ U [j..j+n1[ */
        j++;
        n1 = a + n - j;
        n  = i - a;

        /* We want to recurse on [a..a+n[ and [j..j+n1[, but in order
         * to minimize stack usage, we only recurse on the smaller
         * range and loop on the other.
         */
        if (n <= n1) {
            SWAP(size_t, n, n1);
            SWAP(uint32_t *, a, j);
        }

        if (n1 > (size_t)_G.sort_minsize) {
            if (use_blocks) {
                thr_syn_schedule_b(syn, ^{ par_qsort(syn, j, n1, true); });
                thr_syn_schedule_b(syn, ^{ par_qsort(syn, a, n, true); });
            } else {
                struct sort_job *job;

                job = p_new_raw(struct sort_job, 1);
                job->job.run = &par_qsort_run;
                job->a    = j;
                job->n    = n1;
                thr_syn_schedule(syn, &job->job);

                job = p_new_raw(struct sort_job, 1);
                job->job.run = &par_qsort_run;
                job->a    = a;
                job->n    = n;
                thr_syn_schedule(syn, &job->job);
            }
            return;
        }

        if (n1 > 1) {
            par_qsort(syn, j, n1, use_blocks);
        }
    }
#undef intersects
#undef swap
#undef rotate
}

__flatten
static void par_qsort_run(thr_job_t *job, thr_syn_t *syn)
{
    struct sort_job *j = container_of(job, struct sort_job, job);

    par_qsort(syn, j->a, j->n, false);
    p_delete(&j);
}

static void test_qsort(bool use_blocks)
{
    t_scope;
    const size_t len = (8 << 20);
    uint32_t *vec[thr_parallelism_g];
    thr_syn_t syn;

    for (size_t j = 0; j < thr_parallelism_g; j++) {
        vec[j] = t_new_raw(uint32_t, len);
        srand(0);
        for (size_t i = 0; i < len; i++) {
            vec[j][i] = (rand() << 16) | rand();
        }
    }

    _G.sort_minsize = MAX(2, _G.sort_minsize);
    thr_acc_reset();
    thr_syn_init(&syn);
    if (use_blocks) {
        for (size_t j = 0; j < thr_parallelism_g; j++) {
            uint32_t *a = vec[j];
            thr_syn_t *synp = &syn;

            thr_syn_schedule_b(&syn, ^{ par_qsort(synp, a, len, true); });
        }
    } else {
        for (size_t j = 0; j < thr_parallelism_g; j++) {
            struct sort_job *job = p_new_raw(struct sort_job, 1);

            job->job.run    = &par_qsort_run;
            job->a          = vec[j];
            job->n          = len;
            thr_syn_schedule(&syn, &job->job);
        }
    }
    thr_syn_wait(&syn);
    thr_acc_trace(0, "%s", __func__);
    thr_syn_wipe(&syn);
}

static void test_queue(void)
{
    size_t n = thr_parallelism_g + 1;
    thr_queue_t *q[n];

    for (size_t i = 0; i < n; i++) {
        q[i] = thr_queue_create();
    }

    for (int i = 0; i < 20; i++) {
        for (size_t j = 0; j < n; j++) {
            thr_queue_b(q[j], ^{ fputc('1' + j, stderr); });
        }
    }
    for (size_t j = 0; j < n; j++) {
        thr_queue_b(q[j], ^{ fputc('A' + j, stderr); });
    }

    for (size_t i = 0; i < n; i++) {
        thr_queue_destroy(q[i], true);
    }

    fputc('\n', stderr);
}

static popt_t popt[] = {
    OPT_GROUP(""),
    OPT_FLAG('h', "help", &_G.help, "show this help"),
    OPT_GROUP("qsort options"),
    OPT_INT(0,    "sort-minsize", &_G.sort_minsize, "sort threshold for jobs"),
    OPT_END(),
};

int main(int argc, char **argv)
{
    const char *arg0 = NEXTARG(argc, argv);

    argc = parseopt(argc, argv, popt, 0);
    if (argc < 1 || _G.help) {
        makeusage(argc < 0 ? EX_USAGE : EX_OK, arg0, "scenario", NULL, popt);
    }

    thr_initialize();
    srand(hardclock());
    thr_acc_set_affinity(rand());

    while (argc > 0) {
        const char *arg = NEXTARG(argc, argv);

        if (strequal("contention", arg)) {
            test_contention();
        } else
        if (strequal("sort_b", arg)) {
            test_qsort(true);
        } else
        if (strequal("sort", arg)) {
            test_qsort(false);
        } else
        if (strequal("queue", arg)) {
            test_queue();
        } else {
            makeusage(EX_USAGE, arg0, "scenario", NULL, popt);
        }
    }
    thr_shutdown();
    return 0;
}
