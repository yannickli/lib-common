=== Standards conformance ===

The platform globally conforms to 'HTTP/1.1' as defined in <<HTTP_1.1>> and to
'SOAP/1.2' as defined in <<SOAP_1.2>>.

==== HTTP/1.1 conformance ====

Platform 'HTTP/1.1' support as a server is complete, including features like
`Expect: 100- continue' or pipelining. Though, unlike what the <<HTTP_1.1>>
standard mandates, the server doesn't support 'HTTP/0.9' requests. It is
to be noted that whereas 'HTTP/1.0' is supported, due to its lack of support
for pipelining and chunked encoding, using 'HTTP/1.0' may yield bad overall
performance.

Our HTTP interfaces support:

-  Pipelining.
-  Garbage collecting of unused connections (after a configurable delay);
-  Automatic recycling of connections after a configurable amount of requests;
-  Basic HTTP Authentication (no Digest support
footnote:[Digest HTTP Authentication makes life harder for clients wishing to
use pipelining, hence is not implemented.  If additional security is needed,
using an HTTPS-enabled reverse proxy is suggested.]).

==== SOAP conformance ====

The platform tries to make use of the SOAP Exceptions where possible. Though,
in a few (rare) cases, it uses HTTP errors instead:

-  Authentication errors: these are caught early in the Intersec HTTP layer,
   before they are sent to the SOAP layer. The HTTP 401 ('Unauthorized') error
   code is used instead.
-  Internal server errors: some of the internal server errors of the Intersec
   HTTP layer may be triggered before the SOAP layer is actually used. The
   client application should hence be able to deal with HTTP transport errors.
   Though, those errors are very unlikely in the presence of a valid SOAP Query.

The platform doesn't use SOAP with attachments, and expects SOAP
queries/responses not to be multi-part.

=== Interfaces constraints ===

==== Size of application queries ====

For performance reasons, queries must stay below a 2 MB limit.
The platform will ignore requests with larger query sizes.

==== Size of responses towards applications ====

To find a fair trade-off between the responses size, network latencies and
batch processing, we will try to limit its responses to 10 MB. This limit is
a fuzzy one though, as it may decide to limit the significant part of a payload
to 10 MB, and add some additional wrapping XML tags. The additional payload
should always be under a few kilobytes though.

=== Intersec Web services use of XML Schema ===

====  XML Basic Types ====

The Intersec web services can use the following <<XMLSchema>> types:

-  +byte+ and +unsignedByte+;
-  +short+ and +unsignedShort+;
-  +int+ and +unsignedInt+;
-  +long+ and +unsignedLong+;
-  +boolean+;
-  +double+;
-  +string+;
-  +base64Binary+;
-  +any+.

In addition to those, some of the APIs use a notion near the C so called
'enumeration'. In that case, the field can take various string values or an
integer one. For example, an enumeration with the possibilities ENUM_A, ENUM_B,
ENUM_C will be described with the following XML Schema description:

----------------------------------
<simpleType name="MyEnum">
    <union>
        <simpleType>
            <restriction base="string">
                <enumeration value="ENUM_A" />
                <enumeration value="ENUM_B" />
                <enumeration value="ENUM_C" />
            </restriction>
        </simpleType>
        <simpleType>
            <restriction base=”integer” />
        </simpleType>
    </union>
</simpleType>
----------------------------------

==== Complex types ====

Only the XML Schema 'choice' and 'sequence' are used to build complex types. It
is to be noted that the XML Schema 'sequence' is ordered. So for the given
following XML Schema type:

----------------------------------
<complexType name="MyType">
   <sequence>
      <element name="a" type="string">
      <element name="b" type="string">
   </sequence>
</complexType>
----------------------------------

The following XML fragment isn't valid, because the tags ``a'' and ``b'' aren't
in the proper order.

----------------------------------
<b>some value</b>
<a>some other value</a>
----------------------------------

[[repeat-optional]]
==== Repeated field, optional fields ====

Finally, the Intersec SOAP web services make use of three kinds of fields:

- Optional fields (+minOccurs="0" maxOccurs="1"+);
- Mandatory fields (default);
- Repeated fields (+minOccurs="0"+).


=== Intersec descriptive language ===

XML can be a bit tedious to work with, that's why Intersec uses a more readable
notation to describe its interfaces. This section describes the Intersec
conventions and this notation.

==== Types ====

The Intersec descriptive language is syntactically a C-like footnote:[Some will
say Java-like] descriptive language. Basic XML types are mapped as follows:

[options="header"]
|===
| XML Schema        | Intersec notation
| +byte+            | +byte+
| +unsignedByte+    | +ubyte+
| +short+           | +short+
| +unsignedShort+   | +ushort+
| +int+             | +int+
| +unsignedInt+     | +uint+
| +long+            | +long+
| +unsignedLong+    | +ulong+
| +boolean+         | +bool+
| +double+          | +double+
| +string+          | +string+
| +base64Binary+    | +bytes+
| +any+             | +xml+
|===

The XML 'sequence' is mapped to the keyword 'struct', the XML 'choice' to the keyword
'union', and the XML 'enumeration' to the keyword 'enum'.

For example:

[cols="1asciidoc,2asciidoc",options="header"]
|===
| Intersec notation | XML Schema
|
----------------------------------
struct MyType {
    int    i;
    string s;
};
----------------------------------
|
----------------------------------
<complexType name="MyType">
    <sequence>
        <element name="i" type="int"/>
        <element name="s" type="string"/>
    </sequence>
</complexType>
----------------------------------

|
----------------------------------
union OtherType {
    MyType t;
    ulong  ul;
};
----------------------------------
|
----------------------------------
<complexType name="OtherType">
    <choice>
        <element name="t" type="MyType"/>
        <element name="ul"
                 type="unsignedLong"/>
    </choice>
</complexType>
----------------------------------
|===

==== Additional features ====

As described in <<repeat-optional,Repeated field - optional fields>>, types may
use optional and repeated fields.  The Intersec notation actually supports four
forms for fields:

-   Mandatory fields (default);
-   Optional fields: the type has a postfix question mark ``?'';
-   Repeated fields: the type has a postfix pair of brackets, like the standard C/Java array
notation ``[]'';
-   Optional fields with default values: the field name is postfixed with the default value
    the element takes if not specified.

For example:

[cols="2asciidoc,5asciidoc",options="header"]
|===
| Intersec notation | XML Schema

2+^e|Mandatory string field
|
----------------------------------
string s;
----------------------------------
|
----------------------------------
<element name="s" type="string" />
----------------------------------

2+^e|Optional field of type SomeType
|
----------------------------------
SomeType? t;
----------------------------------
|
----------------------------------
<element name="t" type="SomeType"
         minOccurs="0" maxOccurs"1" />
----------------------------------

2+^e|Repeated field of type int
|
----------------------------------
int[] array;
----------------------------------
|
----------------------------------
<element name="array" type="int"
         minOccurs="0" maxOccurs"unbounded" />
----------------------------------

2+^e|Optional field of type string with default value ``foo''
|
----------------------------------
string s = "foo";
----------------------------------
|
----------------------------------
<element name="s" type="string"
         minOccurs="0" maxOccurs"1" />
----------------------------------

Plus the information that an absent field is equivalent as having explicitly
specified +<s>foo</s>+.

This semantics is different from the following XML Schema ``default'' element
attribute. Indeed, the following XML Schema definition:

----------------------------------
<element name="s" type="string" default="foo" />
----------------------------------
means that +<s/>+ is equivalent to +<s>foo</s>+, but an absent element is still
``absent''.

|===

==== Remote Procedure Calls ====

The Intersec Notation also applies to the SOAP Procedure Calls (known as SOAP
operations).  The <<WSDL_1.1>> description for a SOAP Remote Procedure Call is
really hard to read, hence we won't even try to describe how to map the
Intersec description language to the <<WSDL_1.1>>. We will instead explain how
to get the input and output SOAP Message types from our notation.

The description for a callback is as follows:

----------------------------------
rpcspec ::= rpcName [in <msgspec>] [out <msgspec>]
msgspec ::= ComplexTypeName | (elementspec, ...)
----------------------------------

Here is one example with two alternatives:

[cols="asciidoc,asciidoc"]
|===
|
----------------------------------
getSomeInfo
    in ObjTarget
    out (string info, long? date)
----------------------------------
|
----------------------------------
struct GetSomeInfoResponse {
    string info;
    long?  date;
};

getSomeInfo
    in ObjTarget
    out GetSomeInfoResponse;
----------------------------------
|===

The left form defines a method:

-  named +getSomeInfo+;
-  taking a message of type +ObjTarget+ as input;
-  and returning a output message made of an anonymous type made of a sequence
   of a string named +info+ and an optional long integer named +date+.

The right form is actually completely equivalent, except that instead of using
an anonymous type for the output message, it explicitly instantiates a type
name for it, and then uses it. The right form is actually very near the
``WSDL'' way to describe SOAP operations. Though, we believe that adding all
the explicit fresh type names for each SOAP Message is detrimental to the
readability. That's why we will often prefer the ``left'' form in this
specification when the messages types aren't reused.

It is also to be noted that the ``in'' or ``out'' parts are optional. When
unspecified, the message carries no payload, only a single SOAP Body top-level
element is sent.

Last but not least, some of the Web-Service RPC can be marked as ``one-way'',
to support the SOAP operation semantics having the same name. This is a
fire-and-forget semantic where the SOAP Client sending the request won't pay
any attention to the HTTP answer made by the server (clients are actually
supposed to answer with an HTTP 200-OK or 202-Accepted status code without an
HTTP Entity). As a corollary, one-way methods cannot throw any exceptions.

==== Mapping from the Intersec notation to WSDL operations ====

For each RPC, the message names are constructed this way:

-   Input messages names are built with the RPC name with an appended ``Req''
    (as in Request);
-   Output messages names are built with the RPC name with an appended ``Res''
    (as in Response);
-   Exceptions for this query are built with the RPC name with an appended
    ``.Fault'' (with the leading dot).

[cols="header,4asciidoc"]
|===
| Method definition
|
----------------------------------
getSomeInfo
    in  ObjTarget
    out (string info, long? date)
----------------------------------

| Input Message
|
+getSomeInfoReq+, and the message type is +ObjTarget+

| Output Message
|
+getSomeInfoRes+, and the message type is an anonymous one equivalent to the
following type:

----------------------------------
struct GetSomeInfoResType {
    string info;
    long?  date;
};
----------------------------------

| Exception
|
If the method/operation can throw an exception, the exception message name will
be: +getSomeInfo.Fault+.

|===

// vim:ft=asciidoc
